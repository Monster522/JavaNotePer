## 线程的活性故障

线程活性故障是由资源稀缺性或者程序自身的问题和缺陷导致**线程一直处于非RUNNABLE状态**，或者线程虽然处于RUNNABLE状态但是**其要执行的任务却一直无法进展**的故障现象。

###1. 死锁

![](https://javanote.oss-cn-shenzhen.aliyuncs.com/9_死锁示意图.png)

- 死锁的定义

  如果两个或者更多的线程，因相互等待对方而被永远暂停(线程的生命周期状态为BLOCKED或者WAITING)，则是发生了死锁。

- 死锁的经典情形

  线程A 在持有锁L1的情况下申请锁L2, 而线程B 在持有锁L2的情况下申请锁L1。 A只有在获得并释放L2后才会
  释放L1, 而B只有在获得并释放L1后才会释放L2。

- 死锁的检测

  可以通过查看线程转储手工检测死锁，也可以利用ThreadMXBean.findDeadlockedThreads()方法进行死锁的自动检测。

####1.1死锁产生的条件与规避

- **产生死锁的必要不充分条件**

  只要产生了死锁，那么下面这些条件一定同时成立，但是上述条件即使同时成立也不一定就能产生死锁。

  1. 资源互斥(Mutual Exclusion) 

     涉及的资源必须是独占的，即每个资源一次只能够被一个线程使用。

  2. 资源不可抢夺(No Preemption)

     涉及的资源只能够被其持有者(线程)主动释放，而无法被资源的持有者和申请者之外的第三方线程所抢夺(被动释放)。

  3. 占用并等待资源(Hold and Wait)

     涉及的线程当前至少持有一个资源(资源A)并申请其他资源(资源B)，而这些资源(资源B)恰好被其他线程持有。在这个资源等待的过程中，线程并不释放其已经持有的资源。

  4. 循环等待资源(Circular Wait)

     涉及的线程必须在等待别的线程持有的资源，而这些线程又反过来在等待第1个线程所持有的资源。

- **规避死锁的方法**

  1. 粗锁法(Coarsen-grained Lock) -使用—个粗粒度的锁代替多个锁。

     采用一个粒度较粗的锁来替代原先的多个粒度较细的锁，这样涉及的线程都只需要申请一个锁从而避免了死锁。

  2. 锁排序法(Lock Ordering) -相关线程使用全局统一的顺序申请锁。

     假设有多个线程需要申请资源（锁）{Lock1, Lock2. …, Lock对，那么我们只需要让这些线程依照一个全局（相对于使用这种资源的所有线程而言）统一的顺序去申请这些资源，就可以消除"循环等待资源"这个条件，从而规避死锁。

  3. 使用ReentrantLock.tryLock(long, Time Unit)来申请锁。

     ReentrantLock. try Lock(long, Time Unit)允许我们为锁申请这个操作指定一个超时时间。

     使用tryLock(long, Time Unit)来申请锁可以避免一个线程无限制地等待另外一个线程持有的资源，从而最终能够消除死锁产生的必要条件中的"占用并等待资源"

  4. 使用开放调用(Open Call) - 在调用外部方法时不加锁。

  5. 使用锁的替代品 - 无状态对象、线程特有对象以及volatile关键字等

####1.2死锁的恢复

- 恢复的前提

  1. 如果代码中使用的是内部锁或者使用的是显式锁，而锁的申请是通过Lock.lock()调用实现的，那么这些锁的使用所导致的死锁故障是不可恢复的，而我们唯一能够做的就是重启Java虚拟机。
  2. 如果代码中使用的是显式锁，且锁的申请是通过Lock.locklnterruptibly()调用实现的，那么这些锁的使用所导致
     的死锁理论上是可恢复的。

- **死锁恢复的基本思路**

  1. 死锁的自动恢复有赖于线程的中断机制。
  2. 定义一个工作者线程DeadlockDetector专门用于死锁检测与恢复，该线程定期检测系统中是否存在死锁，若检测到死锁，则随机选取一个死锁线程并给其发送中断。该中断使得一个任意的死锁线程（目标线程）被Java虚拟机唤醒，从而使其抛出InterruptedException异常。
  3. 目标线程则通过对InterruptedException进行处理的方式来响应中断，目标线程捕获InterruptedException异常后将其已经持有的资源(锁)主动释放掉。

- 尽量不要进行死锁恢复

  对死锁进行的故障恢复尝试可能是徒劳的(故障线程可无法响应中断)且有害的(可能导致活锁等问题)。

###2 .锁死

等待线程由于唤醒其所需的条件永远无法成立．或者其他线程无法唤醒这个线程而**一直处于非运行状态(线程并未终止)**导致其任务一直无法进展，称为锁死(Lockout)。

####2.1 信号丢失锁死

- 定义

  信号丢失是指，由于没有相应的通知线程来唤醒等待线程而使等待线程一直处于等待状态。

- 典型例子

  1. 等待线程在执行Object.wait()/Condition.await()前没有对保护条件进行判断，而此时保护条件实际上可能已然成立。然而此后，可能并无其他线程更新相应保护条件涉及的共享变量，使其成立并通知等待线程。就使得等待线程一直处于等待状态，从而使其任务一直无法进展。
  2. CountDownLatch.countDown()调用没有放在finally块中导致CountDownLatch.await()的执行线程一直处于等待状态，从而使其任务一直无法进展。

####2.2 嵌套监视器锁死

- 定义

  嵌套监视器锁死是指，由于嵌套锁导致，通知线程始终无法唤醒等待线程的活性故障。

  ![](https://javanote.oss-cn-shenzhen.aliyuncs.com/10_嵌套锁锁死.png)

- 嵌套锁锁死和死锁的区别

  1. 在本质上，嵌套监视器锁死是由于通知线程无法获得锁，导致其无法唤醒等待线程，最终使等待线程永远处于等待状态的活性故障。
  2. 死锁是由于所有故障线程，都无法获得其所需的锁而导致的活性故障。

- 嵌套锁的检测

  嵌套监视器锁死可以通过查看线程转储进行检测。

- 嵌套锁的规避

  为规避嵌套监视器锁死，应该避免在嵌套锁的内层临界区内实现等待／通知。

###3 .线程饥饿

- 定义

  1. 线程饥饿是指，线程一直无法获得其所需的资源而导致其任务一直无法进展的一种活性故障。
  2. 线程饥饿涉及的线程，其生命周期状态不一定就是WATING或者BLOCKED状态，也有可能是RUNNING。

- 典型例子

  1. 在高争用的环境下使用非公平模式(Non-fair mode)的读写锁(ReentrantReadWriteLock)

     相应的读锁总是被业务线程抢先占有（非公平锁调度可能导致的结果）导致系统管理模块的线程始终无法获得相应的写锁，从而使其一直无法更新配置数据。

- 线程饥饿和死锁/活锁的关系

  1. 死锁是一种特殊的线程饥饿，此时线程饥饿涉及的线程，状态为WATING或者BLOCKED。且死锁所需要的全部锁中，一个锁都都无法获得。
  2. 活锁是一种特殊的线程饥饿，此时线程饥饿涉及的线程，状态为RUNNING。相当于，涉及的线程一直在申请其所需的资源。

###4 活锁

- 定义

  活锁(Livelock)是指，线程一直处于运行状态，但是其任务却一直无法进展的一种活性故障。