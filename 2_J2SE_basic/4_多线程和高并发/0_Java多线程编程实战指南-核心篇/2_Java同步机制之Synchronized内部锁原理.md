## Synchronized内部锁原理

### 1.基本介绍

- **作用**
  1. **原子性**
     - 确保线程互斥的访问同步代码。
  2. **可见性**
     - 保证共享变量的修改能够及时可见。
     - 在Java内存模型中，对一个变量unlock操作之前，必须要同步到主内存中。如果对一个变量进行lock操作，则将会清空工作内存中此变量的值。在执行引擎使用此变量前，需要重新从主内存中load操作或assign操作初始化变量值。
  3. **有序性**
     - 有效解决重排序问题，即一个unlock操作先行发生(happen-before)于后面对同一个锁的lock操作。

- **synchronized的三种用法**

  从语法上讲，`Synchronized`可以把任何一个非null对象作为"锁"，在HotSpot JVM实现中，锁有个专门的名字：对象监视器`(Object Monitor)`。 

  1. 当`synchronized`作用在**实例方法**时，监视器锁`(monitor)`便是对象实例`(this)`。

  2. 当`synchronized`作用在**静态方法**时，监视器锁`(monitor)`便是对象的`Class`实例，因为`Class`数据存在于永久代，因此静态方法锁相当于该类的一个全局锁。

  3. 当`synchronized`作用在**某一个对象实例**时，监视器锁`(monitor)`便是括号括起来的对象实例。

     

- **可重入性**
  
  1. synchronized内置锁是一种对象锁(锁的是对象而非引用变量)，作用粒度是对象，可以用来实现对临界资源的同步互斥访问，是可重入的。
  2. 其可重入性，最大的作用是避免死锁。如，**子类同步方法调用了父类同步方法，如没有可重入的特性，则会发生死锁。**

### 2.同步原理

- **内部锁和显式锁的底层实现**
  1. `synchronized`内部锁，在软件层面依赖于JVM。主要是通过`monitorenter`和`monitorexit`两个指令来实现， 两个指令的执行是`JVM`通过调用操作系统的互斥原语`mutex`来实现，被阻塞的线程会被挂起、等待重新调度，会导致“用户态和内核态”两个态之间来回切换，对性能有较大影响。 
  2. `J.U.C.Lock`接口显式锁，在硬件层面依赖特殊的CPU指令，就是CAS。

- **synchronized应用于对象实例**

  ```java
  // 持有this对象的锁
  public class SynchronizedDemo {
      public void method() {
          synchronized (this) {
              System.out.println("Method 1 start");
          }
      }
  }
  ```
  **反编译结果：**
  ![](https://javanote.oss-cn-shenzhen.aliyuncs.com/14_作用于this对象.png)
  
  1. **monitorenter指令**
     - 每个对象都是一个监视器锁(monitor)。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权。
     - 如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者。
     - 如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1。
     - 如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。

  2. **monitorexit指令**
     - 执行monitorexit的线程，必须是objectref所对应的monitor的所有者。
     - 指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者。
     - 其他被这个monitor阻塞的线程可以尝试去获取这个monitor的所有权。
     - monitorexit指令出现了两次，第1次为同步正常退出释放锁，第2次为发生异步退出释放锁。
  
  3. **Synchronized实现原理**
     - `Synchronized`的语义底层是通过一个`monitor`的对象来完成。
     - `wait/notify`等方法也依赖于`monitor`对象。
     - 只有在同步的块或者方法中才能调用`wait/notify`等方法，否则会抛出	`java.lang.IllegalMonitorStateException`的异常。

- **synchronized应用于实例方法**

  ```java
  // 作用于实例方法,相当于持有this对象的锁
  public class SynchronizedMethod {
      public synchronized void method() {
          System.out.println("Hello World!");
      }
  }
  ```
  **反编译结果：**
  ![](https://javanote.oss-cn-shenzhen.aliyuncs.com/15_作用于实例方法.png)

  1. 相对于普通方法，其常量池中多了`ACC_SYNCHRONIZED`标示符。JVM就是根据该标示符来实现方法的同步的。

  2. 当方法调用时，调用指令将会检查方法的`ACC_SYNCHRONIZED`访问标志是否被设置。
  
  3. 如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。
  
  4. 在方法执行期间，其他任何线程都无法再获得同一个monitor对象。
  
  5. 两种同步方式本质上没有区别，只是方法的同步是一种隐式的方式来实现，无需通过字节码来完成。 
  
     

###3.锁在字节码中的实现

#### 3.1Java对象头

- **对象在内存中的布局**

  ![](https://javanote.oss-cn-shenzhen.aliyuncs.com/16_对象的存储数据.png)

  1. **实例数据**
     - 存放类的属性数据信息，包括父类的属性信息。
  2. **对齐填充**
     - 由于虚拟机要求 对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐。
  3. **对象头**
     - Java对象头一般占有2个机器码(在32位虚拟机中，1个机器码等于4字节，也就是32bit，在64位虚拟机中，1个机器码是8个字节，也就是64bit)。
     - 但如果对象是数组类型，则需要3个机器码，因为JVM虚拟机可以通过Java对象的元数据信息确定Java对象的大小，但是无法从数组的元数据来确认数组的大小，所以用一块来记录数组长度。

- **对象头的结构**

  ![](https://javanote.oss-cn-shenzhen.aliyuncs.com/17_对象头的结构.png)

  1. Hotspot虚拟机的对象头主要包括两部分数据：Mark Word(标记字段)、Class Pointer(类型指针)。
  2. 其中Class Pointer是对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。
  3. Mark Word用于存储对象自身的运行时数据，是实现轻量级锁和偏向锁的关键。 
  4. Mark Word用于存储对象自身的运行时数据，如：哈希码(HashCode)、GC分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等。比如锁膨胀就是借助Mark Word的偏向的线程ID。

- **MarkWord部分结构**

  1. 对象头信息是与对象自身定义的数据无关的额外存储成本，但是考虑到虚拟机的空间效率，MarkWord被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据，它会根据对象的状态复用自己的存储空间。

  2. **64位虚拟机的MarkWord结构**

     ![](https://javanote.oss-cn-shenzhen.aliyuncs.com/18_64位标记部分结构.png)

  3. **MarkWord的四种数据状态**

     ![](https://javanote.oss-cn-shenzhen.aliyuncs.com/19_Markword的四种数据状态.png)

     - 对象头的最后两位存储了锁的标志位，01是初始状态，未加锁，其对象头里存储的是对象本身的哈希码。
     - 随着锁级别的不同，对象头里会存储不同的内容。偏向锁存储的是当前占用此对象的线程ID，而轻量级则存储指向线程栈中锁记录的指针。
     - **锁在字节码中的体现**
       1. 可能是个锁记录+对象头里的引用指针(判断线程是否拥有锁时，将线程的锁记录地址和对象头里的指针地址比较)。
       2. 也可能是对象头里的线程ID(判断线程是否拥有锁时，将线程的ID和对象头里存储的线程ID比较)。 

#### 3.2对象头中MarkWord与线程中LockRecord

- **线程LockRecord定义**
  
  1. 在线程进入同步代码块的时候，如果此同步对象没有被锁定，即它的锁标志位是01，则虚拟机首先在当前线程的栈中创建“锁记录(Lock-Record)”的空间，用于存储锁对象的Mark Word的拷贝，官方把这个拷贝称为Displaced-Mark-Word。整个MarkWord及其拷贝至关重要。
  2. LockRecord是线程私有的数据结构，每一个线程都有一个可用LockRecord列表，同时还有一个全局的可用列表。
  3. 每一个被锁住的对象MarkWord都会和一个LockRecord关联，对象头的MarkWord中的LockWord指向LockRecord的起始地址。
  4. 同时LockRecord中有一个Owner字段，存放拥有该锁的线程的唯一标识(或者object-mark-word)，表示该锁被这个线程占用。
  
- **LockRecord结构**

  | LockRecord | 描述                                                         |
  | ---------- | ------------------------------------------------------------ |
  | Owner      | 初始时为NULL表示当前没有任何线程拥有该monitor record，当线程成功拥有该锁后保存线程唯一标识，当锁被释放时又设置为NULL。 |
  | EntryQ     | 关联一个系统互斥锁(semaphore)，阻塞所有试图锁住monitor record失败的线程。 |
  | RcThis     | 表示blocked或waiting在该monitor record上的所有线程的个数。   |
  | Nest       | 用来实现 重入锁的计数。                                      |
  | HashCode   | 保存从对象头拷贝过来的HashCode值(可能还包含GC age)。         |
  | Candidate  | 用来避免不必要的阻塞或等待线程唤醒，因为每一次只有一个线程能够成功拥有锁，如果每次前一个释放锁的线程唤醒所有正在阻塞或等待的线程，会引起不必要的上下文切换(从阻塞到就绪然后因为竞争锁失败又被阻塞)从而导致性能严重下降。Candidate只有两种可能的值，0表示没有需要唤醒的线程，1表示要唤醒一个继任线程来竞争锁。 |

  

#### 3.3监视器(Monitor)

- **Synchronized在JVM的实现**
  
  1. **任何一个对象都有一个Monitor与之关联**，**当且一个Monitor被持有后，它将处于锁定状态**。
  
  2. Synchronized在JVM里，都是基于进入和退出Monitor对象来实现方法同步和代码块同步，虽然具体实现细节不一样，但是都可以通过成对的MonitorEnter和MonitorExit指令来实现。
  
  3. **MonitorEnter指令**，插入在同步代码块的开始位置，当代码执行到该指令时，将会尝试获取该对象Monitor的所有权，即尝试获得该对象的锁。
  
  4. **MonitorExit指令**，插入在方法结束处和异常处，JVM保证每个MonitorEnter必须有对应的MonitorExit。
  
     

- **Monitor的定义**
  
  1. `Monitor`是一个同步工具，也可以描述为一种同步机制，通常被描述为一个对象。
  
  2. 所有的`Java`对象是天生的`Monitor`，对象从创建后就带了一把看不见的锁，被叫做内部锁或者`Monitor`锁。
  
  3. **通常说`Synchronized`的对象锁，`MarkWord`锁标识位为10，其中指针指向的是`Monitor`对象的起始地址。**
  
  4. 在Java虚拟机`(HotSpot)`中，**Monitor是由ObjectMonitor实现的**，位于`HotSpot`虚拟机源码`ObjectMonitor.hpp`文件，`C++`实现的。
  
     
  
- **ObjectMonitor的定义**

  ```java
  /**
  * 1. ObjectMonitor中有两个队列_WaitSet 和 _EntryList，用来保存ObjectWaiter对象列表.
  * 2. 每个等待锁的线程都会被封装成ObjectWaiter对象.
  * 3. _owner指向持有ObjectMonitor对象的线程.
  **/
  ObjectMonitor() {
      _header       = NULL;
      // 记录个数
      _count        = 0; 
      _waiters      = 0,
      _recursions   = 0;
      _object       = NULL;
      _owner        = NULL;
      // 处于wait状态的线程，会被加入到_WaitSet
      _WaitSet      = NULL; 
      _WaitSetLock  = 0 ;
      _Responsible  = NULL ;
      _succ         = NULL ;
      _cxq          = NULL ;
      FreeNext      = NULL ;
      // 处于等待锁block状态的线程，会被加入到该列表
      _EntryList    = NULL ; 
      _SpinFreq     = 0 ;
      _SpinClock    = 0 ;
      OwnerIsThread = 0 ;
    }
  ```

  **当多个线程同时访问一段同步代码时**

  1. 首先会进入**_EntryList**集合，当线程获取到对象的monitor后，进入**_Owner**区域并把monitor中的owner变量设置为当前线程，同时monitor中的计数器count加1。

  2. 若线程调用wait()方法，将释放当前持有的monitor，owner变量恢复为null，count自减1，同时该线程进入**_WaitSet**集合中等待被唤醒。

  3. 若当前线程执行完毕，也将释放monitor(锁)并复位count的值，以便其他线程进入获取monitor(锁)。

     

- **Monitor对象和Java对象的联系**
  1. `Monitor`对象存在于每个Java对象的对象头`MarkWord`中(存储的指针的指向)，`Synchronized`锁便是通过这种方式获取锁的，所以`Java`中任意对象可以作为锁。
  2. 同时`notify/notifyAll/wait`等方法会使用到`Monitor`锁对象，所以必须在同步代码块中使用。

- **Monitor的同步方式：互斥**

  1. 多线程环境下线程之间如果需要共享数据，需要解决互斥访问数据的问题，监视器可以确保监视器上的数据在同一时刻只会有一个线程在访问。

  

- **Monitor的同步方式：协作**

  1. 一个线程向缓冲区写数据，另一个线程从缓冲区读数据。
  2. 如果读线程发现缓冲区为空就会等待，当写线程向缓冲区写入数据，就会唤醒读线程，这里读线程和写线程就是一个合作关系。
  3. JVM通过Object类的wait方法来使自己等待，在调用wait方法后，该线程会释放它持有的监视器，直到其他线程通知它才有执行的机会。
  4. 一个线程调用notify方法通知在等待的线程，这个等待的线程并不会马上执行，而是要通知线程释放监视器后，它重新获取监视器才有执行的机会。
  5. 如果刚好唤醒的这个线程需要的监视器被其他线程抢占，那么这个线程会继续等待。
  6. Object类中的notifyAll方法可以解决这个问题，它可以唤醒所有等待的线程，总有一个线程执行。

- **协作实例**

  ![](https://javanote.oss-cn-shenzhen.aliyuncs.com/20_Monitor对象的协作.png)

  1. 一个线程通过1号门进入EntrySet(入口区)，如果在入口区没有线程等待，那么这个线程就会获取监视器成为监视器的Owner，然后执行监视区域的代码。
  2. 如果在入口区中有其它线程在等待，那么新来的线程也会和这些线程一起等待。
  3. 线程在持有监视器的过程中，有两个选择。
     - 一个是正常执行监视器区域的代码，释放监视器，通过5号门退出监视器。
     - 另一个可能是等待某个条件的出现，于是它会通过3号门到WaitSet(等待区)休息，直到相应的条件满足后再通过4号门进入重新获取监视器再执行。
  4. 当一个线程释放监视器时，在入口区和等待区的等待线程都会去竞争监视器，如果入口区的线程赢了，会从2号门进入。如果等待区的线程赢了会从4号门进入。
  5. 只有通过3号门才能进入等待区，在等待区中的线程只有通过4号门才能退出等待区。
  6. 也就是说一个线程只有在持有监视器时才能执行wait操作，处于等待的线程只有再次获得监视器才能退出等待状态。



### 4.锁的优化

- **JDK对锁的优化**
  1. 从JDK6开始，就对synchronized的实现机制进行了较大调整，包括使用JDK5引进的CAS自旋之外，还增加了自适应的CAS自旋、锁消除、锁粗化、偏向锁、轻量级锁这些优化策略。
  2. 由于此关键字的优化使得性能极大提高，同时语义清晰、操作简单、无需手动关闭，所以推荐在允许的情况下尽量使用此关键字，同时在性能上此关键字还有优化的空间。
  3. 在JDK1.6中默认是开启偏向锁和轻量级锁的，可以通过-XX:-UseBiasedLocking来禁用偏向锁。
  4. 锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁。但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级。

#### 4.1自旋锁

- **应用背景**
  1. 线程的阻塞和唤醒需要CPU从用户态转为核心态，频繁的阻塞和唤醒对CPU来说是一件负担很重的工作，势必会给系统的并发性能带来很大的压力。
  2. 在许多应用上面，对象锁的锁状态只会持续很短一段时间，为了这一段很短的时间频繁地阻塞和唤醒线程是非常不值得的。

- **自旋锁的定义**
  1. 指当一个线程尝试获取某个锁时，如果该锁已被其他线程占用，就一直循环检测锁是否被释放，而不是进入线程挂起或睡眠状态。
  2. 自旋锁适用于锁保护的临界区很小的情况，临界区很小的话，锁占用的时间就很短。


- **作用**
  1. 自旋等待不能替代阻塞，虽然它可以避免线程切换带来的开销，但是它占用了CPU处理器的时间。
  2. 如果持有锁的线程很快就释放了锁，那么自旋的效率就非常好，反之，自旋的线程就会白白消耗掉处理的资源。
  3. 所以说，自旋等待的时间(自旋的次数)必须要有一个限度，如果自旋超过了定义的时间仍然没有获取到锁，则应该被挂起。


- **自旋锁开启**
  1. 自旋锁在JDK1.4.2中引入，默认关闭，但是可以使用-XX:+UseSpinning开开启，在JDK1.6中默认开启。同时自旋的默认次数为10次，可以通过参数-XX:PreBlockSpin来调整。
  2. 如果通过参数-XX:PreBlockSpin来调整自旋锁的自旋次数，会带来诸多不便。假如将参数调整为10，但是系统很多线程都是等你刚刚退出的时候就释放了锁(假如多自旋一两次就可以获取锁)，是不是很尴尬。
  3. JDK1.6引入自适应的自旋锁，让虚拟机会变得越来越聪明。

#### 4.2适应性自旋锁

- **自适应自旋定义**
  1. 自适应就意味着自旋的次数不再是固定的，它是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。

- **原理**
  1. 线程如果自旋成功了，那么下次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多。
  2. 反之，如果对于某个锁，很少有自旋能够成功，那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。

#### 4.3锁消除

- **定义**
  1. 在有些情况下，JVM检测到不可能存在共享数据竞争，这是JVM会对这些同步锁进行锁消除。
  2. 锁消除的依据是逃逸分析的数据支持。
  3. 锁消除可以节省毫无意义的请求锁的时间。

#### 4.4锁粗化

- **定义**
  1. 在使用同步锁的时候，需要让同步块的作用范围尽可能小。
  2. 仅在共享数据的实际作用域中才进行同步，目的是为了使需要同步的操作数量尽可能缩小，如果存在锁竞争，那么等待锁的线程也能尽快拿到锁。
  3. 但是如果一系列的连续加锁解锁操作，可能会导致不必要的性能损耗。
  4. 锁粗化就是将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。

- **实例**
  1. vector每次add的时候都需要加锁操作，JVM检测到对同一个对象(vector)连续加锁、解锁操作，会合并一个更大范围的加锁、解锁操作，即加锁解锁操作会移到for循环之外。

#### 4.5偏向锁

- **定义**
  
  1. 在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低，引进了偏向锁。

  2. **偏向锁是在单线程执行代码块时使用的机制**，如果在多线程并发的环境下(即线程A尚未执行完同步代码块，线程B发起了申请锁的申请)，则一定会转化为轻量级锁或者重量级锁。
  
  3. 在偏向锁中，是没有引入Monitor对象的，只有在对象头的MarkWord中记录了线程ID。
  
     
  
- **JVM参数**
  
  1. 在JDK5中偏向锁默认是关闭的，而到了JDK6中偏向锁已经默认开启。

  2. 如果并发数较大同时同步代码块执行时间较长，则被多个线程同时访问的概率就很大，就可以使用参数-XX:-UseBiasedLocking来禁止偏向锁(但这是个JVM参数，不能针对某个对象锁来单独设置)。
  
     
  
- **作用**
  
  1. 为了在没有多线程竞争的情况下(不代表没有多个线程，只是多线程没有竞争)，尽量减少不必要的轻量级锁执行路径。
  
  2. 因为轻量级锁的加锁解锁操作是需要依赖多次CAS原子指令的，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令。

  3. 由于一旦出现多线程竞争的情况就必须撤销偏向锁，所以偏向锁的撤销操作的性能损耗也必须小于节省下来的CAS原子指令的性能消耗。
  
  4. **轻量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进一步提高性能。**
  
     
  
- **偏向锁减少CAS的原理**
  
  1. 现在几乎所有的锁都是可重入的，即已经获得锁的线程可以多次锁住/解锁监视对象.
  
  2. 按照之前的HotSpot设计，每次加锁/解锁都会涉及到一些CAS操作(比如对等待队列的CAS操作)，CAS操作会延迟本地调用。

  3. 因此偏向锁的基本思想是，一旦线程第一次获得了监视对象，之后让监视对象“偏向”这个线程，之后的多次调用则可以避免CAS操作。
  
  4. 本质上就是置个变量，如果发现为true则无需再走各种加锁/解锁流程。
  
     
  
- **线程应用偏向锁的具体流程**
  当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID。以后**该线程进入和退出同步块时不需要花费CAS操作来争夺锁资源**，只需要检查是否为偏向锁、锁标识为以及ThreadID即可。
  
  1. 检测MarkWord是否为可偏向状态，即是否为偏向锁1，锁标识位为01。
  2. 若为可偏向状态，则测试线程ID是否为当前线程ID，如果是，则执行步骤(5)，否则执行步骤(3)。
  3. 如果测试线程ID不为当前线程ID，则通过CAS操作竞争锁，竞争成功，则将MarkWord的线程ID替换为当前线程ID，否则执行线程(4)。
  4. 通过CAS竞争锁失败，证明当前存在多线程竞争情况，当到达全局安全点，获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码块。
  5. 执行同步代码块。此时执行线程还是持有同步块的锁，以防有其他线程来竞争。一旦发现有其他线程竞争失败的情况，偏向锁就会升级成轻量级锁。

- **偏向锁的升级或撤销**
  偏向锁的释放采用了一种**只有竞争才会释放锁的机制**，**线程是不会主动去释放偏向锁，需要等待其他线程来竞争**。偏向锁的撤销需要，等待全局安全点(这个时间点是上没有正在执行的代码)。
  1. 暂停拥有偏向锁的线程。
  2. 判断锁对象是否还处于被锁定状态。
     - 如果没有被锁定，则恢复到无锁状态(01)，以允许其余线程竞争。
     - 如果有被锁定，则挂起持有锁的当前线程，并将指向当前线程的锁记录地址的指针放入对象头MarkWord，升级为轻量级锁状态(00)，然后恢复持有锁的当前线程，进入轻量级锁的竞争模式。
  3. 当前线程挂起再恢复的过程中并没有发生锁的转移，仍然在当前线程手中，只是穿插了个 “将对象头中的线程ID变更为指向锁记录地址的指针” 这么个事。

- **偏向锁的获取和释放**

  1. 当线程1持有偏向锁的时候，MarkWord中的线程ID是线程1的。当执行完成，就会将MarkWord置空，无锁状态。
  2. 当线程2来竞争的时候，会通过CAS修改，如果失败就存在多线程竞争。CAS会失败的原因是，预期值是偏向锁的线程ID为null，所以会修改失败。
  3. 此时将偏向锁升级为轻量级锁。

  ![](https://javanote.oss-cn-shenzhen.aliyuncs.com/21_偏向锁的获取和释放.png)

#### 4.6轻量级锁

- **作用**

  1. 在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。

     

- **应用场景**

  1. 轻量级是相对于使用操作系统互斥量来实现的传统锁而言的。
  2. 轻量级锁并不是用来代替重量级锁的，它的本意是**在没有多线程竞争的前提下，减少传统的重量级锁使用产生的性能消耗。**
  3. 轻量级锁所**适应的场景是线程交替执行同步块的情况**，如果存在同一时间访问同一锁的情况，必然就会导致轻量级锁膨胀为重量级锁。
  4. 轻量级锁不会导致线程阻塞，只是会自旋等待。


- **轻量级锁的获取流程**

  1. 在线程进入同步块时，如果同步对象锁状态为无锁状态(锁标志位为“01”状态，是否为偏向锁为“0”)，**虚拟机首先将在当前线程的栈帧中建立一个名为锁记录(LockRecord)的空间，用于存储锁对象目前的MarkWord的拷贝**，官方称之为DisplacedMarkWord。

  2. 拷贝对象头中的MarkWord复制到锁记录(LockRecord)中。

  3. 拷贝成功后，虚拟机将使用CAS操作尝试将对象MarkWord中的LockWord更新为指向当前线程LockRecord的指针，并将Lockrecord里的owner指针指向objectmarkword。如果更新成功，则执行步骤(4)，否则执行步骤(5)。

  4. 如果这个更新动作成功了，那么当前线程就拥有了该对象的锁，并且对象MarkWord的锁标志位设置为“00”，即表示此对象处于轻量级锁定状态，此时线程堆栈与对象头的状态如下图所示。

     ![](https://javanote.oss-cn-shenzhen.aliyuncs.com/23_线程堆栈情况轻量级锁.png)

  5. 如果这个更新操作失败了，虚拟机首先会检查对象MarkWord中的LockWord是否指向当前线程的栈帧，如果是，就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行。否则说明多个线程竞争锁，进入自旋执行(3)，若自旋结束时仍未获得锁，轻量级锁就要膨胀为重量级锁，锁标志的状态值变为“10”，MarkWord中存储的就是指向重量级锁(互斥量)的指针，当前线程以及后面等待锁的线程也要进入阻塞状态。

  

- **轻量级锁的释放**

  1. 通过`CAS`操作尝试把线程中复制的`DisplacedMarkWord`对象，就是无锁状态的`MarkWord`，去覆盖当前的`MarkWord`。

  2. 如果替换成功，整个同步过程就完成了，恢复到无锁状态(01)。

  3. 如果替换失败，说明有其他线程尝试过获取该锁(此时锁已膨胀)，那就要在释放锁的同时，唤醒被挂起的线程。

     

- **轻量级锁的膨胀流程**

  ![](https://javanote.oss-cn-shenzhen.aliyuncs.com/22_轻量级锁的流程.png)

- **常见问题**

  1. **为什么升级为轻量锁时要把对象头里的Mark Word复制到线程栈的锁记录中呢？**

     - 因为在申请对象锁时，需要以该值作为CAS的比较条件。
     - 同时在升级到重量级锁的时候，能通过这个比较判定是否在持有锁的过程中此锁被其他线程申请过，如果被其他线程申请了，则在释放锁的时候要唤醒被挂起的线程。

  2. **为什么会尝试CAS不成功以及什么情况下会不成功？**

    **CAS本身是不带锁机制的，其是通过比较而来。**
    
    假设如下场景：
    1. 线程A和线程B都在对象头里的锁标识为无锁状态进入，那么如线程A先更新对象头为其锁记录指针成功之后，线程B再用CAS去更新，就会发现此时的对象头已经不是其操作前的对象HashCode了，所以CAS会失败。
    2. 也就是说，只有两个线程并发申请锁的时候会发生CAS失败。
    3. 然后线程B进行CAS自旋，等待对象头的锁标识重新变回无锁状态，或对象头内容等于对象HashCode(因为这是线程B做CAS操作前的值)。
    4. 这也就意味着线程A执行结束(参见后面轻量级锁的撤销，只有线程A执行完毕撤销锁了才会重置对象头)，此时线程B的CAS操作终于成功了，于是线程B获得了锁以及执行同步代码的权限。
    5. 如果线程A的执行时间较长，线程B经过若干次CAS时钟没有成功，则锁膨胀为重量级锁，即线程B被挂起阻塞、等待重新调度。
    
    
    
#### 4.7重量级锁

- **定义**
  1. `Synchronized`是通过对象内部的一个叫做监视器锁`(Monitor)`来实现的。
  2. 但是监视器锁本质又是依赖于底层的操作系统的`MutexLock`来实现的。
  3. 而操作系统实现线程之间的切换这就需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么`Synchronized`效率低的原因。
  4. 这种依赖于操作系统`MutexLock`所实现的锁我们称之为“重量级锁”。



#### 4.8重量级锁、轻量级锁和偏向锁之间转换

- **转换流程**

  ![](https://javanote.oss-cn-shenzhen.aliyuncs.com/24_锁之间的转换.png)

  

- **详细流程**

  ![](https://javanote.oss-cn-shenzhen.aliyuncs.com/25_锁转换的详细流程图.png)



### 5.锁的优劣

- **常见应用场景**

  1. 如果是单线程使用，那偏向锁毫无疑问代价最小，并且它就能解决问题，连CAS都不用做，仅仅在内存中比较下对象头就可以了。

  2. 如果出现了其他线程竞争，则偏向锁就会升级为轻量级锁。

  3. 如果其他线程通过一定次数的CAS尝试没有成功，则进入重量级锁。

  4. 每种锁是只能升级，不能降级，即由偏向锁 -> 轻量级锁 -> 重量级锁，而这个过程就是开销逐渐加大的过程。 

     

- **各种锁之间的区别**

  ![](https://javanote.oss-cn-shenzhen.aliyuncs.com/26_锁的优劣比较.png)