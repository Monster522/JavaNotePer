## 线程安全的代码设计

- 主要内容：从面向对象设计的角度出发，保障线程安全的常用技术。**在不必借助锁的情况下保障线程安全**，从而既避免锁可能导致的问题以及开销又有利于提高系统的并发性并简化代码。

###1 .Java运行时存储空间

- 存储空间划分

  1. Java 运行时(Java Runtime) 空间可以分为堆(Heap) 空间、栈(Stack) 空间和非堆(Non-Heap)空间。
  2. 堆空间和非堆空间是可以被多个线程共享的。实例变量和静态变量是线程间可共享的。
  3. 栈空间则是线程的私有空间，每个线程都有其栈空间，并且一个线程无法访问其他线程的栈空间。局部变量是无法被多个线程共享的。

- 堆空间

  1. 本身空间创建

     堆空间本身是在Java 虚拟机启动的时候分配的一段可以动态扩容的内存空间。

  2. 堆空间(Heap space) 用于存储对象 - 作用1

     创建一个实例的时候，该实例所需的存储空间是在堆空间中进行分配的。

     类的实例变量是存储在堆空间中的。

  3. 垃圾回收器的主要工作场所 - 作用2

     堆空间中没有可达引用的对象（不再被使用的对象）所占用的存储空间会被垃圾回收器回收。

     年轻代GC称为次要回收，老年代GC称为主要回收。

- 栈空间

  1. 本身空间创建

     栈空间是在线程创建的时候分配的。

  2. 存储内容

     为线程的执行而准备的一段固定大小的内存空间，每个线程都有其栈空间。

     Java虚拟机，会在该线程的栈空间中为这个方法调用创建一个栈帧(Frame)，栈帧用于存储相应方法的局部变量、返回值等私有数据。

- 非堆空间

  1. 本身空间创建

     在Java 虚拟机启动的时候分配的一段可以动态扩容的内存空间。

  2. 存储内容

     用于存储常量以及类的元数据(Meta-data) 等，类的元数据包括类的静态变量、类有哪些方法以及这些方法的元数据（包括名称、参数和返回值等）。

###2 .无状态对象

#### 2.1基本定义

- 对象

  对象(Object) 就是操作和数据的封装。

- 对象的状态

  1. **对象所包含的数据就被称为该对象的状态(`State`), 包括存储在实例变量或者静态变量之中的数据**。

  2. 一个对象的状态也可能包含，**该对象引用的其他对象的实例变量或者静态变量中的数据**。

  3. 实例变量、静态变量也被称为状态变量(`StateVariable`)。

- 无状态对象

  1. **如果一个类的同一个实例被多个线程共享，并不会使这些线程存在共享状态(`SharedState`)** , 这个类或者其任意一个实例被称为无状态对象(`StatelessObject`)。
  2. **无状态对象不含任何实例变量**， 且**不包含任何静态变量**或者**其包含的静态变量都是只读的**（常量）。

- 有状态对象

  1. 如果一个类的同一个实例被多个线程共享，会使这些线程存在共享状态，那么这个类及其任意一个实例就被称为有状态对象(StatefulObject)。
  2. 有状态对象又可以分为，**状态可变对象**和**状态不可变对象**。
  3. 所谓状态可变就是，**对象在其生命周期中，其状态变量的值可以发生变化**。

#### 2.2无状态对象与线程安全

- 线程安全的保障
  1. 实现线程安全的一种自然的方法就是，避免在多个线程之间共享数据。
  2. 一个线程执行无状态对象的任意一个方法来完成某个计算的时候，该计算的瞬时状态（中间结果）仅体现在局部变量和（或）只有当前执行线程能够访问的对象的状态上。
  3. 一个线程执行无状态对象的任何方法，都不会对访问该无状态对象的其他线程产生任何干扰作用。
  4. **无状态对象具有固有的线程安全性**。
- 无状态对象具有线程安全性的体现
  1. 无状态对象的客户端代码，在调用该对象的任何方法时都无须加锁。
  2. 无状态对象自身的方法实现，也无须使用锁。
- **无状态对象的充分必要条件**
  1. 无状态对象不包含任何实例变量或者可更新静态变量（包括来自相应类的上层类的实例变量或者静态变量）。
  2. 无状态对象的方法中不能存在非线程安全对象。
  3. 无状态对象不包含任何实例变量或者可更新静态变量，但一个类不包含任何实例变量或者静态变量却不一定是无状态对象。

###3. 不可变对象

- 不可变对象

  1. 不可变对象(Immutable Object)是指**一经创建其状态就保持不变的对象**。
  2. 不可变对象也可以像无状态对象那样被多个线程共享，而这些线程访问这些共享对象的时候无须加锁。

- **不可变对象的充分必要条件**

  1. 类本身使用final修饰：为了防止通过创建子类来改变其定义的行为。
  2. 所有字段都是用final修饰的：从语义上说明被修饰字段的值不可改变，同时也保证初始化安全。
  3. 对象在此初始化过程中没有逸出(Escape) : 防止其他类(如该类的内部匿名类)在对象初始化过程中修改其状态。
  4. 任何字段，若其引用了其他状态可变的对象(如集合、数组等)，则这些字段必须是private修饰的，并且这些字段值不能对外暴露。若有相关方法要返回这些字段值，则应该进行防御性复制(Defensive Copy) 

- 更新不可变对象

  1. 当不可变对象所建模的现实实体的状态发生变化时，系统通过创建新的不可变对象实例来进行反映。

- 对垃圾回收的影响

  1. 缺点

     系统的状态频繁变更或者不可变对象所占用内存空间比较大时，**不可变对象的不断创建会增加垃圾回收的负担**。

  2. 优点

     创建不可变对象往往导致，堆空间年轻代中的对象(新创建的不可变实例)引用年老代中的对象，有利于降低垃圾回收的开销。

- 不可变对象的引用变量

  虽然不可变对象自身的实例变量或者静态变最的值是不可改变的，但是这些变量所引用的对象本身的状态可能是可变的。可以通过两个方面来采取措施。

  1. 一种是使用迭代器(Iterator)模式，即让相应的不可变对象实现Iterable接口，然后在该接口定义的iterator方法中返回一个只读的Iterator实例（它不支持remove方法）。
  2. 采取防御性复制(Defensive Copy)。

- 应用场景

  1. 被建模对象的状态变化不频繁。
  2. 同时对一组相关的数据进行写操作，因此需要保证原子性。
  3. 使用不可变对象作为安全可靠的Map键( Key ) 。

###4 .线程特有对象

#### 4.1线程局部变量

- 线程特有对象基本定义

  各个线程创建各自的实例，一个实例只能被一个线程访问的对象，称为线程特有对象(TSO. Thread Specific Object)

- 作用

  1. 固有的线程安全性。

     线程特有对象，既保障了对非线程安全对象的访问的线程安全，又避免了锁的开销。

  2. 减少线程安全类的锁开销

     一些线程安全类内部是用锁来实现的，如果用线程特有对象去创建线程安全类，可以减少锁的开销。

  3. 有利于减少对象的创建次数

     一个线程往往只需要该对象的一个实例，这个实例可以被该线程(同一个线程)所执行的多个方法(包括不同类的方法)共享，有利于减少对象的创建次数。

- **线程局部变量(ThreadLocal类)**

  1. ThreadLocal<T>类相当于**线程访问其线程特有对象的代理(Proxy)**，即**各个线程通过这个对象可以创建并访问各自的线程特有对象**，其类型参数T指定了相应线程特有对象的类型。
  2. 每个ThreadLocal<T>实例都有一个(且只有一个)当前线程的特有对象T的实例与之关联。
  3. ThreadLocal实例也被称为线程局部变量(`Thread-local Variable`)

- ThreadLocal类的常用方法

  | 方法                       | 功能                                                         |
  | -------------------------- | ------------------------------------------------------------ |
  | public T get()             | 获取与该线程局部变量关联的 当前线程的 线程特有对象           |
  | public void set(T value)   | 重新关联该线程局部变量所对应的 当前线程的 线程特有对象       |
  | protected T initialValue() | 该方法的返回值(对象)是初始状态下 该线程局部变量所对应的当前线程的线程特有对象 |
  | public void remove()       | 删除该线程局部变量与相应的 当前线程的 线程特有对象之间的 关联关系 |

- ThreadLocal类应用实例

  ```java
  /**
  * 线程局部变量通常是会被声明为某个类的静态变量
  * 原因：如果把线程局部变量声明为某个类的实例变量，那么每创建该类的一个实例都会导致新的ThreadLocal实例被创建,
  *      导致当前线程中同一个类型的线程特有对象会被多次创建。
  **/
  public class ThreadLocalTest {
      // 1. 初始化线程局部变量
      final static ThreadLocal<SimpleDateFormat> SDF = new ThreadLocal<SimpleDateFormat>(){
          @Override
          protected SimpleDateFormat initialValue() {
              return new SimpleDateFormat("yyyy-MM-dd");
          }
      };
  
      // 2. 线程局部变量get()方法,获取线程特有对象SimpleDateFormat
      public void test(){
          System.out.println(SDF.get().format(new Date()));
      }
  }
  ```

####4.2 线程特有对象可能导致的问题及其规避

- 退化与数据错乱

  1. 在一个线程可以执行多个任务的情况下(比如在生产者—消费者模式中)使用线程特有对象，需要确保每个任务的处理逻辑被执行前相应的线程特有对象的状态不受前一个被执行的任务影响。
  2. 可以通过在任务处理逻辑被执行前，为线程局部变最重新关联一个线程特有对象(通过调用ThreadLocal.set(T)实现)或者重置线程特有对象的状态来实现。

  ```java
  public class ThreadLocalTest {
  
      // 1. 初始化线程局部变量
      final static ThreadLocal<SimpleDateFormat> SDF = new ThreadLocal<SimpleDateFormat>(){
          @Override
          protected SimpleDateFormat initialValue() {
              return new SimpleDateFormat("yyyy-MM-dd");
          }
      };
  
      // 2. 线程局部变量get()方法,获取线程特有对象SimpleDateFormat
      public void test(){
          before();
          System.out.println(SDF.get().format(new Date()));
      }
  
      // 在执行每个任务之前,重置线程特有对象
      private void before(){
          SDF.set(new SimpleDateFormat());
      }
  }
  ```

- **ThreadLocal 可能导致内存泄漏、伪内存泄漏**

  1. 内存泄漏(Memory Leak)指，由于对象永远无法被垃圾回收，导致其占用的Java虚拟机内存无法被释放。持续的内存泄漏会导致Java虚拟机可用内存逐渐减少，并最终可能导致Java虚拟机内存溢出(Out of Memory), 直到Java虚拟机宕机。

  2. 伪内存泄漏(Memory Pseudo-leak)类似于内存泄漏。伪内存泄漏中对象占用的内存空间可能会被回收，也可能永
     远无法被回收(此时就变成了内存泄漏)。

  3. 导致内存泄漏的原因

     ![](https://javanote.oss-cn-shenzhen.aliyuncs.com/8_线程局部变量和线程特有对象.png)

     - **ThreadLocal在线程的实现机制**

       对于线程局部变量，每个线程内部会维护一个类似HashMap的对象，称为ThreadLoca!Map。

       ThreadLocalMap内部会包含若干Entry(条目一个键Key-值Value对)。Entry的Key是一个ThreadLocal实例，Value是一个线程特有对象。

       Entry的作用相当于为其属主线程建立起一个ThreadLocal实例与一个线程特有对象之间的对应关系。

       当ThreadLocalMap中有新的ThreadLocal到线程特有对象的映射(对应)关系被创建，ThreadLocalMap 会将无效条目清理掉，使得线程特有对象被回收。

     - 引发内存泄漏

       一个线程访问过线程局部变量之后如果该线程有对其可达的强引用，并且该线程在相当长时间内（甚至一直）处于非运行状态。可能导致这些线程的各个Entry所引用的线程特有对象都无法被垃圾回收，即导致了伪内存
       泄漏。

     - 解决方法

       通过在当前线程中调用ThreadLocal.remove()将线程特有对象从其所属的Entry中剥离（清理），便可以使线程特有对象以及线程局部变量都可以被垃圾回收。

       对于同一个ThreadLocal 实例，ThreadLocal.remove()能够奏效的前提是，其执行线程与ThreadLocal.get()/set(T)的执行线程必须是同一个线程。

       无法通过在线程中执行ThreadLocal.remove()来规避另外一个线程因使用ThreadLocal而导致的伪内存泄露。

       ```java
       public class ThreadLocalTest {
           // 1. 初始化线程局部变量
           final static ThreadLocal<SimpleDateFormat> SDF = new ThreadLocal<SimpleDateFormat>(){
               @Override
               protected SimpleDateFormat initialValue() {
                   return new SimpleDateFormat("yyyy-MM-dd");
               }
           };
       
           // 2. 线程局部变量get()方法,获取线程特有对象SimpleDateFormat
           public void test(){
               before();
               System.out.println(SDF.get().format(new Date()));
               // 清除线程局部变量和线程特有对象的关联,以便垃圾回收
               SDF.remove();
           }
       
           // 在执行每个任务之前,重置线程特有对象
           private void before(){
               SDF.set(new SimpleDateFormat());
           }
       }
       ```

####4.3 线程特有对象的典型应用场景

- 需要使用非线程安全对象，但又不希望因此而引入锁。
- 使用线程安全对象，但希望避免其使用的锁的开销和相关问题。
  1. 线程安全的对象虽然可以被多个线程共享．但是由于其可能使用了锁来保证线程安全，会导致锁的开销。
- 隐式参数传递(Implicit Parameter Passing)
  1. 一个类的方法中设置的线程特有对象对于该方法调用的任何其他方法(包括其他类的方法)都是可见的。
  2. 一个类的方法调用另一个类的方法时，前者向后者传递数据可以借助Thread Local 而不必通过方法参数传递。
- 特定于线程的单例(Singleton)模式
  1. 普通单例模式是，在一个Java虚拟机中的一个类加载器下某个类有且仅有一个实例。
  2. 特殊的单例，对于某个类每个线程有且仅有该类的一个实例，那么就可以使用线程特有对象。

###5 .装饰器模式

- 实现线程安全的思路

  **为非线程安全对象创建一个相应的线程安全的外包装对象(Wrapper), 客户端代码不直接访问非线程安全对象而是访问其外包装对象。**

- 同步集合(java.util.Collections. synchronizedX)

  | 方法                         | 作用                   |
  | ---------------------------- | ---------------------- |
  | Collections.synchronizedList | 返回一个线程安全的List |
  | Collections.synchronizedMap  | 返回一个线程安全的Map  |
  | Collections.synchronizedSet  | 返回一个线程安全的Set  |

  同步集合对象：Collection类中以上三个方法的作用是，指定一个非线程安全的集合对象，该方法的返回值是指定集合对象的外包装对象。

  1. 优点

     关注点分离(Separation of Concern)。在非线程安全版的类里我们可以只关注功能本身，而不必关注线程安全问题。线程安全版的类仅需要关注线程安全问题。可以比较灵活的根据环境来选择，两个不同的类。

  2. 缺点

     同步集合的iterator 方法返回的Iterator 实例并不是线程安全的。同时选用的内部锁，必须和相应的同步集合内部用于保障其自身线程安全所使用的锁保持一致。

     同步集合中通常使用一个粗粒度的锁，使用这些同步集合虽然可以确保线程安全，但是也可能导致锁的高争用，从而导致较大的上下文切换的开销。

###6 .并发集合

- 背景

  `java.util.concurrent`包中引入了一些线程安全的集合对象，被称为并发集合。

  | 非线程安全对象 | 井发集合类            | 共同接口   | 遍历实现方式 |
  | -------------- | --------------------- | ---------- | ------------ |
  | ArrayList      | CopyOnWriteArrayList  | List       | 快照         |
  | HashSet        | CopyOnWriteArraySet   | Set        | 快照         |
  | LinkedList     | ConcurrentLinkedQueue | Queue      | 准实时       |
  | HashMap        | ConcurrentHashMap     | Map        | 准实时       |
  | TreeMap        | ConcurrentSkipListMap | Sortec!Map | 准实时       |
  | TreeSet        | ConcurrentSkipListSet | SortedSet  | 准实时       |

- 作用

  1. 并发集合对象自身就支持对其进行线程安全的遍历操作。

  2. 对并发集合的遍历操作和对其进行的更新操作可以由不同的线程并发执行的，有利于充分提高系统的并发性。

####6.1线程安全的遍历方式

- 快照

  1. 实现原理

     快照(Snapshot)是在Iterator实例被创建的那一刻，待遍历对象内部结构的一个只读副本(对象)，反映了待遍历集合的某一时刻(即Iterator实例被创建的那一刻)的状态(不包括集合元素的状态)。

     **快照相当于这些线程的线程特有对象**。

  2. 并发集合
     CopyOnWriteArrayList 和CopyOnWriteArraySet使用快照的遍历方式。

  3. 优点
     遍历操作和更新操作之间互不影响(因为各自操作的是不同的对象)。

  4. 缺点
     当被遍历的集合比较大时．创建快照的直接或者间接开销会比较大。
  
- 准实时

  1. 实现原理

     准实时是指**遍历操作不是针对待遍历对象的副本进行的，但又不借助锁来保障线程安全，从而使得遍历操作可以与更新操作并发进行**。

     遍历过程中其他线程对被遍历对象的内部结构的更新(比如删除了一个元素)可能会(也可能不会)被反映出来。

     并发集合内部在保障其线程安全的时候通常不借助锁，而是**使用CAS 操作**。或者对锁的使用进行了优化，比如使用粒度极小的锁。

  2. 并发集合

     ConcurrentLinkedQueue、ConcurrentHashMap、 ConcurrentSkipListMap和ConcurrentSkipListSet使用准实时.

  3. 优点

     并发集合的可伸缩性(Scalability)一般要比相应的同步集合高，即使用并发集合的程序相比于使用相应同步集合的程序而言，并发线程数的增加所带来的程序的吞吐率的提升要更加显著。

#### 6.2具体的并发集合

- **ConcurrentLinkedQueue**

  1. 内部实现

     ConcurrentLinkedQueue内部访问其共享状态变量(如队首指针和队尾指针)的时候并不借助锁，而是使用CAS 操作来保障线程安全的。

  2. 适用场景

     ConcurrentLinkedQueue更适合于更新操作和遍历操作并发的场景。比如一个（或者多个）线程往／从队列中添加／删除元素，而另外一个（或者多个）线程则对相应队列进行遍历操作。

     BlockingQueue的实现类（如ArrayBlockingQueue )更适合于多个线程并发更新同一队列的场景。比如在生产者
     一消费者模式中生产者线程往队列中添加元素（产品），而消费者线程从队列中移除（消费）元素。

- **ConcurrentHashMap**

  1. 内部实现

     ConcurrentHashMap内部**使用了粒度极小的锁来保障其线程安全**。

     默认情况下**ConcurrentHashMap可以支持16个并发更新线程**，即这些线程可以在不导致锁(ConcurrentHashMap内部使用的锁）的争用情况下进行并发更新。

- **CopyOnWriteArrayList** 

  1. 内部实现

     CopyOnWriteArrayList的更新操作(添加、修改和删除)是通过创建一个新的数组newArray, 并把老的数组( array当前所引用的数组)的内容复制到newArray, 然后对newArray进行更新并将array引用指向newArray。

     array所引用的数组相当于当前CopyOnWriteArrayList实例的一个快照（线程特有对象）。

  2. 适用场景

     CopyOnWriteArrayList适用于遍历操作远比更新操作（增加、删除和修改）频繁或者不希望在遍历的时候加锁的场景。

- **CopyOnWriteArraySet**

  1. 内部实现

     CopyOnWrite ySet内部实现使用了一个CopyOnWriteArrayList实例，因此CopyOnWriteArraySet的适用场景与CopyOnWriteArrayList相似。