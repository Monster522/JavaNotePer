## Java同步机制

###1.线程同步机制简介

- 基本定义

  线程同步机制是一套用于**协调线程间的数据访问(Data access)及活动(Activity)** 的机制， 该机制用于保障线程安全以及实现这些线程的共同目标。

- 分类

  1. 协调线程间共享数据访问。如锁、volatile关键字、final关键字及其他。
  2. 协调线程间活动。

###2.锁概述

- 锁保障线程安全的思路

  将**多个线程对共享数据的并发访问转换为串行访问**，即**一个共享数据一次只能被一个线程访问**，该线程访问结束后其他线程才能对其进行访问。

- 锁的使用

  锁可以理解为对共享数据进行保护的许可证。

  1. 锁的获得

     一个线程在访间共享数据前必须申请相应的锁（许可证）。

  2. 锁的持有

     一个线程只有在持有许可证的情况下才能够对这些共享数据进行访问，并且一个许可证一次只能够被一个线程持有。

  3. 锁的释放

     锁的持有线程可以对该锁所保护的共享数据进行访问，访问结束后该线程必须释放(`Release`)相应的锁。

  4. 临界区

     锁的持有线程在其获得锁之后和释放锁之前这段时间内所执行的代码被称为临界区。

     共享数据只允许在临界区内进行访问，临界区一次只能被一个线程执行。

  5. 锁所引导的临界区

     如果有多个线程访问同—个锁所保护的共享数据，则称这些线程同步在这个锁上。这些线程所执行的临界区就被称为这个锁所引导的临界区。

- 锁的实现方式-Java

  1. **内部锁(Intrinsic Lock)**

     内部锁是通过synchronized关键字实现的。

  2. **显式锁(Explicit Lock)**

     显式锁是通过java.concurrent.locks.Lock接口的实现类（如java.concurrent.locks.ReentrantLock类）实现的。

  3. **排他锁(互斥锁)**

     锁具有排他性(Exclusive), 即一个锁一次只能被一个线程持有。内部锁和显式锁都属于排他锁。

     排他锁的一种相对改进的锁称为读写锁。

- 互斥锁的流程

  ![](https://javanote.oss-cn-shenzhen.aliyuncs.com/4_互斥锁示意图.png)

####2.1锁的作用

锁能够保护共享数据以实现线程安全，其作用包括**保障原子性、保障可见性和保障有序性**。

- 锁保障性的前提(原子性、可见性、有序性)
  1. 线程在访问同一组共享数据的时候必须使用同一个锁。
  2. 线程中的任意一个线程，即使是读取这组共享数据而没有对其进行更新的话，也需要在读取时持有相应的锁。

- **保障原子性**

  1. 互斥的定义

     互斥(Mutual Exclusion), 就是指一个锁一次只能被一个线程持有。

  2. **通过互斥实现原子性**

     一个线程执行临界区期间没有其他线程能够访间相应的共享数据，这使得临界区代码所执行的操作自然而然地具有不可分割的特性，即具备了原子性。

  3. 实现原理

     从互斥的角度来看，锁是将多个线程对共享数据的访问由本来的并发(未使用锁的清况下)改为串行(使用锁之后)。

     **虽然实现并发是多线程编程的目标，但是这种并发往往是并发中带有串行的局部并发**。

- **保障可见性**

  1. 可见性保障原理

     通过写线程冲刷处理器缓存和读线程刷新处理器缓存这两个动作实现的。

  2. 锁的获取和释放

     **锁的获得隐含着刷新处理器缓存这个动作**，可以从处理器缓存同步最新的数据。

     **锁的释放隐含着冲刷处理器缓存这个动作**，将写线程所做的更新推送到处理器缓存。

     此时可以保障线程能读取到共享数据的相对新值。

  3. 互斥性和可见性

     锁的互斥性及其对可见性的保障合在一起，可保证临界区内的代码能够读取到共享数据的最新值。

     由于锁的互斥性，同一个锁所保护的共享数据一次只能够被一个线程访问，线程在临界区中所读取到共享数据的相对新值(锁对保障可见性的结果)，同时也是最新值。

     对引用型共享变量，锁还可保障临界区中的代码能够读取到，该变量所引用对象的字段(实例变量和静态变量)的最新值。

- **保障有序性**

  1. 原子性和可见性

     锁对原子性和可见性的保障，决定了读线程对这些操作的感知顺序与源代码顺序一致，即保障了有序性。

  2. 实质

     虽然锁能够保障有序性，但这并不意味着临界区内的内存操作不能够被重排序。只是在其他线程看来是有序的。

####2.2与锁相关的几个概念

- **可重入性**

  1. 基本定义

     如果一个线程持有一个锁的时候还能够继续成功申请该锁，那么该锁是可重入的(`Reentrant`) 。

  2. 实例

     ```java
     /**
     * 可重入性
     * 1. 在方法A中已经获取lock锁实例
     * 2. 方法A调用方法B,在A还没释放锁时又再次获取该锁实例
     **/
     void metheadA () {
         // 申请锁lock
         acquireLock(lock); 
         // 省略其他代码
         methodB();
         // 释放锁lock
         releaseLock(lock); 
     }
     
     void metheadB () {
         // 申请锁lock
         acquireLock(lock); 
         // 省略其他代码
         // 释放锁lock
         releaseLock(lock);
     }
     
     ```

- **锁的争用和调度**

  1. Java平台中锁的调度策略也包括公平策略和非公平策略，相应的锁就被称为公平锁和非公平锁。
  2. 内部锁属于非公平锁，而显式锁则既支持公平锁又支持非公平锁。

- **锁的粒度**

  1. 一个锁实例所保护的共享数据的数最大小就被称为该锁的粒度(`Granularity`)
  2. 一个锁实例保护的共享数据的数量大，我们就称该锁的粒度粗，否则就称该锁的粒度细。
  3. 锁的粒度比较细可以提高线程的效率，不过也会增加锁的开销。

####2.3锁的开销及其可能导致的问题

- 开销分类

  锁的开销包括锁的申请和释放所产生的开销，以及锁可能导致的上下文切换的开销。这些开销主要是处理器时间

- **线程活性故障**

  1. 锁泄露

     锁泄漏是指一个线程获得某个锁之后，由于程序的错误、缺陷致使该锁一直无法被释放而导致其他线程一直无法获得该锁的现象。

  2. 锁的不正确使用还可能导致死锁、锁死等线程活性故障。

###3.内部锁：synchronized关键字

#### 3.1基本定义

- 内部锁定义

  **Java平台中的任何一个对象都有唯一的与之关联的锁**。这种锁被称为监视器(Monitor)或者内部锁(IntrinsicLock)。

- 内部锁的实现

  1. 内部锁是通过synchronized关键字实现的。

  2. synchronized关键字可以用来修饰方法以及代码块（花括号"{}"包裹的代码）

- 同步方法

  synchronized关键字修饰的方法就被称为同步方法(SynchronizedMethod) 。

  1. synchronized修饰的静态方法就被称为同步静态方法。
  2. synchronized修饰的实例方法就被称为同步实例方法。

- 同步块

  synchronized关键字修饰的代码块被称为同步块(SynchronizedBlock)。

#### 3.2同步方法

```java
public class SynchronizedTest {
    private int first = 5;
    private static int second = 5;

    /**
    * 同步实例方法
    * 1.同步实例方法相当于以"this" 为引导锁的同步
    **/
    public synchronized int judge() {
        if(first > 3 ) {
            return 0;
        }
        return 1;
    }
    
    // 相当于：以this为锁句柄
    public  int judge() {
        synchronized (this) {
            if(first > 3 ) {
                return 0;
            }
            return 1;
        }
    }

    
    
    /** 
    * 同步静态方法
    * 1. 同步静态方法相当于以当前类对象(Java中的类本身也是一个对象)为引导锁的同步块。
    **/ 
    public static synchronized int judgeStatic() {
        if(second > 3 ) {
            return 0;
        }
        return 1;
    }
    
    // 相当于：以类对象为锁句柄
    public static int judgeStatic() {
        synchronized (SynchronizedTest.class) {
            if(second > 3 ) {
                return 0;
            }
            return 1;
        }
    }
}
```

#### 3.3同步块

```java
/**
* 1. synchronized关键字所引导的代码块就是临界区。锁句柄是一个对象的引用(或者能够返回对象的表达式)。
* 2. 锁句柄可以填写为this关键字(表示当前对象),也可以直接称锁句柄为锁。
* 3. 锁句柄对应的监视器就被称为相应同步块的引导锁。
* 4. 相应的同步块为该锁引导的同步块。
**/
public class SynchronizedTest {
    private int first = 5;
    
    // 作为锁句柄的变量通常采用private final修饰
    private final String handle = "句柄对象";

    // 同步块
    public int balance() {
        // synchronized(锁句柄）
        synchronized(handle) {
            if(first > 3 ) {
                return 0;
            }
            return 1;
        }
    }
}
```

- 句柄变量
  1. 锁句柄变量的值一旦改变，会导致执行同一个同步块的多个线程实际上使用不同的锁，从而导致竞态。
  2. **作为锁句柄的变量通常采用final修饰。通常会使用private修饰作为锁句柄的变最，以防变量被修改**。

#### 3.4内部锁原理

- 内部锁的由来

  线程对内部锁的申请与释放的动作由Java虚拟机负责代为实施，这也是synchronized实现的锁被称为内部锁的原因。

- 内部锁的使用并**不会导致锁泄漏**

  这是因为Java 编译器(javac) 在将同步块代码编译为字节码的时候，对临界区中可能抛出的而程序代码中又未捕获的异常进行了特殊(代为)处理，这使得临界区的代码即使抛出异常也不会妨碍内部锁的释放。

- 内部锁仅支持非公平调度

  1. Java虚拟机会为每个内部锁分配一个入口集(Entry Set), 用于记录等待获得相应内部锁的线程。
  2. 入口集中的线程就被称为相应内部锁的等待线程。
  3. Java虚拟机对内部锁的调度仅支持非公平调度。

###4.显式锁：Lock接口

#### 4.1基本定义

- 显式锁的API

  显式锁(`ExplicitLock`) 是`java.util.concurrent.lcoks.Lock`接口的实例。类`java.util.concurrent.lcoks.ReentrantLock`是`Lock`接口的默认实现类。

  | 方法                                      | 作用                                                       |
  | ----------------------------------------- | ---------------------------------------------------------- |
  | void lock();                              | 获取锁                                                     |
  | void lockInterruptibly()                  | 如果当前线程未被中断，则获取锁。                           |
  | Condition newCondition();                 | 返回绑定到此Lock实例的新Condition实俐．                    |
  | boolean tryLock();                        | 仅在调用时锁为空闲状态才获取该锁．                         |
  | boolean tryLock(long time, TimeUnit unit) | 如杲锁在给定的等待时间内空闲且当前线程未被中断，则获取锁． |
  | void unlock();                            | 释放锁                                                     |

- **显式锁的使用**

  1. 创建Lock接口的实例。

     创建Lock接口的默认实现类ReentrantLock的实例作为显式锁使用，ReentrantLock是一个可重入锁。

  2. 在访问共享数据前申请相应的显式锁。

     直接调用相应Lock.lock()方法。

  3. 在临界区中访问共享数据。

     Lock.lock()调用与Lock. unlock()调用之间的代码区域为临界区。一般try代码块为临界区。

  4. 共享数据访问结束后释放锁。

     释放锁的操作通过调用Lock.unlock()即可实现，为了避免锁泄露，必须在finally块中释放锁。

  ```java
  public class ExplicitLockTest {
      // 共享数据
      private int first = 5;
      // 显式锁对象
      private final Lock lock = new ReentrantLock();
      
      public int water() {
          // 申请锁
          lock.lock();
          try {
              // 对共享数据的访问
              if(first > 5) {
                  return 1;
              }
          } finally {
              // 在finally块中释放锁，以避免锁泄湍
              lock.unlock();
              return 0;
          }
      }
  }
  ```

####4.2显式锁的调度

- 显式锁默认使用的是非公平调度策略

  公平锁保障锁调度的公平性往往是以增加了线程的暂停和唤醒的可能性，即增加了上下文切换为代价的。

  公平锁适合于锁被持有的时间相对长或者线程申请锁的平均间隔时间相对长的情形。

  ```java
  // 默认无参构造方法，非公平调度
  public ReentrantLock();
  // 参数fair决定调度策略，true为公平，false为非公平
  public ReentrantLock(boolean fair);
  ```

####4.3显式锁与内部锁的比较

- 灵活性

  1. 内部锁是基于代码块的锁，因此其使用基本无灵活性可言。内部锁的申请与释放只能是在一个方法内进行。
  2. 显式锁是基于对象的锁，显式锁支持在一个方法内申请锁，却在另外一个方法里释放锁。

- 锁泄露

  1. 内部锁简单易用，且不会导致锁泄漏。
  2. 显式锁容易被错用而导致锁泄漏，必须将锁的释放操作放在finally 块中。

- 锁的调度

  1. 内部锁仅支持非公平锁。
  2. 而显式锁既支持非公平锁，又支持公平锁。

- 线程阻塞

  1. 如果一个内部锁的持有线程一直不释放这个锁(这通常是由于代码错误导致的)，那么同步在该锁之上的所有线程就会一直被暂停而使其任务无法进展。

  2. Lock 接口定义了一个tryLock 方法。该方法的作用是尝试申请相应Lock 实例锁表示的锁。如果无法获取锁不会导致线程阻塞，可以继续执行其他方法。

     ```java
     // 不会因为获取不到锁导致线程一直阻塞住
     Lock lock = ... ;
     if (lock. tryLock ()) {
         try {
             // 在此访问共享数据
         } finally {
             lock.unlock();
         }
     } else{
     	// 执行其他操作
     }
     ```

- 锁信息监控

  显式锁提供了一些接口（指方法）可以用来对锁的相关信息进行监控，而内部锁不支持这种特性。

  1. RentrantLock中定义的方法isLocked()可用于检测相应锁是否被某个线程持有。
  2. getQueueLength()方法可用于检查相应锁的等待线程的数量。

- **锁的性能**

  Java 1.6/1. 7对内部锁做了一些优化，这些优化在特定情况下可以减少锁的开销。

  到了Java 1.6, 随着JDK对内部锁所做的一些改进，显式锁和内部锁之间的可伸缩性差异已经变得非常小了。

####4.4内部锁还是显式锁：锁的选用

- **—默认情况下选用内部锁**，仅在需要显式锁所提供的特性的时候才选用显式锁。

####4.5改进型锁：读写锁

- 基本定义

  1. 读写锁(Read/Write Lock)是一种改进型的排他锁，也被称为共享／排他(Shared/Exclusive)锁。
  2. 读写锁允许多个线程可以同时读取(只读)共享变量，但是一次只允许一个线程对共享变量进行更新(包括读取后再更新)。

- 特点

  1. 任何线程读取共享变量的时候，其他线程无法更新这些变量。
  2. 一个线程更新共享变量的时候，其他任何线程都无法访问该变量。

- 实现原理

  1. 读锁(Read Lock)

     读线程在访问共享变量的时候必须持有相应读写锁的读锁，读锁可以被多个线程持有。

  2. 写锁(Write Lock)

     写线程在访问共享变批的时候必须持有相应读写锁的写锁，写锁只能被一个线程持有。

  |      | 获得条件                               | 排他性                             | 作用                                                         |
  | ---- | -------------------------------------- | ---------------------------------- | ------------------------------------------------------------ |
  | 读锁 | 相应的写锁未被任何线程持有             | 对读线程是共享的，对写线程是排他的 | 允许多个读线程可以同时读取共享变量，并保障读线程读取共享变量期间没有其他任何线程能够更新这些共享变量。 |
  | 写锁 | 该写锁且相应读锁，未被其他任何线程持有 | 对写线程和读线程都是排他的         | 使得写线程能够以独占的方式访问共享变量。                     |

- 读写锁应用实例

  `java.util.concurrent.locks.ReadWriteLock`接口是对读写锁的抽象。

  其默认实现类是`java.util.concurrent.locks.ReentrantReadWriteLock`。

  ```java
  /**
  * 读写锁的使用同时满足的条件
  * 1. 只读操作比写(更新)操作要频繁得多
  * 2. 读线程持有锁的时间比较长。
  **/
  public class ReadWriteLockTest {
      private final ReadWriteLock rwLock = new ReentrantReadWriteLock();
      // 读锁
      private final Lock readLock = rwLock.readLock();
      // 写锁
      private final Lock writeLock = rwLock.writeLock();
  
      public void read() {
          // 申请读锁
          readLock.lock();
          try{
              // 读取共享变量
          } finally {
              // 在finally块中释放锁，防止锁泄露
              readLock.unlock();
          }
      }
  
      public void write() {
          // 申请写锁
          writeLock.lock();
          try{
              // 在此区域访问（读、写）共享变量
          } finally {
              // 在finally块中释放锁，防止锁泄露
              writeLock.unlock();
          }
      }
  }
  ```

- 锁的降级

  1. ReentrantReadWriteLock支持**锁的降级**。一个线程持有读写锁的写锁的情况下可以继续获得相应的读锁。
  2. ReentrantReadWriteLock不支持锁的升级。读线程如果要申请写锁，需要先释放读锁，然后申请相应的写锁。

###5.锁的适用场景

- check-then-act操作：一个线程读取共享数据并在此基础上决定其下一个操作是什么。
- read-modify-write操作：一个线程读取共享数据并在此基础上更新该数据。
- 多个线程对多个共享数据进行更新：如果共享数据之间存在关联关系，那么为了保障操作的原子性而使用锁。

###6.线程同步机制的底层助手：内存屏障

- 基本定义

  1. 内存屏障是对一类仅针对内存读、写操作指令(`Instruction`)的跨处理器架构(x86、ARM)的比较底层的抽象。

  2. 内存屏障是被插入到两个指令之间进行使用的，其**作用是禁止编译器、处理器重排序从而保障有序性**。

- **可见性的内存屏障**

  1. 加载屏障(Load Barrier)：作用是刷新处理器缓存，同步最新的数据。
  2. 存储屏障(Store Barrier)：作用是冲刷处理器缓存，推送最新的数据。
  3. 可见性的保障是通过写线程和读线程成对地使用存储屏障和加载屏障实现的。

- **有序性的内存屏障**

  1. 获取屏障(AcquireBarrier)

     使用方式是在一个读操作(包括Read-Modify-Write以及普通的读操作)之后插入该内存屏障。

     **作用是禁止该读操作与其后的任何读写操作之间进行重排序**，这相当于在进行后续操作之前先要获得相应共享数据的所有权(这也是该屏障的名称来源）

  2. 释放屏障(Release Barrier ) 

     使用方式是在一个写操作之前插入该内存屏障。

     **作用是禁止该写操作与其前面的任何读写操作之间进行重排序**。

  3. 锁对有序性的保障是通过写线程和读线程配对使用释放屏障与获取屏障实现的。

###7.锁与重排序 的七个规则

- 临界区内的操作不允许被重排序到临界区之外(即临界区前或者临界区后)。

  保障原子性和可见性。

- 临界区内的操作之间允许被重排序。

  保障运行的性能。

- 临界区外(临界区前或者临界区后)的操作之间可以被重排序。

  保障运行的性能。

- 临界区外(临界区前、临界区后)的操作可以被重排到临界区之内。

  JIT动态编译(从字节码到机器码的编译)过后的目标代码中的临界区之外的指令，由于编译器插入的内存屏障的作用无法被重排到临界区之内

多个锁的场景规则，确保了Java语义支持嵌套锁，避免锁操作(申请、释放)可能导致的死锁。

- 锁申请(MonitorEnter)与锁释放(MonitorExit)操作不能被重排序。
- 两个锁申请操作不能被重排序。
- 两个锁释放操作不能被重排序。

###8.轻量级同步机制：volatile关键字 

volatile关键字**用于修饰共享可变变量**，即**没有使用final关键字修饰的实例变量或静态变量**，被称为volatile变量。

####8.1volatile的作用 

- 基本作用

  1. **保障可见性**、**保障有序性**和**保障long/double型变量读写操作的原子性**。

     在Java语言中，对long型和double型以外的任何类型的变量的写操作都是原子操作。Java语言规范特别地规定对long/double型volatile变最的写操作和读操作也具有原子性。

  2. volatile关键字在原子性方面仅保障对被修饰的变量的读操作、写操作本身的原子性。

     如果要保障对volatile变量的赋值操作的原子性，那么这个赋值操作不能涉及任何共享变量(包括被赋值的volatile变量本身)的访问。

     ```java
     // 赋值操作：将一个非volatile变量的值赋值给volatile变量
     // 因为count2为非volatile变量，赋值过程中可能会发生变化，所以不能保证赋值操作的原子性。
     countl = count2 + 1;
     
     // 写操作：将一个明确的值(基本变量),赋值给volatile变量
     // 由于基本变量本身的读写就是原子性的，所以可以保证写操作的原子性。
     count1 = 2;      
     ```

- volatile和锁的联系

  1. 写线程对volatile变量的写操作会产生类似于释放锁的效果。
  2. 读线程对volatile变量的读操作会产生类似于获得锁的效果。

- **有序性的保障**

  1. 实现原理

     对于volatile变量的写操作，Java虚拟机会在该操作之前插入一个释放屏障，并在该操作之后插入一个存储屏障。

     释放屏障禁止了volatile写操作与该操作之前的任何读、写操作进行重排序。存储屏障保证了写操作后，冲刷处理器缓存。

  2. 目的

     保障读线程对写线程，在更新volatile变量前，**对共享变量所执行的更新操作的感知顺序**，与源代码顺序一致。

- **可见性的保障**

  1. 实现原理

     对于volatile变量读操作，Java虚拟机会在该操作之前插入一个加载屏障, 并在该操作之后插入一个获取屏障。

     加载屏障保证刷新处理器缓存得到相对新值，获取屏障保证读操作不与之后的读写操作进行重排序。

  2. 目的

     保障了写线程对volatile变量的写操作，以及在此之前所执行的其他内存操作的结果，都对读线程可见。

- volatile对引用类型或者数组

  1. 如果被修饰的变量是个数组，那么volatile关键字只能够对数组引用本身的操作(读取数组引用和更新数组引用)起作用，而无法对数组元素的操作(读取、更新数组元素)起作用。
  2. 对于引用型volatile变最，volatile关键字只是保证读线程能够读取到一个指向对象的相对新的内存地址(引用)，而这个内存地址指向的对象的实例／静态变量值是否是相对新的则没有保障。

####8.2volatile变量的开销 

- volatile的开销比锁要小。volatile变量的读、写操作都不会导致上下文切换。

- volatile变量读写操作的成本介于普通变量的写操作和在临界区内进行的写操作之间。

####8.3volatile的典型应用场景与实战案例 

- **使用volatile变量作为状态标志**。应用程序的某个状态由一个线程设置，其他线程会读取该状态并以该状态作为其计算的依据。

- **使用volatile保障可见性**。多个线程共享一个可变状态变量，其中一个线程更新了该变量之后．其他线程在无需加锁的情况下也能够看到该更新。

- **使用volatile实现简易版读写锁**。简易版读写锁仅涉及一个共享变量，并且允许一个线程读取这个共享变量时其他线程可以更新该变量。

  ```java
  // 简易版读写锁
  public class Counter {
      private volatile long count;
      
      // 读取方法不加锁
      public long vaule() {
          return count;
      }
      
      // 更新方法加锁
      public void increment () {
          synchronized (this) {
              count++;
          }
      }
  }
  ```

###9.CAS与原子变量 
####9.1CAS(Compare and Swap) 

- 基本定义

  CAS是对硬件层面的处理器指令的称呼。在Java程序看来，CAS就是一个不可分割的指令，是一个原子操作。

- 作用

  1. CAS能够 read-modify-write操作和check-then-act操作转换为原子操作。
  2. CAS本身是一个if-then-act操作。
  3. CAS**只是保障了共享变量更新这个操作的原子性，并不保障可见性。**即在多线程中，其他线程可能读取到更新前的共享变量值，且只能读取到更新前或更新后两个值。

  ```java
  /**
  * 用伪代码来表示CAS从硬件层面实现的程序逻辑
  * 1. CAS并不是用代码实现了这个操作,是CAS指令起到的作用相当于伪代码起到的作用。
  * 2. 并且CAS是一个原子操作。
  **/
  boolean cornpareAndSwap(Variable V,Object A, Object B) {
      // check: 检查变量值是否被其他线程修改过
      if(A== V.get()) {
          // act: 更新变量值
          V. set (B);
          // 更新成功
          return true;
      }
      // 变量值已被其他线程修改，更新失败
      return false;
  }
  ```

####9.2原子操作工具：原子变量类 

| 分组       | 类名                                                         |
| ---------- | ------------------------------------------------------------ |
| 基础数据型 | Atomiclnteger、 AtomicLong、 AtomicBoolean                   |
| 数组型     | AtomiclntegerArray、AtomicLongArray、AtomicReferenceArray    |
| 字段更新器 | AtomiclntegerFieldUpdater、AtomicLongFieldUpdater、AtomicReferenceFieldUpdater |
| 引用型     | AtomicReference、AtomicStampedReference、AtomicMarkableReference |

- 基本定义

  1. **原子变量类是基于CAS实现的，能够保障对共享变量，进行read-modify-write更新操作的原子性和可见性**。
  2. 所谓的read-modify-write更新操作，是指对共享变量的更新不是一个简单的赋值操作．而是变量的新值依赖于变量的旧值，例如自增操作"count++"。

- ABA问题

  1. CAS实现原子操作的前提是，共享变量的当前值与当前线程所提供的旧值相同，就认为这个变量没有被其他线程修改过。

  2. 问题描述

     对于共享变量V, 当前线程看到它的值为A的那一刻，其他线程已经将其值更新为B, 接着在当前线程执行CAS的时
     候该变量的值又被其他线程更新为A。此时是否认为V没有被更改过，称为ABA问题。

  3. 问题解决

     为共享变量的更新引入一个修订号(也称时间戳)。每次更新共享变量时相应的修订号的值就会被增加1。

     AtomicStampedReference类可以实现这个功能。

###10.对象的发布与逸出 

- 对象发布(`Publish`)

  1. 线程安全问题产生的前提条件是**多个线程共享变量**。
  2. 对象发布就是，使对象能够在当前作用域之外的代码中使用。 比如return一个对象，或者作为参数传递到其他类的方法中。 

- 对象逸出(`Escape`)

  1. 对象逸出是，**发布了某个不该被发布的对象**。发布内部状态将会破坏封装性，并使得程序难以维持不变性条件。

     第一种情况：当一个对象还没有构造结束就发布了对象(将对象提供给外部代码) ，会破坏线程安全性。

     第二种情况：变量为私有，却在public方法中返回该变量。就是私有对象逸出。

  2. 对象逸出属于对象发布的一种形式，对象发布会造成多个线程。

  3. **一个对象在其初始化过程中没有出现this逸出，称为正确创建对象**。

- 对象发布的方式

  ```java
  /**
  * 1.对象引用作为非私有属性
  * 问题：registry对象引用可以直接被其他类访问,Set中的元素也可以被随意访问.
  *      在多线程的环境中,多个线程访问共享变量registry会造成线程不安全.
  *      这种方式没有逸出,是不安全的对象发布.
  **/
  public Map<String, Integer> registry = new HashMap<String, Integer>();
  
  /**
  * 2.私有对象引用被非私有方法返回
  * 问题：registry对象引用是一个私有变量，是不能被其他类的访问的.
  *      通过方法getRegistry可以获取到私有变量的引用,就是发布了不该发布的对象.
  *      这是私有对象逸出,同时也是不安全的对象发布.
  **/
  public class test {
      private Map<String, Integer> registry = new HashMap<String, Integer>();
      
      public Map<String, Integer> getRegistry(){
          return registry;
      }
  }
  
  /**
  * 3.外部方法发布对象
  * 外部方法定义：对当前类来说，外部方法是指行为不完全由当前类来规定的方法，包括其他类中定义的方法以及当前类中
  *             可以被改写的方法（既不是私有方法，也不是final方法）
  * 问题：对于类test来说,setNose是Dog类的方法,是外部方法.
  *      对象Nose被就被外部方法发布出去,就是其他线程可以通过,传入参数dog这个引用,来访问到nose对象。
  *      这种方式没有逸出,是不安全的对象发布.体现为,nose对象可能被别的线程修改.
  **/
  public class test {
     
      public void setDog(Dog dog){
          dog.setNose(new Nose(){})
      }
  }
  
  public class Dog {
      private Nose nose;
      
      public setNose(Nose nose) {
          this.nose = nose;
      }
  }
  
  /**
  * 4.this逸出,当一个对象还没有构造结束就发布了对象(将对象提供给外部代码) ，会破坏线程安全性。
  * 问题：在ThisEscape类的构造器中,新建匿名类EventListener.此时匿名类带有ThisEscape类的this指针。
  *       如果在构造器还没运行结束的时候,其他线程通过引用source,可以访问到this指针。
  *       此时的this指针就是一个构建不完全的ThisEscape类。
  *       这就是this逸出,会造成严重的线程安全问题。
  **/
  public class ThisEscape {
      public ThisEscape(EventSource source){
          source.registerListener(
              new EventListener(){
                  public void onEvent(Event e){
                      doSomething(e)
                  }
              });
      }
  }
  ```

####10.1对象的初始化安全：重访final与static 

- static关键字

  1. 静态变量的加载模式

     一个类被Java虚拟机加载之后，该类的所有静态变量的值都仍然是其默认值（引用型变量的默认值为null. boolean变量的默认值为false)。

     直到有个线程初次访问了该类的任意一个静态变量，才使这个类被初始化一类的静态初始化块("static{} ")被执行．类的所有静态变股被赋予初始值。

  2. 多线程环境

     static在多线程下，能够**保证一个线程即使在未使用其他同步机制的情况下，也总是可以读取到一个类的静态变量的初始值(而不是默认值)**。

     对于引用型静态变量，static关键字还能够**保障一个线程读取到该变量的初始值时，这个值所指向(引用)的对象巳经初始化完毕**。

     static关键字仅仅保障读线程能够读取到相应字段的初始值，而不是相对新值。

  3. 保障初始化安全的原理
     static保证了在所有线程访问静态变量前，将静态块初始化。

- final关键字

  1. 多线程环境下

     **当一个对象被发布到其他线程的时候，该对象的所有final字段(实例变量)都是初始化完毕的**。其他线程读取这些字段的时候所读取到的值都是相应字段的初始值。

     对于引用型final字段，final关键字还进一步确保该字段所引用的对象已经初始化完毕。这些线程读取该字段所引用的对象的各个字段时所读取到的值都是相应字段的初始值。

     final 关键字并不保障对象引用本身对外的可见性。

  2. 保障初始化安全的原理

     final保证了指令的有序性，使所有的赋值操作在发布对象操作之前完成。

  3. 线程安全

     对于基本变量，final变量是不可更改的，所以**在多线程访问共享的final变量情况下，也是线程安全的**。

     final变量进一步保证了初始化安全，所以final变量在多线程环境下是线程安全的。
     
     对于引用变量，final保证指针值是不可修改的，但是不能保证指针指向的对象不可更改。不能保证线程安全。

####10.2安全发布

- 基本定义

  安全发布指的是线程安全发布对象。

- 以下方式可以组合或单独使用

  1. 在静态初始化函数中初始化一个对象的引用。-- 保证初始化安全
  2. 将对象的引用保持到volatile类型的域或者AtomicReference对象中。 -- 保证可见性或原子性
  3. 将对象的引用保存到某个正确构造对象的final类型域中。 -- 保证线程安全
  4. 将对象的引用保存到一个由锁保护的域中。- 保证线程安全