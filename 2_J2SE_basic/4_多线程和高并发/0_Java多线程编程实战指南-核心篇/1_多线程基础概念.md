## 多线程基础概念

### 1.进程、线程与任务

- **进程的定义**
  1. 进程(`Process`) 是程序的运行实例。
  2. 一个运行的Java程序就是一个Java虚拟机进程。
  3. 进程是程序向操作系统申请资源(如内存空间和文件句柄)的基本单位。
- **线程的定义**
  1. 线程(`Thread`)是进程中可独立执行的最小单位。
- **任务的定义**
  1. 线程所要完成的计算就被称为任务，特定的线程总是在执行着特定的任务。
- **进程和线程的联系**
  1. 一个进程可以包含多个线程。同一个进程中的所有线程共享该进程中的资源，如内存空间、文件句柄等。

### 2.多线程编程简介

- **定义**
  1. 函数式编程(`Functional Programming`)中的函数是基本抽象单位。
  2. 面向对象编程中的类(`Class`) 是基本抽象单位。
  3. 多线程编程就是以线程为基本抽象单位的一种编程范式(`Paradigm`)。
- **面向对象和多线程**
  1. 可以在面向对象编程的基础上实现多线程编程，在Java平台中，一个线程就是一个对象。
  2. 多线程编程并非使用多个线程进行编程那么简单，需要考虑线程之间的协调性。
- **多线程的应用条件**
  1. 目标任务是可以被分割成多个小任务的。
  2. 任务量比较大需要多个线程提高处理效率。
  3. 多线程是有成本的，提高效率的收益要大于使用多线程的成本。

### 3.Java线程API简介

- 基本的JAR包
  1. Java标准库类`java.lang.Thread`就是Java平台对线程的实现。Thread类或其子类的一个实例就是一个线程。

#### 3.1线程的创建启动运行

- **创建线程的两种方式**

  1. 定义`Thread`类的子类，在该子类中覆盖(Override)run方法并在该方法中实现线程任务处理逻辑。
  2. 创建一个`java.lang.Runnable`接口的实例，并在该实例的run方法中实现任务处理逻辑，然后以该`Runnable`接口实例作为构造器的参数，直接创建(new)一个`Thread`类的实例。

- **启动线程的方式**

  1. Thread类的start方法的作用是启动相应的线程。
  2. 启动一个线程的实质是，请求Java虚拟机运行相应的线程，而这个线程具体何时能够运行是由线程调度器( Scheduler)决定的。

- **运行线程**

  1. 运行一个线程实际上就是让Java虚拟机执行该线程的run方法，从而使相应线程的任务处理逻辑代码得以执行。
  2. run方法相当于线程的任务处理逻辑的入口方法，它由Java虚拟机在运行相应线程时直接调用，而不是由应用代码进行调用。
  3. 一旦线程的run方法执行(由Java虚拟机调用)结束，相应的线程的运行也就结束了。
  4. 运行结束的线程所占用的资源(如内存空间)会如同其他Java对象一样被Java虚拟机垃圾回收
  5. **不能通过重新调用一个已经运行结束的线程的start方法来使其重新运行**。

  ```java
  /**
  * 线程的创建启动运行
  **/
  public class CreateTread {
      public static void main(String[] args){
          // 创建方式1：继承Thread类
          Thread thread = new FirstThread();
          thread.start();
  
          // 创建方式2：实现Runnable接口
          Thread runnale = new Thread(new SecondRunnable());
          runnale.start();
          
          // main线程
          System.out.println(String.format("1.TreadName is %s.",Thread.currentThread().getName()));
      }
  }
  
  // 1.继承Thread类
  class FirstThread extends Thread {
      @Override
      public void run() {
          System.out.println(String.format("2.TreadName is %s.",Thread.currentThread().getName()));
      }
  }
  
  // 2.实现Runnable接口
  class SecondRunnable implements Runnable {
      @Override
      public void run() {
          System.out.println(String.format("3.TreadName is %s.",Thread.currentThread().getName()));
      }
  }
  
  
  // 程序输出
  3.TreadName is Thread-1.
  1.TreadName is main.
  2.TreadName is Thread-0.
  ```

- **线程和Java内存**

  1. 创建一个线程与创建其他类型的Java对象所不同的是，Java虚拟机会为每个线程分配**调用栈**(`Call Stack`) 所需的内存空间。
  2. 调用栈用于跟踪Java代码(方法)间的调用关系以及Java代码对本地代码(Native Code, 通常是C代码）的调用。
  3. Java平台中的每个线程可能还有一个内核线程（具体与Java虚拟机的实现有关）与之对应。
  4. 创建线程对象比创建其他类型的对象的成本要高一些。

- **执行线程和当前线程**

  1. Java平台中的任意一段代码（比如一个方法）总是由确定的线程负责执行的，这个线程就相应地被称为这段代码的执行线程。同一段代码可以被多个线程执行。
  2. 任意一段代码都可以通过调用`Thread.currentThread()`来获取这段代码的执行线程，这个线程就被称为当前线程。
  3. 在某一个时间点，一段代码的执行线程可以有多个，当前线程只有一个。当前线程是可以变化的，但是一定在执行线程的范围中。

- **run方法与线程**

  1. Java可以直接调用Run方法，而不是必须通过虚拟机调用。
  2. 如果没有启动线程而在应用代码中直接调用线程的run方法的话，那么这个线程的run方法其实运行在当前线程。
  3. run方法的运行不是代表着一定有新的线程启动。

  ```java
  public class CreateTread {
      public static void main(String[] args){
          
          // 通过start()方法才会启动一个新线程
          Thread thread = new FirstThread();
          thread.start();
          
          // 直接调用run()方法,并没有启动一个新线程
          thread.run();
          System.out.println(String.format("1.TreadName is %s.",Thread.currentThread().getName()));
      }
  }
  
  
  // 1.继承Thread类
  class FirstThread extends Thread {
      @Override
      public void run() {
          System.out.println(String.format("2.TreadName is %s.",Thread.currentThread().getName()));
      }
  }
  
  // 输出
  2.TreadName is Thread-0.
  2.TreadName is main.
  1.TreadName is main.
  ```

#### 3.2Runnable接口

- Runnable和Thread的联系

  1. Runnable接口可以被看作对任务进行的抽象，任务的处理逻辑就体现在run方法之中。
  2. Thread类实际上是Runnable接口的一个实现类。

  ```java
  /**
  * Thread类的run方法
  * 1. Thread 类所实现的任务处理逻辑是要么什么也不做(target 为null),要么直接执行target所引用的Runnable实
  *    例所实现的任务处理逻辑.
  **/
  public class Thread implements Runnable {
      @Override
      public void run() {
          if (target != null) {
              target.run();
          }
      }
  }
  ```

- 线程两种创建方式的区别

  1. 从面向对象编程的角度
     - 继承Thread类。基于继承，耦合性高。
     - 实现Runnable接口。基于组合，耦合性低。
  2. 从对象共享的角度
     - 继承Thread类。一个线程一个Thread子类实例。该实例数据是线程安全的，不会被别的线程修改。
     - 实现Runnable接口。多个线程共享一个Runnable实例。该实例数据不是线程安全的，会被别的线程修改。
  3. 从对象创建成本的角度
     - 继承Thread类。只需要创建一个线程实例。
     - 实现Runnable接口。需要创建一个线程实例，再创建一个Runnable实例当做参数传给线程实例。

#### 3.3线程属性

| 属性             | 属性类型及用途                                               | 只读属性 | 重要注意事项                                                 |
| :--------------- | :----------------------------------------------------------- | -------- | :----------------------------------------------------------- |
| 编号(ID)         | 类型：long。用于标识不同的线程。不同的线程拥有不同的编号。   | 是       | 某个编号的线程运行结束后，该编号可能被后续创建的线程使用。不同线程拥有的编号虽然不同，但是**这种编号的唯一性只在Java 虚拟机的一次运行有效**。也就是说重启一个Java 虚拟机（如重启Web 服务器）后，某些线程的编号可能与上次Java 虚拟机运行的某个线程的编号一样．因此该属性的值不适合用作某种唯一标识，特别是作为数据库中的唯一标识（如主键） |
| 名称(Name)       | 类型：String。面向人（而非机器）的一个属性，用千区分不同的线程。默认值与线程的编号有关，默认值的格式为："Thread-线程编号”，如"Thread-0" | 否       | Java 并不禁止我们将不同的线程的名称属性设置为相同的值。尽管如此，设置线程的名称屈性有助于代码调试和问题定位。 |
| 线程类别(Daemon) | 类型：boolean。值为true表示相应的线程为**守护线程**，否则表示相应的线程为**用户线程**。该属性的默认值与相应线程的父线程的该属性的值相同 | 否       | 该属性必须在相应线程启动之前设置，即对setDaemon方法的调用必须在，对start方法的调用之前，否则setDaemon方法会抛出IllegalThreadStateException 异常。负责一些关键任务处理的线程不适宜设置为守护线程。 |
| 优先级(Priority) | 类型：int。该属性本质上是给线程调度器的提示信息，**用于表示应用程序希望哪个线程能够优先得以运行**。Java 定义了1-10 的10个优先级。默认值一般为5 (表示普通优先级）。对于具体的一个线程而言．其优先级的默认值与其父线程（创建该线程的线程）的优先级值相等 | 否       | 一般使用默认优先级即可。不恰当地设置该属性值可能导致严重的问题（线程饥饿） |

线程的属性除了编号外， 其他属性都是可读写的属性，即Thread 类提供了相应的get方法和set 方法用于读取或者设置相应的属性。

- 名称(Name)

  1. 为每个线程都设置一个简短而又能够体现其作用或其实现的功能的名称，有助于程序调试和问题定位。

- 线程类别(Daemon)

  1. 用户线程

     用户线程会阻止Java 虚拟机的正常停止，即一个Java虚拟机只有在其所有用户线程都运行结束（即Thread.run()调用未结束）的情况下才能正常停止。

  2. 守护线程

     守护线程不会影响Java虚拟机的正常停止，即应用程序中有守护线程在运行也不影响Java 虚拟机的正常停止。

     **守护线程**通常用于执行一些重要性不是很高的任务，例如**用于监视其他线程的运行情况**。

  3. Linux的Kill命令

     在Linux系统下使用kill命令，强制终止一个Java 虚拟机进程，那么即使是用户线程也无法阻止Java虚拟机的停止。

- 优先级(Priority)

  1. **不能决定线程按照其优先级高低的顺序运行**，只是一个建议信息。
  2. 产生线程饥饿(Thread Starvation)。Java线程的优先级使用不当或者滥用则可能导致某些线程永远无法得到运行。
  3. 一般情况下使用普通优先级即可，即不必设置线程的优先级属性。

#### 3.4Thread类的常用方法

```java
/**
* 作用：返回当前线程．即当前代码的执行线程（对象）
* 备注：同一段代码对Thread.currentThread()的调用． 其返回值可能对应着不同的线程（对象）
**/
public static native Thread currentThread();

/**
* 作用：用于实现线程的任务处理逻辑
* 备注：该方法是由Java虚拟机直接调用的．一般情况下应用程序不应该调用该方法。
**/
public void run() {...}

/** 
* 作用：启动相应线程
* 备注：该方法的返回并不代表相应的线程已经被启动。一个Thread实例的start方法只能够被调用一次，多次调用会导致异常
*       的抛出。
**/
public synchronized void start() {...}

/**
* 作用：等待相应线程运行结束
* 备注：若线程A调用线程B的join方法． 那么线程A的运行会被暂停，直到线程B运行结束。
**/
public final void join() throws InterruptedException {...}

/**
* 作用：使当前线程主动放弃其对处理器的占用， 这可能导致当前线程被暂停
* 备注：这个方法是不可靠的。该方法被调用时当前线程可能仍然继续运行（视系统当前的运行状况而定）
**/
public static native void yield();

/**
* 作用：使当前线程休眠（暂停运行）指定的时间
* 备注：
**/
public static native void sleep(long millis) throws InterruptedException;
```

#### 3.5Thread类的废弃方法

不要在继续使用这些废弃方法，即使没有替代方法。

```java
// 作用：停止线程的运行
public final void stop() {...}

// 作用：暂停线程的运行
public final void suspend() {...}

// 作用：使被暂停的线程继续运行
public final void resume() {...}
```

### 4.无处不在的线程

- 系统创建的多个线程：main线程、垃圾回收线程、Web服务器请求处理线程、JIT编译线程

### 5.线程的层次关系

- **父子线程的定义**
  1. 假设线程A所执行的代码创建了线程B, 习惯上我们称线程B为线程A的子线程，相应地线程A
     就被称为线程B的父线程。
  2. 子线程所执行的代码还可以创建其他线程，因此一个子线程也可以是其他线程的父线程。
- **父子线程与线程属性**
  1. 线程类别。默认情况下父线程是守护线程，则子线程也是守护线程；父线程是用户线程，则子线程也是用户线程。父线程可以在启动子线程之前设置其类别，设为用户线程或守护线程。
  2. 优先级。一个线程的优先级默认值为该线程的父线程的优先级。
  3. 生命周期。**父线程和子线程之间的生命周期也没有必然的联系**。父线程运行结束后，子线程可以继续运行，子线程运行结束也不妨碍其父线程继续运行。

### 6.线程的生命周期状态

·

![](https://javanote.oss-cn-shenzhen.aliyuncs.com/2_线程状态转换.png)

Java线程的状态可以使用监控工具查看，也可以通过`Thread.getState()`调用来获取。`Thread.getState()`的返回值类型Thread.State是一个枚举类型(Enum)。

- **NEW**

  一个已创建而未启动的线程处于该状态。由于一个线程实例只能够被启动一次，因此只可能有一次处于该状态。

- **RUNNABLE**

  该状态可以被看成一个复合状态。它包括两个子状态：READY 和RUNNING。

  1. 前者表示处于该状态的线程，可以被线程调度器(`Scheduler`) 进行调度而使之处于RUNNING 状态。
  2. 后者表示处于该状态的线程正在运行，即相应线程对象的run 方法所对应的指令正在由处理器执行。
  3. 执行Thread.yield()的线程，其状态可能会由RUNNING转换为READY。
  4. 处于READY子状态的线程也被称为**活跃线程**。

- **BLOCKED**

  1. 一个线程发起**一个阻塞式I/O(Blocking I/O)操作**后, 或者**申请一个由其他线程持有的独占资源(比如锁)**时，相应的线程会处于该状态。

  2. 处于`BLOCKED`状态的线程并不会占用处理器资源。

  3. 当阻塞式I/O操作完成后，或者线程获得了其申请的资源，该线程的状态又可以转换为RUNNABLE。

- **WAITING**

  1. 一个线程执行了某些特定方法之后，就会处于这种等待其他线程执行另外一些特定操作的状态。
  2. 能够使其执行线程变更为WAITING状态的方法包括：Object. wait() 、Thread.join()和LockSupport.park(Object)。
  3. 能够使相应线程从WAITING 变更为RUNNABLE的相应方法包括：Object.notify()/notify All()和LockSupport.unpark(Object))。

- **TIMED_ WAITING**

  1. 该状态和WAITING 类似，差别在于，处于该状态的线程并非无限制地等待其他线程执行特定操作，而是处于带有时间限制的等待状态。
  2. 当其他线程没有在指定时间内执行该线程所期望的特定操作时，该线程的状态自动转换为RUNNABLE。
  3. 进入该状态的方法有Tread.sleep(long)、Object.wait(long)、LockSupport.partkNanos/parkUntil调用。

- **TERMINATED**

  1. 已经执行结束的线程处于该状态。
  2. 由于一个线程实例只能够被启动一次，因此一个线程也只可能有一次处于该状态。
  3. Thread.run()正常返回或者由于抛出异常而提前终止都会导致相应线程处于该状态。
  4. 一个线程在其整个生命周期中，只可能有一次处于NEW状态和TERMINATED 状态。

### 7.线程的监视

- 主要途径

  1. 对线程进行监视的主要途径是，**获取并查看程序的线程转储**(`Thread Dump`)。
  2. 一个程序的线程转储，包含了获取这个线程转储的那一刻该程序的线程信息。
  3. JDK自带的工具jvisualvm适合于在开发和测试环境下监视Java 系统中的线程情况。jvisualvm不仅可以用来获取线程转储，它还支持直接选中一个线程来查看该线程的调用栈。

  ![](https://javanote.oss-cn-shenzhen.aliyuncs.com/3_获取线程转储的方法.png)

### 8.多线程编程简单运用实例

### 9.多线程编程的优势和风险

- **优势**

  1. **提高系统的吞吐率(`Throughput`)**。多线程编程使得一个进程中可以有多个并发(Concurrent, 即同时进行的）的操作。例如，当一个线程因为I/O操作而处于等待时，其他线程仍然可以执行其操作。
  2. **提高响应性(`Responsiveness`)**。对于Web应用程序而言，一个请求的处理慢了并不会影响其他请求的处理。
  3. **充分利用多核(Multicore)处理器资源**。实施恰当的多线程编程有助于充分利用设备的多核处理器资源，从而避免了资源浪费。
  4. **最小化对系统资源的使用。**一个进程中的多个线程可以共享其所在进程所申请的资源（如内存空间）,使用多个线程相比于使用多个进程进行编程来说，节约了对系统资源的使用。
  5. **简化程序的结构**。线程可以简化复杂应用程序的结构。

- **风险**

  1. **线程安全(`ThreadSafe`)问题。**多个线程共享数据的时候，如果没有采取相应的并发访问控制措施，可能产生数据
     一致性问题。如读取脏数据（过期的数据）、丢失更新（某些线程所做的更新被其他线程所做的更新覆盖）

  2. **线程活性(`Thread Liveness`)问题**。

     代码编写不当可能导致，某些线程一直处于等待其他线程释放锁的状态(BLOCKED状态）即产生了**死锁**。

     一直忙碌的线程也可能会出现问题，它可能面临**活锁**(Livelock)问题，即**一个线程一直在尝试某个操作但就是无法进展**。

     可能出现**线程饥饿**(`Starvation`)的问题，即某些线程永远无法获取处理器执行的机会而永远处于RUNNABLE状态的READY子状态。

  3. **上下文切换(Context Switch)。**

     处理器从执行一个线程转向执行另外一个线程的时候操作系统所需要做的一个动作被称为上下文切换。

     上下文切换增加了系统的消耗，不利于系统的吞吐率。

  4. **可靠性。**

     多线程有利于可靠性，表现在一个线程意外终止并不影响其他线程的执行。

     单进程多线程不利于可靠性，表现在如果多线程依附的进程意外终止了，那么所有的多线程都会终止。

##多线程调度与安全

###1.串行、并发与并行

- **串行(`Sequential`)**

  单处理器情况下，线程一个接一个执行，不能同时执行。多个串行就可以称为并行，也是侧重于物理上的概念。 

- **并发(`Concurrent`)**

  单处理器情况下，两个或多个线程在同一时间轮流执行 。往往是指程序代码的结构支持并发，是逻辑上的同时发生。

- **并行(`Parallel`)**

  多处理器情况下，多个线程在同一时刻发生，在不同的处理器上同时执行。并行是物理机支持并行，侧重于物理上的同时发生 。

- 联系

  1. 并发就是在一段时间内以交替的方式去完成多个任务。
  2. 并行就是以齐头并进的方式去完成多个任务。
  3. **并发往往是带有部分串行的并发，而并发的极致就是并行(`Parallel`)。**
  4. 多线程编程的实质就是，**将任务的处理方式由串行改为并发，即实现并发化，以发挥并发的优势。**
  5. 如果一个任务的处理方式可以由串行改为并发(或者并行)，那么就称这个任务是可并发化(或者可并行化)的。

###2.竞态(RaceCondition)

#### 2.1竞态的定义

- **状态变量**

  指的是类的实例变量、静态变量。

- **共享变量**

  1. 可以被多个线程共同访问的变量。
  2. 共享变量中的“共享“强调的是“可以被共享"的可能性，因此称呼一个变量为共享变量并不表示该变量一定会被多个线程访问。
  3. 状态变量由于可以被多个线程共享，因此也是共享变量。

- 竞态的定义
  1. 一个计算结果的正确性与时间有关的现象就被称为竞态。
  2. 竞态(`RaceCondition`)是指，计算的正确性依赖于相对时间顺序(`RelativeTiming`)或线程的交错(`Interleaving`)。
  3. 竞态不一定就导致计算结果的不正确，只是不排除计算结果时而正确时而错误的可能。

- 竞态产生的原因
  
- 引发的问题
  
  1. **读取脏数据问题**。读取完成后，数据被其他线程修改，导致读取到一个过时的数据。
  2. **更新丢失问题**。当线程读取到脏数据，并在此基础上进行更新，就会覆盖掉其他线程的更新。

####2.2竞态的模式
- read-modify-write(读—改—写)操作

  1. 读取一个共享变量的值(read)  -- 脏数据问题
  2. 根据该值做一些计算(modify)
  3. 更新该共享变最的值(write) -- 更新丢失问题

- check-then-act(检测而后行动)操作

  1. 读取某个共享变量的值。-- 脏数据问题
  2. 根据该变量的值决定下一步的动作是什么。
  
####2.3竞态产生的一般条件

- **对于共享变量**

  多个线程在没有采取任何控制措施的情况下并发地更新、读取同一个共享变量，会导致竞态。

- **对于局部变量**

  由于不同的线程各自访问的是各自的那一份局部变量，因此局部变量的使用不会导致竞态。

- 实例

  1. 设O1和O2是并发访问共享变量V的两个操作，这两个操作并非都是读操作。
  2. 如果一个线程在执行O1期间（开始执行而未执行结束）另外一个线程正在执行O2。
  3. 那么无论O2是在读取还是更新V都会导致竞态。

#### 2.4竞态的消除

- **synchronized关键字**

  synchronized关键字会使其修饰的方法在任一时刻只能够被一个线程执行，这使得该方法涉及的共享变量在任一时刻只能够有一个线程访问(读、写)，从而避免了这个方法的交错执行而导致的干扰，这样就消除了竞态。

###3.线程安全性

#### 3.1基本定义

- **线程安全性(Thread Safety)**

  1. 一般而言，如果一个类在单线程环境下能够运作正常。并且在多线程环境下，在其使用方不必为其做任何改变的情况下也能运作正常，那么就是线程安全的。
  2. 线程安全的类不会产生竞态问题。

- **非线程安全**

  1. 如果一个类在单线程环境下运作正常而在多线程环境下则无法正常运作，则是非线程安全。
  2. 非线程安全的类会产生竞态问题。

- **线程安全问题**

  在**多线程环境**下直接使用**存在线程安全问题**，一般分为**原子性**、**可见性**和**有序性**三方面。

#### 3.2原子性

- **原子操作定义**

  1. **对于涉及共享变量访问的操作，若该操作从其执行线程以外的任意线程来看是不可分割的**，那么就是原子操作。
  2. 多个原子操作叠加在一起的复合操作，并非是原子操作。

- **不可分割的含义**

  1. 访问(读、写)某个共享变量的操作从其执行线程以外的任何线程来看，该操作要么已经执行结束要么尚未发生，即其他线程不会“看到“该操作执行了部分的中间效果。
  2. 访问同一组共享变量的原子操作是不能够被交错的。

- **原子操作的应用环境**

  1. 原子操作是**针对访问共享变量的操作**而言的。**对于局部变量的操作，可以全部当做原子操作**。
  2. 单线程环境下一个操作无所谓是否具有原子性，可以全部当成原子操作。

- **原子操作的实现**

  1. **使用锁(Lock)**

     锁具有排他性。即它能够保障一个共享变量在任意一个时刻只能够被一个线程访问，从而消除竞态。

  2. **利用CAS (Compare-and-Swap) 指令**

     CAS指令实现原子性的方式与锁实现原子性的方式实质上是相同的，差别在于锁通常是在软件这一层次实现的，而CAS是直接在硬件(处理器和内存)这一层次实现的，可以被看作“硬件锁"。

- **Java虚拟机实现的原子操作**

  1. 对基础类型(long/double 除外，仅包括byte 、boolean 、short 、char 、float 和int)的变量和其引用型变量的写操作都是原子的。
  2. Java语言规范特别地规定，**对于volatile关键字修饰的long/double型变量的写操作具有原子性**。
  3. Java语言中**针对任何变量的读操作都是原子操作**。

#### 3.3可见性

- **基本定义**

  1. 可见性是**一个线程对共享变量的更新的结果，对于读取相应共享变量的线程而言是否可见**。
  2. 如果一个线程对某个共享变量进行更新之后，后续访问该变量的线程可以读取到该更新的结果，那么是可见的。反之则是不可见的。

- **可见性问题的原因**

  1. 如果两个线程分别运行在不同的处理器上，而这两个线程所共享的变量却被分配到寄存器上进行存储。一个处理器不能直接读取另一个处理器的寄存器，这样就产生了可见性问题。
  2. 即便某个共享变量是被分配到主内存中进行存储的，也不能保证该变量的可见性。处理器对主内存的访问并不是直接访问，而是通过其高速缓存(`Cache`)子系统进行的。如果高速缓存没有及时同步主内存的更新数据，依然会产生可见性问题。

- **处理器之间的缓存交互**

  1. **缓存同步**

     一个处理器的高速缓存中的内容不能被另外一个处理器直接读取。但是一个处理器可以通过**缓存一致性协议**(CacheCo herence Protocol)来读取其他处理器的高速缓存中的数据，并将读到的数据更新到该处理器的高速缓存中。称为缓存同步。

  2. **冲刷处理器缓存**

     一个处理器对共享变量所做的更新最终被写入该处理器的高速缓存或者主内存中(而不是始终停留在其写缓冲器中)，称为冲刷处理器缓存。

  3. **刷新处理器缓存**

     一个处理器在读取共享变量的时候，如果其他处理器在此之前已经更新了该变量，那么该处理器必须从其他处理器的高速缓存或者主内存中对相应的变量进行缓存同步，称为刷新处理器缓存。

- **保障可见性的实现**

  1. **内部原理**

     通过使更新共享变量的处理器执行冲刷处理器缓存的动作，并使读取共享变量的处理器执行刷新处理器缓存的动作来实现。

  2. **Java中保障可见性的实现**

     **使用volatile关键字**。读取一个volatile关键字修饰的变量，会使相应的处理器执行刷新处理器缓存的动作。写一个volatile关键字修饰的变量，会使相应的处理器执行冲刷处理器缓存的动作，从而保障了可见性。

- **保障可见性的意义**

  1. **相对新值**

     对于同一个共享变量而言，一个线程更新了该变量的值之后，其他线程能够读取到这个更新后的值，那么这个值就被称为该变量的相对新值。

  2. **最新值**

     如果读取这个共享变量的线程，**在读取并使用该变量的时候其他线程无法更新该变量的值**，那么该线程读取到
     的相对新值就被称为该变量的最新值。

  3. **意义**

     可见性的保障仅仅意味着，**一个线程能够读取到共享变量的相对新值**， 而不能保障该线程能够读取到相应变量的最新值。

- **可见性和原子性的联系和区别**

  1. 原子性描述的是一个线程对共享变量的更新。**原子性可以保证一个线程所读取到的共享变量的值，要么是该变量的初始值要么是该变量的相对新值。**
  2. 可见性描述的是，一个线程对共享变量的更新对于另外一个线程而言是否可见(或者说什么情况下可见)的问题。**保障可见性意味着，一个线程可以读取到相应共享变量的相对新值**。
  3. 如果仅仅保证原子性，其他线程可能会读取到共享变量的初始值(没有进行刷新处理器缓存)。再加上保证可见性，就可以正确读取到原子操作后的结果。

- **可见性与多线程**

  1. 父线程在启动子线程之前对共享变量的更新，对于子线程来说是可见的。
  2. 一个线程终止后该线程对共享变量的更新，对于调用该线程的join方法的线程而言是可见的。

#### 3.4有序性

#####3.4.1有序性基本定义

- 有序性(`Ordering`)
  1. **在一个处理器上运行的一个线程所执行的内存访问操作，在另外一个处理器上运行的其他线程看起来的顺序**。
  2. 如果这个顺序和代码的顺序比较起来发生了变化，则称为是乱序的(`Out of order`)
  3. 乱序，是指内存访问操作的顺序看起来像是发生了变化。

##### 3.4.2重排序基本定义

- **顺序结构**

  1. 顺序结构是结构化编程中的一种基本结构，表示某个操作必须先于另外一个操作得以执行。
  2. 两个操作即便是可以用任意一种顺序执行，但是反映在代码上这两个操作也总是有先后关系。

- **重排序的现象**

  1. 编译器可能改变两个操作的先后顺序。
  2. 处理器可能不是，完全依照程序的目标代码所指定的顺序执行指令。
  3. 一个处理器上执行的多个操作，从其他处理器的角度来看其顺序可能与目标代码所指定的顺序不一致。

- **重排序的影响**

  1. 对内存访问有关的操作(读和写)所做的一种优化，可以在不影响单线程程序正确性的情况下提升程序的性能。
  2. 可能对多线程程序的正确性产生影响．即可能导致线程安全问题。 

- **重排序的特征**

  1. 重排序也不是必然出现的。
  2. 重排序可能导致线程安全问题。

- **重排序的类型**

  1. 源代码顺序(`SourceCode`) : 源代码中所指定的内存访问操作顺序。
  2. 程序顺序(`ProgramOrder`) : 在给定处理器上运行的目标代码(Object Code) 所指定的内存访问操作顺序。
  3. 执行顺序(`ExecutionOrder`) : 内存访问操作在给定处理器上的实际执行顺序。
  4. 感知顺序(`PerceivedOrder`) : 给定处理器所感知到(看到)的该处理器及其他处理器的内存访问操作发生的顺序。

  | 重排序类型       | 重排序表现                                                   | 重排序来源（主体） |
  | ---------------- | ------------------------------------------------------------ | ------------------ |
  | 指令重排序       | 程序顺序与源代码顺序不一致                                   | 编译器             |
  | 指令重排序       | 执行顺序与程序顺序不一致                                     | JIT编译器、处理器  |
  | 存储子系统重排序 | 源代码顺序、程序顺序和执行顺序这三者保持一致，但是感知顺序与执行顺序不一致 | 高速缓存、写缓冲器 |

#####3.4.3指令重排序

- 基本定义

  **指令重排序是一种动作，确确实实地对指令的顺序做了调整，其重排序的对象是指令。**

- 编译器

  1. 在其他编译型语言（如C++) 中，编译器是可能导致指令重排序的
  2. 在Java 平台中，静态编译器(javac)基本上不会执行指令重排序，而JIT编译器则可能执行指令重排序。

- 处理器

  处理器也可能执行指令重排序，这使得执行顺序与程序顺序不一致。**处理器按照顺序读取→乱序执行→顺序提交进行指令的处理**，并不会对单线程的正确性产生影响，可能导致多线程程序出现非预期的结果。

  1. 顺序读取。指令是一条一条按照程序顺序被处理器读取的。
  2. 乱序执行。现代处理器为了提高指令执行效率，往往不是按照程序顺序逐一执行指令的，而是动态调整指令的顺序，做到哪条指令就绪就先执行哪条指令。
  3. 顺序提交。指令执行的结果会被先存入重排序缓冲器，重排序缓冲器会将各个指令的执行结果按照相应指令被处理器读取的顺序提交到寄存器或者内存中去。

#####3.4.4存储子系统重排序

- 基本定义

  1. **存储子系统重排序是一种现象而不是一种动作，并没有真正对指令执行顺序进行调整，其重排序的对象是内存操作。**

  2. 在处理器严格依照程序顺序执行两个内存访问操作的情况下，在存储子系统的作用下其他处理器对这两个操作的感知顺序仍然可能与程序顺序不一致，即这两个操作的执行顺序看起来像是发生了变化。
  3. 实质是，**处理器和高速缓存的内存操作(读写)**与**处理器的执行结果的先后顺序**不一致。

- 内存重排的实质

  1. 读内存操作(Load)。处理器从高速缓存中读取数据。
  2. 写内存操作(Store)。处理器将执行结果写入高速缓存中。

  | 内存重排序类型(分为4种) | 含义                                                     |
  | ----------------------- | -------------------------------------------------------- |
  | LoadLoad重排序          | 先后执行两个读内存操作LI和L2，实际L2排在L1前执行。       |
  | StoreStore重排序        | 先后执行两个写内存操作WI和W2，实际W2排在W1前执行。       |
  | LoadStore重排序         | 先后执行读内存操作LI和写内存操作W2,实际W2排在L1前执行。  |
  | StoreLoad重排序         | 先后执行写内存操作W1和读内存操作L2，实际L2排在W1前执行。 |

##### 3.4.5有序性的保障

- **单处理器的有序性**
  
  1. 编译期重排序，即静态编译器(对于Java平台指javac)造成的重排序会对运行在单处理器上的多个线程产生影响。
2. 运行期重排序，包括存储子系统造成的重排序、JIT编译器造成的重排序以及处理器的乱序执行所导致的重排序，并不会对单处理器上运行的多线程产生影响，即在这些线程看来处理器像是按照程序顺序执行指令。
  
- **貌似串行语义 - 单线程**

  1. 重排序并非随意地**对指令、内存操作的结果**进行杂乱无章的排序或者顺序调整，而是遵循一定的规则。
  2. 编译器（主要是JIT编译器）、处理器（包括其存储子系统）都会遵守这些规则，从而给单线程程序创造一种假象--- 指令是按照源代码顺序执行的。被称为貌似串行语义。
  3. 貌似串行语义只是从单线程程序的角度保证重排序后的运行结果不影响程序的正确性，并不保证多线程环境下程序的正确性。

- **貌似串行语义的实现**

  **存在数据依赖关系的语句不会被重排序，只有不存在数据依赖关系的语句才会被重排序**。

  1. 数据依赖关系。如果两个操作(指令)访问同一个变量(地址)．且其中一个操作(指令)为写操作。
  2. 控制依赖关系。如果一条语句(指令)的执行结果会决定另外一条语句(指令)能否被执行。

- **多线程有序性的保障**

  通过某些措施使得貌似串行语义扩展到多线程程序，即**重排序要么不发生，要么即使发生了也不会影响多线程程序的正确性**。从逻辑上部分禁止重排序。

  1. 从底层的角度来说，禁止重排序是通过调用处理器提供相应的指令(内存屏障)来实现的。
  2. Java 作为一个跨平台的语言，会替我们与这类指令打交道，而我们只需要使用语言本身提供的机制即可.

##### 3.4.6有序性和可见性

- **可见性是有序性的基础**
1. 可见性描述的是，一个线程对共享变量的更新对于另外一个线程是否可见，或者说什么情况下可见的问题。
  
2. 有序性描述的是，一个处理器上运行的线程对共享变量所做的更新，在其他处理器上运行的其他线程看来，这些线程是以什么样的顺序观察到这些更新的问题。
  
- **有序性影响可见性**
1. 由于重排序的作用，一个线程对共享变量的更新对于另外一个线程而言可能变得不可见。

###4.上下文切换

#### 4.1基本概念

- **单处理器的并发**

  在单处理器(`Uni-processor`)上也能够以多线程的方式实现并发，即一个处理器可以在同一时间段内运行多个线程。

- **时间片的实现**

  单处理器上的多线程，通过时间片分配的方式实现了并发。时间片决定了一个线程可以连续占用处理器运行的时间长度。

- **线程上下文切换的定义**

  1. 一个线程被暂停，即被剥夺处理器的使用权，另外一个线程被选中开始或者继续运行的过程，称为上下文切换。

  2. 当一个进程中的一个线程由于其时间片用完或者其自身的原因（比如需要稍后再继续运行）被迫或者主动暂停其运行时，另外一个线程（可能是同一个进程或者其他进程中的一个线程）可以被操作系统（线程调度器）选中占用处理器开始或者继续其运行。

- 上下文切换相关概念

  1. 切出(SwitchOut)

     一个线程被剥夺处理器的使用权而被暂停运行，称为切出。

  2. 切入(Switch In)

     一个线程被操作系统选中占用处理器开始或者继续其运行，称为切入。

  3. 上下文(Context) 

     **在切出和切入的时候操作系统需要保存和恢复相应线程的进度信息，这个进度信息被称为上下文**。

     一般包括通用寄存器(`GeneralPurposeRegister`)的内容和程序计数器(`ProgramCounter`)的内容。

- **Java中的上下文切换**

  1. 一个线程的生命周期状态在RUNNABLE状态与非RUNNABLE状态（包括BLOCKED、 WAITING和TIMED_WAITING中的任意一个子状态）之间切换的过程就是一个上下文切换的过程。

  2. 线程暂停(切出)

     当一个线程的生命周期状态由RUNNABLE转换为非RUNNABLE时，称这个线程被暂停。

  3. 线程唤醒(切入)

     一个线程的生命周期状态由非RUNNABLE状态进入RUNNABLE状态时，称这个线程被唤醒。

     一个线程被唤醒仅代表该线程获得了一个继续运行的机会，而并不代表其立刻可以占用处理器运行。

     当被唤醒的线程被操作系统选中占用处理器继续其运行的时候，操作系统会恢复之前为该线程保存的上下文。 

#### 4.2上下文切换的分类及其诱因

- 自发性上下文切换(Voluntary Context Switch)

  1. 线程由于其自身因素导致的切出。

  | Java中引发切出的自身因素                                     |
  | ------------------------------------------------------------ |
  | Thread.sleep(long millis)                                    |
  | Object. wait() / wait(long timeout) / wait(long timeout, int nanos) |
  | Thread.yield()                                               |
  | Thread.join() / Thread.join(long timeout)                    |
  | LockSupport .park()                                          |
  | 线程发起了I/O操作（如读取文件）                              |
  | 等待其他线程持有的锁                                         |

- 非自发性上下文切换(Involuntary Context Switch)

  1. 线程由于线程调度器的原因被迫切出。

  | Java引发切出的非自身因素                     |
  | -------------------------------------------- |
  | 被切出线程的时间片用完                       |
  | 有一个比被切出线程优先级更高的线程需要被运行 |
  | Java虚拟机的垃圾回收(Garbage Collect )动作   |

#### 4.3上下文切换的开销和监测

- 直接开销

  1. 操作系统保存和恢复上下文所需的开销，这主要是处理器时间开销。
  2. 线程调度器进行线程调度的开销（比如，按照一定的规则决定哪个线程会占用处理器运行）。

- 间接开销

  1. 处理器高速缓存重新加载的开销。

     一个被切出的线程可能稍后在另外一个处理器上被切入继续运行。如果处理器从未访问过这个线程，需要从主内存或者高速缓存中重新读取加载这个线程相关的变量。

  2. 上下文切换也可能导致整个一级高速缓存中的内容被冲刷(Flush) , 即一级高速缓存中的内容会被写入下一级高速缓存（如二级高速缓存）或者主内存(RAM)中。

- 监测上下文切换的方式

  1. 在Linux平台下，可以使用Linux内核提供的perf命令来监视Java程序运行过程中的上下文切换的次数和频率。
  2. 在Windows 平台下，可以使用Windows 自带的工具perfmon 来监视Java 程序运行过程中的上下文切换情况。

###5.线程的活性故障

- 基本定义

  **由资源稀缺性或者程序自身的问题和缺陷导致线程一直处于非RUNNABLE状态**，或者线程虽然处于RUNNABLE状态但是其要执行的任务却一直无法进展的现象，被称为**线程活性故障**。

- 常见故障

  1. 死锁。

     一个线程X持有资源A的时候等待另外一个线程释放资源B, 而另外一个线程Y在持有资源B的时候却等待线程X释放资源A。

     外在表现是当事线程的生命周期状态永远处于非RUNNABLE状态而使其任务一直无法进展。

  2. 锁死。

     信号丢失锁死是，由于没有相应的通知线程来唤醒等待线程而使等待线程一直处于等待状态的一种活性故障。 

  3. 活锁。

     活锁的外在表现是线程可能处于RUNNABLE状态，但是线程所要执行的任务却丝毫没有进展，即线程可能一直在做无用功。

  4. 饥饿。

     饥饿就是线程因无法获得其所需的资源而使得任务执行无法进展的现象。

###6.资源争用与调度

#### 6.1资源的争用

- 排他性资源(`Exclusive`) 

  一次只能够被一个线程占用的资源被称为排他性资源。常见的排他性资源包括处理器、数据库连接、文件等。

- 资源争用(`ResourceContention`)

  在一个线程占用一个排他性资源进行访问（读、写操作）而未释放其对资源所有权的时候，其他线程试图访问该资源的现象就被称为资源争用。

  1. 高争用。同时试图访间同一个已经被其他线程占用的资源的线程数最越多，争用的程度就越高。
  2. 低争用。同时试图访间同一个已经被其他线程占用的资源的线程数最越少，争用的程度就越低。

- 并发

  1. 高并发。同—时间内，处于运行状态（即生命周期状态为RUNNABLE的RUNNING子状态的线程）的线程数量越多，就称并发的程度越高，简称高并发。
  2. 低并发。相对于高并发。

- 高并发与高争用

  虽然高并发增加了争用的概率，但是高并发未必就意味着高争用。

#### 6.2资源的调度

- 基本定义

  在多个线程申请同一个排他性资源的情况下，决定哪个线程会被授予该资源的独占权，即选择哪个申请者占用该资源的过程就是资源的调度。

- **资源调度策略的公平性**

  1. **公平的**

     如果资源的任何一个先申请者总是能够比任何一个后申请者先获得该资源的独占权，那么相应的资源调度策略就被称为是公平的。

  2. **非公平的**

     如果资源的后申请者可能比先申请者先获得该资源的独占权，那么相应的资源调度策略就被称为是非公平的。

     非公平的资源调度策略往往只是说明它并不保证资源调度的公平性，即它允许不公平的资源调度的出现，而不是表示它刻意造就不公平(Unfair) 的资源调度。

- 公平的调度策略

  1. 应用场景

     **适合在资源的持有线程占用资源的时间相对长或资源的平均申请时间间隔相对长的情况下**，或者对资源申请所需的时间偏差有所要求的情况下使用。

  2. 优点

     线程申请资源所需的时间偏差较小，并且不会导致饥饿现象。

  3. 缺点

     吞吐率较小

- 非公平的调度策略(首选策略)

  1. 应用场景

     多数(或者每个)线程占用资源的时间比较短(或者申请资源的间隔相对长)的情况下适合使用非公平调度策略.

  2. 优点

     吞吐率较大

  3. 缺点

     资源申请者申请资源所需的时间偏差可能较大，并可能导致饥饿现象

