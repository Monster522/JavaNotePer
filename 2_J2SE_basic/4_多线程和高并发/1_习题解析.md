## 习题解析

### 1.Java并发正确的说法：

- CopyOnWriteArrayList 适合使用在 **读操作远远大于写操作** 的场景里，比如 **缓存**。
- ReadWriteLock 当写操作时，其他线程无法读取或写入数据。当读操作时，其它线程无法写入数据，但可以读取数据。适用于 **读取远远大于写入的操作**。
- ConcurrentHashMap 是一个线程安全的HashTable，它的主要功能是提供了一组和HashTable功能相同但是线程安全的方法。
- ConcurrentHashMap 可以做到读取数据不加锁，并且其内部的结构可以让其在进行写操作的时候能够将锁的粒度保持地尽量地小，不用对整个ConcurrentHashMap加锁。
- Volatile：与锁相比，Volatile变量直接访问主内存中的真实值，不会去访问拷贝或者缓存。这是一种非常简单但同时又非常脆弱的同步机制，它在某些情况下将提供优于锁的性能和伸缩性。如果严格遵循 volatile 的使用条件，即变量真正独立于其他变量和自己以前的值，在某些情况下可以使用 volatile 代替 synchronized 来简化代码。然而，使用 volatile 的代码往往比使用锁的代码更加容易出错。使用Volatile变量保证线程安全，满足两个条件：
  1. 对变量的写操作不依赖于当前值。
  2. 该变量没有包含在具有其他变量的不变式中。

### 2.终止线程的方法

- sleep和wait并不会终止线程
- 四种方法：抛出一个异常、stop方法、interrupt方法、线程正常终止。

### 3.四个线程安全的集合类

- Vector：就比arraylist多了个同步化机制（线程安全），因为效率较低，现在已经不太建议使用。在web应用中，特别是前台页面，往往效率（页面响应速度）是优先考虑的。

- Statck：堆栈类，先进后出

- Hashtable：就比hashmap多了个线程安全

- Enumeration：枚举，相当于迭代器