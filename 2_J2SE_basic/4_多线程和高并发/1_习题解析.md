## 习题解析

### 1.Java并发正确的说法：

- CopyOnWriteArrayList 适合使用在 **读操作远远大于写操作** 的场景里，比如 **缓存**。
- ReadWriteLock 当写操作时，其他线程无法读取或写入数据。当读操作时，其它线程无法写入数据，但可以读取数据。适用于 **读取远远大于写入的操作**。
- ConcurrentHashMap 是一个线程安全的HashTable，它的主要功能是提供了一组和HashTable功能相同但是线程安全的方法。
- ConcurrentHashMap 可以做到读取数据不加锁，并且其内部的结构可以让其在进行写操作的时候能够将锁的粒度保持地尽量地小，不用对整个ConcurrentHashMap加锁。
- Volatile：与锁相比，Volatile变量直接访问主内存中的真实值，不会去访问拷贝或者缓存。这是一种非常简单但同时又非常脆弱的同步机制，它在某些情况下将提供优于锁的性能和伸缩性。如果严格遵循 volatile 的使用条件，即变量真正独立于其他变量和自己以前的值，在某些情况下可以使用 volatile 代替 synchronized 来简化代码。然而，使用 volatile 的代码往往比使用锁的代码更加容易出错。使用Volatile变量保证线程安全，满足两个条件：
  1. 对变量的写操作不依赖于当前值。
  2. 该变量没有包含在具有其他变量的不变式中。

### 2.终止线程的方法

- sleep和wait并不会终止线程
- 四种方法：抛出一个异常、stop方法、interrupt方法、线程正常终止。

### 3.四个线程安全的集合类

- Vector：就比arraylist多了个同步化机制（线程安全），因为效率较低，现在已经不太建议使用。在web应用中，特别是前台页面，往往效率（页面响应速度）是优先考虑的。
- Statck：堆栈类，先进后出
- Hashtable：就比hashmap多了个线程安全
- Enumeration：枚举，相当于迭代器

### 4.Java concurrent包中的类

- Semaphore类：控制某个资源可被同时访问的个数。
- ReentrantLock类：具有与使用synchronized方法和语句所访问的隐式监视器锁相同的一些基本行为和语义，但功能更强大。
- CountDownLatch类：可以用来在一个线程中等待多个线程完成任务的类。
- Future：接口，表示异步计算的结果。

### 5.Volatile关键字

- 出于运行速率的考虑，java编译器会把经常经常访问的变量放到缓存（严格讲应该是工作内存）中，读取变量则从缓存中读。但是在多线程编程中,内存中的值和缓存中的值可能会出现不一致。
- volatile用于限定变量只能从内存中读取，保证对所有线程而言，值都是一致的。但是volatile不能保证原子性，也就不能保证线程安全。

### 6.集合类的线程安全

- ConcurrentHashMap使用segment来分段和管理锁，segment继承自ReentrantLock，因此ConcurrentHashMap使用ReentrantLock来保证线程安全。
- Arrays.asList()将一个数组转化为一个List对象，这个方法会返回一个ArrayList类型的对象， 这个ArrayList类并非java.util.ArrayList类，而是Arrays类的静态内部类。用这个对象对列表进行添加删除更新操作，就会报UnsupportedOperationException异常。
- SimpleDateFormat对象是线程不安全的。

### 7.并发锁

- CopyOnWriteArrayList适用于写少读多的并发场景。
- ReadWriteLock即为读写锁，要求写与写之间互斥，读与写之间互斥，读与读之间可以并发执行。在读多写少的情况下可以提高效率。
- ConcurrentHashMap是同步的HashMap，读写都加锁。
- volatile只保证多线程操作的可见性，不保证原子性。

### 8.HashMap和HashTable区别

- Hashtable是同步的，HashMap是快速失败机制保证。
- HashTable不允许null值(key和value都不可以)，HashMap允许null值(key和value都可以)。