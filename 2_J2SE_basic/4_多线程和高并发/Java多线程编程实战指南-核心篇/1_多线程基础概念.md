## 多线程基础概念

### 1.进程、线程与任务

- 进程的定义
  1. 进程(Process) 是程序的运行实例。
  2. 一个运行的Java 程序就是一个Java虚拟机进程。
  3. 进程是程序向操作系统申请资源（如内存空间和文件句柄）的基本单位。
- 线程的定义
  1. 线程(Thread)是进程中可独立执行的最小单位。
- 任务的定义
  1. 线程所要完成的计算就被称为任务，特定的线程总是在执行着特定的任务。
- 进程和线程的联系
  1. 一个进程可以包含多个线程。同一个进程中的所有线程共享该进程中的资源，如内存空间、文件句柄等。

### 2.多线程编程简介

- 定义
  1. 函数式编程(Functional Programming)中的函数是基本抽象单位。
  2. 面向对象编程中的类(Class) 是基本抽象单位。
  3. 多线程编程就是以线程为基本抽象单位的一种编程范式(Paradigm)。
- 面向对象和多线程
  1. 可以在面向对象编程的基础上实现多线程编程，在Java平台中，一个线程就是一个对象。
  2. 多线程编程并非使用多个线程进行编程那么简单，需要考虑线程之间的协调性。
- 多线程的应用条件
  1. 目标任务是可以被分割成多个小任务的。
  2. 任务量比较大需要多个线程提高处理效率。
  3. 多线程是有成本的，提高效率的收益要大于使用多线程的成本。

### 3.Java线程API简介

- 基本的JAR包
  1. Java标准库类java.lang.Thread就是Java平台对线程的实现。Thread类或其子类的一个实例就是一个线程。

#### 3.1线程的创建启动运行

- 创建线程的两种方式

  1. 定义Thread类的子类，在该子类中覆盖(Override)run方法并在该方法中实现线程任务处理逻辑。
  2. 创建一个java.lang.Runnable接口的实例，并在该实例的run方法中实现任务处理逻辑，然后以该Runnable接口实例作为构造器的参数直接创建(new)一个Thread类的实例。

- 启动线程的方式

  1. Thread类的start方法的作用是启动相应的线程。
  2. 启动一个线程的实质是请求Java 虚拟机运行相应的线程，而这个线程具体何时能够运行是由线程调度器( Scheduler)决定的。

- 运行线程

  1. 运行一个线程实际上就是让Java虚拟机执行该线程的run方法，从而使相应线程的任务处理逻辑代码得以执行。
  2. run方法相当于线程的任务处理逻辑的入口方法，它由Java虚拟机在运行相应线程时直接调用，而不是由应用代码进行调用。
  3. 一旦线程的run方法执行（由Java虚拟机调用）结束，相应的线程的运行也就结束了。
  4. 运行结束的线程所占用的资源（如内存空间）会如同其他Java对象一样被Java虚拟机垃圾回收
  5. 不能通过重新调用一个已经运行结束的线程的start方法来使其重新运行。

  ```java
  /**
  * 线程的创建启动运行
  **/
  public class CreateTread {
      public static void main(String[] args){
          // 创建方式1：继承Thread类
          Thread thread = new FirstThread();
          thread.start();
  
          // 创建方式2：实现Runnable接口
          Thread runnale = new Thread(new SecondRunnable());
          runnale.start();
          
          // main线程
          System.out.println(String.format("1.TreadName is %s.",Thread.currentThread().getName()));
      }
  }
  
  // 1.继承Thread类
  class FirstThread extends Thread {
      @Override
      public void run() {
          System.out.println(String.format("2.TreadName is %s.",Thread.currentThread().getName()));
      }
  }
  
  // 2.实现Runnable接口
  class SecondRunnable implements Runnable {
      @Override
      public void run() {
          System.out.println(String.format("3.TreadName is %s.",Thread.currentThread().getName()));
      }
  }
  
  
  // 程序输出
  3.TreadName is Thread-1.
  1.TreadName is main.
  2.TreadName is Thread-0.
  ```

- 线程和Java内存

  1. 创建一个线程与创建其他类型的Java对象所不同的是，Java虚拟机会为每个线程分配**调用栈**(Call Stack) 所需的内存空间。
  2. 调用栈用于跟踪Java代码（方法）间的调用关系以及Java代码对本地代码(Native Code, 通常是C代码）的调用。
  3. Java平台中的每个线程可能还有一个内核线程（具体与Java虚拟机的实现有关）与之对应。
  4. 创建线程对象比创建其他类型的对象的成本要高一些。

- 执行线程和当前线程

  1. Java平台中的任意一段代码（比如一个方法）总是由确定的线程负责执行的，这个线程就相应地被称为这段代码的执行线程。同一段代码可以被多个线程执行。
  2. 任意一段代码都可以通过调用Thread.currentThread()来获取这段代码的执行线程，这个线程就被称为当前线程。
  3. 在某一个时间点，一段代码的执行线程可以有多个，当前线程只有一个。当前线程是可以变化的，但是一定在执行线程的范围中。

- run方法与线程

  1. Java可以直接调用Run方法，而不是必须通过虚拟机调用。
  2. 如果没有启动线程而在应用代码中直接调用线程的run方法的话，那么这个线程的run方法其实运行在当前线程。
  3. run方法的运行不是代表着一定有新的线程启动。

  ```java
  public class CreateTread {
      public static void main(String[] args){
          
          // 通过start()方法才会启动一个新线程
          Thread thread = new FirstThread();
          thread.start();
          
          // 直接调用run()方法,并没有启动一个新线程
          thread.run();
          System.out.println(String.format("1.TreadName is %s.",Thread.currentThread().getName()));
      }
  }
  
  
  // 1.继承Thread类
  class FirstThread extends Thread {
      @Override
      public void run() {
          System.out.println(String.format("2.TreadName is %s.",Thread.currentThread().getName()));
      }
  }
  
  // 输出
  2.TreadName is Thread-0.
  2.TreadName is main.
  1.TreadName is main.
  ```

#### 3.2Runnable接口

- Runnable和Thread的联系

  1. Runnable接口可以被看作对任务进行的抽象，任务的处理逻辑就体现在run方法之中。
  2. Thread类实际上是Runnable接口的一个实现类。

  ```java
  /**
  * Thread类的run方法
  * 1. Thread 类所实现的任务处理逻辑是要么什么也不做(target 为null),要么直接执行target所引用的Runnable实
  *    例所实现的任务处理逻辑.
  **/
  public class Thread implements Runnable {
      @Override
      public void run() {
          if (target != null) {
              target.run();
          }
      }
  }
  ```

- 线程两种创建方式的区别

  1. 从面向对象编程的角度
     - 继承Thread类。基于继承，耦合性高。
     - 实现Runnable接口。基于组合，耦合性低。
  2. 从对象共享的角度
     - 继承Thread类。一个线程一个Thread子类实例。该实例数据是线程安全的，不会被别的线程修改。
     - 实现Runnable接口。多个线程共享一个Runnable实例。该实例数据不是线程安全的，会被别的线程修改。
  3. 从对象创建成本的角度
     - 继承Thread类。只需要创建一个线程实例。
     - 实现Runnable接口。需要创建一个线程实例，再创建一个Runnable实例当做参数传给线程实例。

#### 3.3线程属性

| 属性             | 属性类型及用途                                               | 只读属性 | 重要注意事项                                                 |
| :--------------- | :----------------------------------------------------------- | -------- | :----------------------------------------------------------- |
| 编号(ID)         | 类型：long。用于标识不同的线程。不同的线程拥有不同的编号。   | 是       | 某个编号的线程运行结束后，该编号可能被后续创建的线程使用。不同线程拥有的编号虽然不同，但是这种编号的唯一性只在Java 虚拟机的一次运行有效。也就是说重启一个Java 虚拟机（如重启Web 服务器）后，某些线程的编号可能与上次Java 虚拟机运行的某个线程的编号一样．因此该属性的值不适合用作某种唯一标识，特别是作为数据库中的唯一标识（如主键） |
| 名称(Name)       | 类型：String。面向人（而非机器）的一个属性，用千区分不同的线程。默认值与线程的编号有关，默认值的格式为："Thread-线程编号”，如"Thread-0" | 否       | Java 并不禁止我们将不同的线程的名称属性设置为相同的值。尽管如此，设置线程的名称屈性有助于代码调试和问题定位。 |
| 线程类别(Daemon) | 类型：boolean。值为true 表示相应的线程为守护线程，否则表示相应的线程为用户线程。该属性的默认值与相应线程的父线程的该属性的值相同 | 否       | 该属性必须在相应线程启动之前设置，即对setDaemon 方法的调用必须在对start 方法的调用之前，否则setDaemon 方法会抛出IllegalThreadStateException 异常。负责一些关键任务处理的线程不适宜设置为守护线程。 |
| 优先级(Priority) | 类型：int。该属性本质上是给线程调度器的提示信息，用于表示应用程序希望哪个线程能够优先得以运行。Java 定义了1-10 的10个优先级。默认值一般为5 (表示普通优先级）。对于具体的一个线程而言．其优先级的默认值与其父线程（创建该线程的线程）的优先级值相等 | 否       | 一般使用默认优先级即可。不恰当地设置该属性值可能导致严重的问题（线程饥饿） |

线程的属性除了编号外， 其他属性都是可读写的属性，即Thread 类提供了相应的get方法和set 方法用千读取或者设置相应的属性。

- 名称(Name)

  1. 为每个线程都设置一个简短而又能够体现其作用或其实现的功能的名称，有助于程序调试和问题定位。

- 线程类别(Daemon)

  1. 用户线程

     用户线程会阻止Java 虚拟机的正常停止，即一个Java虚拟机只有在其所有用户线程都运行结束（即Thread.run()调用未结束）的情况下才能正常停止。

  2. 守护线程

     守护线程不会影响Java 虚拟机的正常停止，即应用程序中有守护线程在运行也不影响Java 虚拟机的正常停止。

     守护线程通常用于执行一些重要性不是很高的任务，例如用于监视其他线程的运行情况。

  3. Linux的Kill命令

     在Linux 系统下使用kill 命令强制终止一个Java 虚拟机进程那么即使是用户线程也无法阻止Java 虚拟机的停止。

- 优先级(Priority)

  1. 不能决定线程按照其优先级高低的顺序运行，只是一个建议信息。
  2. 产生线程饥饿(Thread Starvation)。Java线程的优先级使用不当或者滥用则可能导致某些线程永远无法得到运行。
  3. 一般情况下使用普通优先级即可，即不必设置线程的优先级属性。

#### 3.4Thread类的常用方法

```java
/**
* 作用：返回当前线程．即当前代码的执行线程（对象）
* 备注：同一段代码对Thread.currentThread()的调用． 其返回值可能对应着不同的线程（对象）
**/
public static native Thread currentThread();

/**
* 作用：用于实现线程的任务处理逻辑
* 备注：该方法是由Java虚拟机直接调用的．一般情况下应用程序不应该调用该方法。
**/
public void run() {...}

/** 
* 作用：启动相应线程
* 备注：该方法的返回并不代表相应的线程已经被启动。一个Thread实例的start方法只能够被调用一次，多次调用会导致异常
*       的抛出。
**/
public synchronized void start() {...}

/**
* 作用：等待相应线程运行结束
* 备注：若线程A调用线程B的join方法． 那么线程A的运行会被暂停，直到线程B运行结束。
**/
public final void join() throws InterruptedException {...}

/**
* 作用：使当前线程主动放弃其对处理器的占用， 这可能导致当前线程被暂停
* 备注：这个方法是不可靠的。该方法被调用时当前线程可能仍然继续运行（视系统当前的运行状况而定）
**/
public static native void yield();

/**
* 作用：使当前线程休眠（暂停运行）指定的时间
* 备注：
**/
public static native void sleep(long millis) throws InterruptedException;
```

#### 3.5Thread类的废弃方法

不要在继续使用这些废弃方法，即使没有替代方法。

```java
// 作用：停止线程的运行
public final void stop() {...}

// 作用：暂停线程的运行
public final void suspend() {...}

// 作用：使被暂停的线程继续运行
public final void resume() {...}
```

### 4.无处不在的线程

- 系统创建的多个线程：main线程、垃圾回收线程、Web服务器请求处理线程、JIT编译线程

### 5.线程的层次关系

- 父子线程的定义
  1. 假设线程A所执行的代码创建了线程B, 习惯上我们称线程B为线程A的子线程，相应地线程A
     就被称为线程B的父线程。
  2. 子线程所执行的代码还可以创建其他线程，因此一个子线程也可以是其他线程的父线程。
- 父子线程与线程属性
  1. 线程类别。默认情况下父线程是守护线程，则子线程也是守护线程；父线程是用户线程，则子线程也是用户线程。父线程可以在启动子线程之前设置其类别，设为用户线程或守护线程。
  2. 优先级。一个线程的优先级默认值为该线程的父线程的优先级。
  3. 生命周期。父线程和子线程之间的生命周期也没有必然的联系。父线程运行结束后，子线程可以继续运行，子线程运行结束也不妨碍其父线程继续运行。

### 6.线程的生命周期状态

![](https://javanote.oss-cn-shenzhen.aliyuncs.com/1_线程生命周期状态.png)

![](https://javanote.oss-cn-shenzhen.aliyuncs.com/2_线程状态转换.png)

Java线程的状态可以使用监控工具查看，也可以通过Thread.getState()调用来获取。Thread.getState()的返回值类型Thread.State是一个枚举类型(Enum)。

- NEW

  一个已创建而未启动的线程处于该状态。由于一个线程实例只能够被启动一次，因此一个线程只可能有一次处于该状态。

- RUNNABLE

  该状态可以被看成一个复合状态。它包括两个子状态：READY 和RUNNING。

  1. 前者表示处于该状态的线程可以被线程调度器(Scheduler) 进行调度而使之处于RUNNING 状态。
  2. 后者表示处千该状态的线程正在运行，即相应线程对象的run 方法所对应的指令正在由处理器执行。
  3. 执行Thread.yield()的线程，其状态可能会由RUNNING转换为READY。
  4. 处于READY 子状态的线程也被称为活跃线程。

- BLOCKED

  1. 一个线程发起一个阻塞式I/O(Blocking I/O) 操作后, 或者申请一个由其他线程持有的独占资源（比如锁）时，相应的线程会处于该状态。

  2. 处于BLOCKED状态的线程并不会占用处理器资源。

  3. 当阻塞式I/0 操作完成后，或者线程获得了其申请的资源，该线程的状态又可以转换为RUNNABLE。

- WAITING

  1. 一个线程执行了某些特定方法之后就会处于这种等待其他线程执行另外一些特定操作的状态。
  2. 能够使其执行线程变更为WAITING 状态的方法包括：Object. wait() 、Thread.join()和LockSupport.park(Object)。
  3. 能够使相应线程从WAITING 变更为RUNNABLE的相应方法包括：Object.notify()/notify All()和LockSupport.unpark(Object))。

- TIMED_ WAITING

  1. 该状态和WAITING 类似，差别在千处于该状态的线程并非尤限制地等待其他线程执行特定操作，而是处千带有时间限制的等待状态。
  2. 当其他线程没有在指定时间内执行该线程所期望的特定操作时，该线程的状态自动转换为RUNNABLE。
  3. 进入该状态的方法有Tread.sleep(long)、Object.wait(long)、LockSupport.partkNanos/parkUntil调用。

- TERMINATED

  1. 已经执行结束的线程处千该状态。
  2. 由于一个线程实例只能够被启动一次，因此一个线程也只可能有一次处于该状态。
  3. Thread.run()正常返回或者由于抛出异常而提前终止都会导致相应线程处于该状态。
  4. 一个线程在其整个生命周期中，只可能有一次处于NEW 状态和TERMINATED 状态。

### 7.线程的监视

- 主要途径

  1. 对线程进行监视的主要途径是获取并查看程序的线程转储(Thread Dump)。
  2. 一个程序的线程转储包含了获取这个线程转储的那一刻该程序的线程信息。
  3. JDK 自带的工具jvisualvm 适合于在开发和测试环境下监视Java 系统中的线程情况。jvisualvm 不仅可以用来获取线程转储，它还支持直接选中一个线程来查看该线程的调用栈。

  ![](https://javanote.oss-cn-shenzhen.aliyuncs.com/3_获取线程转储的方法.png)

### 8.多线程编程简单运用实例

### 9.多线程编程的优势和风险

- 优势

  1. 提高系统的吞吐率(Throughput)。多线程编程使得一个进程中可以有多个并发(Concurrent, 即同时进行的）的操作。例如，当一个线程因为I/O操作而处于等待时，其他线程仍然可以执行其操作。
  2. 提高响应性(Responsiveness)。对于Web应用程序而言，一个请求的处理慢了并不会影响其他请求的处理。
  3. 充分利用多核(Multicore)处理器资源。实施恰当的多线程编程有助于我们充分利用设备的多核处理器资源，从而避免了资源浪费。
  4. 最小化对系统资源的使用。一个进程中的多个线程可以共享其所在进程所申请的资源（如内存空间）,使用多个线程相比于使用多个进程进行编程来说，节约了对系统资源的使用。
  5. 简化程序的结构。线程可以简化复杂应用程序的结构。

- 风险

  1. 线程安全(ThreadSafe)问题。多个线程共享数据的时候，如果没有采取相应的并发访问控制措施，可能产生数据
     一致性问题。如读取脏数据（过期的数据）、丢失更新（某些线程所做的更新被其他线程所做的更新覆盖）

  2. 线程活性(Thread Liveness)间题。

     代码编写不当可能导致某些线程一直处于等待其他线程释放锁的状态(BLOCKED状态）即产生了死锁。

     一直忙碌的线程也可能会出现问题，它可能面临活锁(Liveloc k)问题，即一个线程一直在尝试某个操作但就是无法进展。

     可能出现线程饥饿(Starvation)的问题，即某些线程永远无法获取处理器执行的机会而永远处于RUNNABLE状态的READY子状态。

  3. 上下文切换(Context Switch)。

     处理器从执行一个线程转向执行另外一个线程的时候操作系统所需要做的一 个动作被称为上下文切换。

     上下文切换增加了系统的消耗，不利于系统的吞吐率。

  4. 可靠性。

     多线程有利于可靠性，表现在一个线程意外终止并不影响其他线程的执行。

     单进程多线程不利于可靠性，表现在如果多线程依附的进程意外终止了，那么所有的多线程都会终止。

##多线程调度与安全

###1.串行、并发与并行
###2.竞态
###3.线程安全性
###4.原子性
###5.可见性
###6.有序性
###7.上下文切换
###8.线程的活性故障
###9.资源争用与调度