## 习题解析

###  1.JVM虚拟机各个分区的作用

- 栈区：主要用来存放局部变量, 传递参数, 存放函数的返回地址。Esp(栈顶指针)
  始终指向栈顶, 栈中的数据越多, Esp(栈顶指针)的值越小。
- 堆区：用于存放动态分配的对象, 当你使用 malloc和new 等进行分配时,所得到的空间就在堆中。动态分配得到的内存区域附带有分配信息, 所以可以free和delete。 
- 数据区：全局，静态和常量是分配在数据区中的，数据区包括bss（未初始化数据区）和初始化数据区。
- 方法区：方法一般存放在代码区中，也称为方法区。
- **注意：** 堆向高内存地址生长，栈向低内存地址生长，堆和栈相向而生，堆和栈之间有个临界点，称为stkbrk。

### 2. JVM类加载器

- Bootstrap ClassLoader：启动类加载器，加载Java的核心库，原生代码实现。

  主要负责 jdk_home/lib 目录下的核心 api 或 -Xbootclasspath 选项指定的jar包装入工作.。

  

- Extension ClassLoader：扩展类加载器 ，加载Java的扩展库。

  主要负责 jdk_home/lib/ext 目录下的jar包或 -Djava.ext.dirs 指定目录下的jar包装入工作。

  

- System ClassLoader：系统类加载器，根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。

  主要负责 java -classpath/-Djava.class.path 所指的目录下的类与jar包装入工作。

  

- User Custom ClassLoader：用户自定义类加载器(java.lang.ClassLoader的子类)

  在程序运行期间, 通过java.lang.ClassLoader的子类动态加载class文件, 体现java动态实时类装入特性。

### 3. Java进程的正确说法

- Java用（监视器）机制实现了进程之间的同步执行。

  jvm中没有进程的概念，但是jvm中的线程映射为操作系统中的进程，对应关系为1：1。

  等价于：jvm中线程如何异步执行？在jvm中 是使用监视器锁来实现不同线程的异步执行，在语法的表现就是synchronized。

### 4.内存使用

- 堆区：只存放类对象，线程共享。
- 方法区：又叫静态存储区，存放class文件和静态数据，线程共享。
- 栈区：存放方法局部变量，基本类型变量区、执行环境上下文、操作指令区，线程不共享。

### 5.虚拟机GC回收

- 两个基本回收算法：复制算法和标记清理算法
  1. 复制算法：两个区域A和B，初始对象在A，继续存活的对象被转移到B。此为新生代最常用的算法。
  2. 标记清理：一块区域，标记可达对象（可达性分析），然后回收不可达对象，会出现碎片。
  3. 标记-整理算法：多了碎片整理，整理出更大的内存放更大的对象。
- 两个概念：新生代和年老代
  1. 新生代：初始对象，生命周期短的。
  2. 永久代：长时间存在的对象。
- 整个Java的垃圾回收是新生代和年老代的协作，这种叫做分代回收。

### 6.虚拟机GC收集器

- Serial New收集器：针对新生代的收集器，采用的是复制算法。
- Parallel New(并行)收集器：新生代采用复制算法，老年代采用标记整理。
- Parallel Scavenge(并行)收集器：针对新生代，采用复制收集算法。
- Serial Old(串行)收集器：新生代采用复制，老年代采用标记整理。
- Parallel Old(并行)收集器：针对老年代，标记整理。
- CMS收集器：基于标记清理。
- G1收集器：整体上是基于标记 整理 ，局部采用复制。
- 新生代基本采用复制算法，老年代采用标记整理算法。cms采用标记清理。

### 7.GC回收原理

- JVM-GC垃圾回收是作用于堆上的，不用于局部变量（栈上）
- java提供了一个系统级的线程，即垃圾回收器线程。用来对每一个分配出去的内存空间进行跟踪。
- 当JVM空闲时，自动回收每块可能被回收的内存，GC是完全自动的，不能被强制执行。程序员最多只能用System.gc()来建议执行垃圾回收器回收内存，但是具体的回收时间，是不可知的。

### 8.JVM堆

- 堆分为新生代(一般是一个Eden区，两个Survivor区)，老年代（old区）。常量池属于 PermGen（方法区）。
- java7，字符串常量池从方法区移到堆中。java8 整个常量池从方法区中移除。方法区使用元空间（MetaSpace）实现。

### 9.方法的调用原理

- Java虚拟机，对于方法的调用采用的是栈帧（方法调用和方法执行），调用则入栈，完成之后则出栈，回收了内存资源，而针对于其他，GC回收的时间不定。

### 10.判断类是否相同

- JVM在判定两个class是否相同时，不仅要判断两个类名是否相同，而且要判断是否由同一个类加载器实例加载的。

### 11.内存泄露问题

- 垃圾收集也会有内存泄露问题，例如访问资源文件，流不关闭，访问数据库等连接不关闭。

### 12.Java中的堆内存

-  Java的堆内存分为两块：permantspace（持久带） 和 heap space。
- 持久带中主要存放用于存放静态类型数据，如 Java Class, Method 等， 与垃圾收集器要收集的Java对象关系不大。
- heapspace分为年轻代和年老代。
  1. 年轻代的垃圾回收叫 Young GC， 年老代的垃圾回收叫 Full GC。
  2. 在年轻代中经历了N次（可配置）垃圾回收后仍然存活的对象，就会被复制到年老代中。
  3. 年老代中存放的都是一些生命周期较长的对象。
- 年老代溢出原因：循环上万次的字符串处理、创建上千万个对象、在一段代码内申请上百M甚至上G的内存。
- 持久代溢出原因：动态加载了大量Java类而导致溢出。