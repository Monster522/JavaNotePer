## 2-3二叉查找树

### 1.基本定义

![](https://javanote.oss-cn-shenzhen.aliyuncs.com/14_23查找树示意图.png)

- 一棵2-3 查找树或为一棵空树，或由以下结点组成：

  1. 2- 结点，含有一个键（及其对应的值）和两条链接，左链接指向的2-3 树中的键都小于
     该结点，右链接指向的2-3 树中的键都大于该结点。
  2. 3- 结点，含有两个键（及其对应的值）和三条链接，左链接指向的2-3 树中的键都小
     于该结点，中链接指向的2-3 树中的键都位于该结点的两个键之间，右链接指向的2-3
     树中的键都大于该结点。
  3. 将指向一棵空树的链接称为空链接。

- 完美平衡的定义

  一棵完美平衡的2-3 查找树中的所有空链接到根结点的距离都应该是相同的。

### 2.查找算法

- 查找的基本步骤 - 和普通的排序二叉树查找类似

  1. 先与根结点比较，如果相同则命中。
  2. 如果比根结点小，在左子树查找。
  3. 如果比根结点大，在右子树查找。
  4. 在子树中按照123步骤继续递归查找，直至找到或者返回空(未命中)。

- 查找示意图

  ![](https://javanote.oss-cn-shenzhen.aliyuncs.com/15_23查找算法示意图.png)

### 3.插入算法

#### 3.1向2- 结点中插入新键

- 在2-结点中插入新键，直接将2-结点更改为3-结点即可。3-结点中两个键的排序是从左到右从小到大。

  ![](https://javanote.oss-cn-shenzhen.aliyuncs.com/16_2-结点插入新键.png)

#### 3.2向一棵只含有一个3- 结点的树中插入新键

![](https://javanote.oss-cn-shenzhen.aliyuncs.com/17_3-结点插入新键.png)

- 将4-结点分解为一棵2-3树
  1. 先临时将新键存入该结点中，使之成为一个4- 结点。(三个键四个链接)
  2. 将它转换为一棵由3 个2- 结点组成的2-3 树
  3. 插入前树的高度为0，插入后树的高度为1

#### 3.3向一个父结点为2- 结点的3- 结点中插入新键

![](https://javanote.oss-cn-shenzhen.aliyuncs.com/18_父结点为2-结点的3-插入情况.png)

- 将父结点修改为3-结点，将原3-结点修改为两个2-结点
  1. 往3-结点插入一个键，将3-结点替换为包含Z的4-结点
  2. 将父结点2-结点替换为含有中键的新3-结点
  3. 将4-结点分解为两个2-结点子结点，将中键移动至父结点中

#### 3.4向一个父结点为3- 结点的3- 结点中插入新键

![](https://javanote.oss-cn-shenzhen.aliyuncs.com/19_父结点为3-结点的3-插入情况.png)

- 一直向上不断分解临时的4- 结点并将中键插入更高层的父结点，直至遇到一个2- 结点并将它替换为一个不需要继续
  分解的3- 结点，或者是到达3- 结点的根。

#### 3.5分解根结点(4-结点)

![](https://javanote.oss-cn-shenzhen.aliyuncs.com/20_分解根结点4-结点.png)

- 将临时的4-结点分解为3 个2- 结点，使得树高加1。

### 4.局部变换(分解4-结点的6种情况)

![](https://javanote.oss-cn-shenzhen.aliyuncs.com/21_分解4-结点的6种情况.png)

- 2-3 树插入算法的根本在于这些变换都是局部的：除了相关的结点和链接之外不必修改或者检查树的其他部分。
- 不光是在树的底部，树中的任何地方只要符合相应的模式，变换都可以进行。

###5.全局性质(树的有序性和平衡性)

- 完美平衡的2-3树拥有全局有序性和平衡性，任意空链接到根结点的路径长度都是相等的。

- 2-3 树的生长是由下向上的。

- 在一棵大小为N 的2-3 树中，查找和插入操作访问的结点必然不超过lgN 个。

  例如，含有10 亿个结点的一棵2-3 树的高度仅在19 到30之间。我们最多只需要访问30个结点就能够在10亿个键中进行任意查找和插入操作

## 红黑二叉查找树

### 1.2-3树到红黑树的转换

![](https://javanote.oss-cn-shenzhen.aliyuncs.com/22_红黑树和23树转换.png)

#### 1.1红黑树和2-3树的替换规则

- 红链接将两个2- 结点连接起来构成一个3- 结点，黑链接则是2-3 树中的普通链接。
- 红黑树中一个结点的颜色，是指向该结点的链接的颜色，反之亦然。约定空链接为黑色。
- 红黑树集中了二叉查找树中简洁高效的查找方法和2-3 树中高效的平衡插入算法。

#### 1.2红黑树的定义

​	满足这样定义的红黑树和相应的2-3 树是一一对应的。

- 红链接均为左链接。
- 没有任何一个结点同时和两条红链接相连。
- 该树是完美黑色平衡的，即任意空链接到根结点的路径上的黑链接数量相同。

### 2.树结构和颜色的调整

#### 2.1树结构调整-旋转

- 旋转的场景：结点出现红色右链接，结点的上下链接都是红色链接且在一条线上

- 特点：旋转操作可以保持红黑树的两个重要性质：有序性和完美平衡性。

- 左旋 - 解决红色右链接

  ![](https://javanote.oss-cn-shenzhen.aliyuncs.com/23_左旋.png)

  

- 右旋 - 解决上下链接都是红色链接

  ![](https://javanote.oss-cn-shenzhen.aliyuncs.com/24_右旋.png)

#### 2.2树颜色调整-颜色转换

- 颜色转换场景：结点的左右链接都是红色链接(相当于分解4-结点为3个2-结点)

- 特点：不会影响整棵树的黑色平衡性。

- 根结点为黑色：当颜色转换后根结点变成红色，直接将根结点设置为黑色，黑链接高度加1.

  ![](https://javanote.oss-cn-shenzhen.aliyuncs.com/25_颜色转换.png)

### 3.插入算法

#### 3.1向单个2- 结点中插入新键

![](https://javanote.oss-cn-shenzhen.aliyuncs.com/26_向单个2-插入.png)

- 分为两种情况
  1. 插入的键比结点小，形成红色左链接，2-结点变成3-结点。
  2. 插入的键比结点大，形成红色右链接。进行左旋转得到一个3-结点。

#### 3.2向树底部的2- 结点插入新键

![](https://javanote.oss-cn-shenzhen.aliyuncs.com/27_向树底部2-插入.png)

- 和3.1的情况一样，分为两种情况处理。
- 插入的键总是用红链接和父结点连在一起。

#### 3.3向一棵双键树（即一个3- 结点）中插入新键

- 分为三种情况

  1. 新键小于树中的两个键，结点上下两个红链接形成一条直线。

     解决：进行右旋，变为第3种情况处理。

  2. 在两者之间，结点上下两个红链接不在一条直线。

     解决：进行左旋，变成第1种情况处理。

  3. 大于树中的两个键，结点两个子红链接。

     解决：进行颜色转换，把两个红链接转换成黑色链接，再把父链接变成红链接。

  ![](https://javanote.oss-cn-shenzhen.aliyuncs.com/28_想3-结点插入键.png)

#### 3.4向树底部的3- 结点插入新键

- 找到插入点，根据3.3的三种情况进行处理，依次将红链接向上传递。

![](https://javanote.oss-cn-shenzhen.aliyuncs.com/29_向树底部的3-结点插入新键.png)

#### 3.5红链接的向上传递

- 重复3.3的处理过程，就可以将红链接向上传递。不再出现矛盾情况或者根结点。

- 如果根结点是红链接，直接将根结点设置为黑色，高度加1。

- 插入的三种情况处理

  ![](https://javanote.oss-cn-shenzhen.aliyuncs.com/30_插入的三种情况示意.png)

### 4.删除算法

-- 暂时省略，这是算法第四版的红黑树，比较简单。算法导论的红黑树比较难，需要去补一下。





