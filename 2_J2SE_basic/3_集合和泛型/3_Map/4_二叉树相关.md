## 二叉树基础概念

### 1.二叉树

![](https://javanote.oss-cn-shenzhen.aliyuncs.com/1_二叉树基础概念.jpg)

- 每个结点最多只有两个子结点的树称为二叉树。
- 有一个或者两个子结点的称为根结点，没有子结点的称为叶子结点，没有父结点的那个结点是起始结点。
- 树的深度(高度)，是从根到叶子结点经过的结点个数的最大值。上图中,左边树的高度为3,右边的为5。

### 2.排序二叉树

- 二叉树中没有重复元素，且元素是有序的，称为排序二叉树。(上图都为排序二叉树)
  1. 如果一个结点的左子树不为空，则左子树上的所有结点都小于该结点。
  2. 如果一个结点的右子树不为空，则右子树上的所有结点都大于该结点

### 3.二叉树和数据结构

- **时间复杂度**
  1. 排序二叉树保持了元素的顺序，是一种综合效率很高的数据结构。基本的保存、删除、查找的效率都为O(h)，h为树的高度。
  2. 在树平衡的情况下，h为log2(N)，N为结点数。比如，如果N为1024，则log2(N)为10。
- **二叉树和哈希表**
  1. 为了能够快速操作数据，哈希和树是两种基本的思维方式。
  2. 不需要顺序，优先考虑哈希。需要顺序，考虑树。
  3. 除了容器类`TreeMap/TreeSet`，数据库中的索引结构也是基于树的(不过基于B树，而不是二叉树)，而索引是能够在大量数据中快速访问数据的关键。

### 4.二叉树的基本性质

- **三个基本性质**

  假设二叉树的总结点树为n，度为0的节点数量为n0，度为1的节点数量为n1，度为2的节点数量为n2,则显然满足n=n0+n1+n2。

  1. 在二叉树的第 i 层至多有`2^(i －1)`个结点`(i>=1)` 。

  2. 深度为 k 的二叉树至多有`2^(k-1)`个结点`(k >=1)`。 

     - 证明：n=2^0+2^1+…+2^(k-1)=(2^k)-1故命题正确。

  3. 对任何一棵二叉树T，如果其叶结点数为`n0`，度为2的结点数为`n2`，则`n0＝n2＋1`。

     ```
     性质3证明
     因为二叉树中所有结点的度数均不大于2，假设二叉树的总结点树为n，度为0的节点数量为n0，度为1的节点数量为n1，
     度为2的节点数量为n2,则结点数之和：n=no+n1+n2 (式子1)
     
     另一方面，1度结点有一个孩子孩，2度结点有两个子，故二叉树中孩子结点总数是：n1+2*n2
     树中只有根结点不是任何结点的孩子，故二叉树中的结点总数又可表示为：n=n1+2*n2+1 (式子2)
         
     由式子1和式子2得到：no=n2+1
     ```

###4.平衡的排序二叉树


#### 4.1出现背景

![](https://javanote.oss-cn-shenzhen.aliyuncs.com/5_二叉树退化为链表.jpg)

- 在极端的情况下，排序二叉树会退化成链表(如上图)
- 退化成链表或者高度不平衡，排序二叉树的查找效率会变的很低。

#### 4.2平衡二叉树概念

- **高度平衡**

  在排序二叉树中，任何结点的左右子树的高度差最多为一 ，则称为高度平衡。也被称为AVL树。

- **大致平衡(红黑树)**

  1. 红黑树是大致平衡的，确保对于任意一条从根到叶子结点的路径，**没有任何一条路径的长度会比其他路径长过两倍**。红黑树减弱了对平衡的要求，但降低了保持平衡需要的开销，在实际应用中，统计性能高于AVL树。
  2. 红黑树名字由来：因为它对每个结点进行着色，颜色或黑或红，并对结点的着色有一些约束，满足这个约束即可以确保树是大致平衡的。
  3. 在TreeMap的实现中，用的并不是AVL树，而是红黑树。与AVL树类似，红黑树也是一种平衡的排序二叉树，也是在插入和删除结点时通过旋转操作来平衡的。

###5.完全二叉树和完全二叉树
![](https://javanote.oss-cn-shenzhen.aliyuncs.com/6_满二叉树和完全二叉树.png)

#### 5.1满二叉树

- **定义**
  1. 国内定义：一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。也就是说，如果一个二叉树的层数为K，且结点总数是(2^k) -1 ，则它就是满二叉树。
  2. 国际定义：满二叉树的结点要么是叶子结点，度为0，要么是度为2的结点，不存在度为1的结点。

#### 5.2完全二叉树

- **定义**
  1. 若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数。
  2. 第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。
- **特点**
  1.  所有叶子节点都出现在 k 或者 k-1 层，而且从 1 到 k-1 层必须达到最大节点数。
  2.  第 k 层可以不是满的，但是第 k 层的所有节点必须集中在最左边。 
  3.  任何一个节点不能只有左子树没有右子树。
  4.  叶子节点出现在最后一层或者倒数第二层，不能再往上 。
- **性质**
  1. 当n为偶数时，n1=1，n为奇数时，n1=0。
  2. 具有n个节点的完全二叉树的深度为`k=log2(n)`(向上取整)。
  3. 对一颗具有n个节点的完全二叉树中的节点从1开始按层序编号，则对于任意的编号为i（1<= i <=n)的节点：
     - 如果`i=1`,则节点 i 是根节点，无双亲。
     - 如果`i>1`,则节点i的双亲节点为 `i/2` (向下取整)
     - 如果`2i<=n`，则 i 的左孩为`2i`，如果`2i>n`，则 i 无左孩
     - 如果`2i+1<=n`,则 i 的右孩为 `2i+1`，否则 i 无右孩



## 排序二叉树的基础算法

### 1.查找

- 基本步骤
  1. 首先与根结点比较，如果相同，则返回根结点。
  2. 如果小于根结点，则到左子树中递归查找。
  3. 如果大于根结点，则到右子树中递归查找。
- 查找最大值最小值
  1. 最小值即为最左边的结点，从根结点一路查找左子结点即可。
  2. 最大值即为最右边的结点，从根结点一路查找右子结点即可。

### 2.按序遍历

![](https://javanote.oss-cn-shenzhen.aliyuncs.com/2_遍历排序二叉树.png)

- 递归方式(对于每个结点都执行这三个动作)

  1. 访问左子结点
  2. 访问当前结点
  3. 访问右子结点
  4. 上图访问顺序为：1-3-4-6-7-8-9

- 非递归方式

  从最左边的结点开始，依次找后继结点。给定一个结点，找其后继结点的算法为： 

  1. 如果有右子结点，则后继结点取整个右子树中最小的结点。

  2. 如果没有右子结点，则后继结点取父结点或某个祖先结点。

     是父结点的左孩子,后继结点取父结点。

     是父结点的右孩子,找它的父结点,判断父结点是不是右孩子,直到其父结点不是右孩子才停止,则此父结点就是后继结点。如果找不到,则后继为空遍历结束。

### 3.插入

- 基本步骤

  在排序二叉树中，插入元素首先要找插入位置，即新结点的父结点。

  1. 与当前结点比较，如果相同，表示已经存在了，不能再插入
  2. 如果小于当前结点，则到左子树中寻找，如果左子树为空，则当前结点即为要找的父结点。
  3. 如果大于当前结点，则到右子树中寻找，如果右子树为空，则当前结点即为要找的父结点。
  4. 找到父结点后，即可插入，如果插入元素小于父结点，则作为左孩子插入，否则作为右孩子插入。

### 4.删除

- 如果为叶子结点，直接删除即可。

- 有一个子结点

  ![]( https://javanote.oss-cn-shenzhen.aliyuncs.com/3_%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9%E6%9C%89%E4%B8%80%E4%B8%AA%E5%AD%90%E8%8A%82%E7%82%B9.jpg )

  1. 将待删结点替换为子结点，在父结点和子结点之间建立连接。
  2. 上图中，删除4，则直接将3和6连接起来。

- 有两个子结点

  ![]( https://javanote.oss-cn-shenzhen.aliyuncs.com/4_%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9%E6%9C%89%E4%B8%A4%E4%B8%AA%E5%AD%90%E8%8A%82%E7%82%B9.jpg )

  1. 找到待删结点的后继结点，后继为右子树中最小结点且没有左子树。
  2. 将待删结点替换为后继结点。
  3. 删除后继结点，此时相当于删除一个子结点的情况。
  4. 上图中，删除3。3有两个孩子，后继结点为4，则将3替换为4，再将4删掉。







