## 二叉树基础概念

### 1.二叉树

![](https://javanote.oss-cn-shenzhen.aliyuncs.com/1_二叉树基础概念.jpg)

- 每个结点最多只有两个子结点的树称为二叉树。
- 有一个或者两个子结点的称为根结点,没有子结点的称为叶子结点,没有父结点的那个结点是起始结点。
- 树的深度(高度),是从根到叶子结点经过的结点个数的最大值。上图中,左边树的高度为3,右边的为5。

### 2.排序二叉树

- 二叉树中没有重复元素,且元素是有序的,称为排序二叉树.（上图都为排序二叉树)
  1. 如果一个结点的左子树不为空，则左子树上的所有结点都小于该结点。
  2. 如果一个结点的右子树不为空，则右子树上的所有结点都大于该结点

### 3.二叉树和数据结构

- 时间复杂度
  1. 排序二叉树保持了元素的顺序，是一种综合效率很高的数据结构。基本的保存、删除、查找的效率都为O(h)，h为树的高度。
  2. 在树平衡的情况下，h为log2(N)，N为结点数。比如，如果N为1024，则log2(N)为10。
- 二叉树和哈希表
  1. 为了能够快速操作数据，哈希和树是两种基本的思维方式。
  2. 不需要顺序，优先考虑哈希，需要顺序，考虑树。
  3. 除了容器类TreeMap/TreeSet，数据库中的索引结构也是基于树的(不过基于B树，而不是二叉树)，而索引是能够在大量数据中快速访问数据的关键。

###4. 二叉树的性质

-  在二叉树的第 i 层至多有 2^(i －1)个结点。(i>=1) 
-  深度为 k 的二叉树至多有 2^(k-1)个结点(k >=1)。 
-  对任何一棵二叉树T, 如果其叶结点数为n0, 度为2的结点数为 n2,则n0＝n2＋1。 
-  具有 n (n>=0) 个结点的完全二叉树的深度为![img](https://img-blog.csdn.net/20160529154127355)＋1   
-  如将一棵有n个结点的完全二叉树自顶向下，同层自左向右连续为结点编号0,1, …, n-1，则有： 
  1. 若i = 0, 则 i 无双亲,   若i > 0, 则 i 的双亲为」(i -1)/2」
  2. 若2*i+1 < n, 则i 的左子女为 2*i+1，若2*i+2 < n, 则 i 的右子女为2*i+2
  3. 若结点编号i为偶数，且i != 0,则左兄弟结点i-1.
  4. 若结点编号i为奇数，且i != n-1,则右兄弟结点为i+1.
  5. 结点i 所在层次为」log2(i+1) 」

## 排序二叉树的基础算法

### 1.查找

- 基本步骤
  1. 首先与根结点比较，如果相同，则返回根结点。
  2. 如果小于根结点，则到左子树中递归查找。
  3. 如果大于根结点，则到右子树中递归查找。
- 查找最大值最小值
  1. 最小值即为最左边的结点，从根结点一路查找左子结点即可。
  2. 最大值即为最右边的结点，从根结点一路查找右子结点即可。

### 2.按序遍历

![](https://javanote.oss-cn-shenzhen.aliyuncs.com/2_遍历排序二叉树.png)

- 递归方式(对于每个结点都执行这三个动作)

  1. 访问左子结点
  2. 访问当前结点
  3. 访问右子结点
  4. 上图访问顺序为：1-3-4-6-7-8-9

- 非递归方式

  从最左边的结点开始，依次找后继结点。给定一个结点，找其后继结点的算法为： 

  1. 如果有右子结点，则后继结点取整个右子树中最小的结点。

  2. 如果没有右子结点，则后继结点取父结点或某个祖先结点。

     是父结点的左孩子,后继结点取父结点。

     是父结点的右孩子,找它的父结点,判断父结点是不是右孩子,直到其父结点不是右孩子才停止,则此父结点就是后继结点。如果找不到,则后继为空遍历结束。

### 3.插入

- 基本步骤

  在排序二叉树中，插入元素首先要找插入位置，即新结点的父结点。

  1. 与当前结点比较，如果相同，表示已经存在了，不能再插入
  2. 如果小于当前结点，则到左子树中寻找，如果左子树为空，则当前结点即为要找的父结点。
  3. 如果大于当前结点，则到右子树中寻找，如果右子树为空，则当前结点即为要找的父结点。
  4. 找到父结点后，即可插入，如果插入元素小于父结点，则作为左孩子插入，否则作为右孩子插入。

### 4.删除

- 如果为叶子结点，直接删除即可。

- 有一个子结点

  ![](https://javanote.oss-cn-shenzhen.aliyuncs.com/3_删除结点有一个子结点.jpg)

  1. 将待删结点替换为子结点，在父结点和子结点之间建立连接。
  2. 上图中，删除4，则直接将3和6连接起来。

- 有两个子结点

  ![](https://javanote.oss-cn-shenzhen.aliyuncs.com/4_删除结点有两个子结点.jpg)

  1. 找到待删结点的后继结点，后继为右子树中最小结点且没有左子树。
  2. 将待删结点替换为后继结点。
  3. 删除后继结点，此时相当于删除一个子结点的情况。
  4. 上图中，删除3。3有两个孩子，后继结点为4，则将3替换为4，再将4删掉。

## 平衡的排序二叉树

### 1.出现背景

![](https://javanote.oss-cn-shenzhen.aliyuncs.com/5_二叉树退化为链表.jpg)

- 在极端的情况下，排序二叉树会退化成链表(如上图)
- 退化成链表或者高度不平衡，排序二叉树的查找效率会变的很低。

### 2.平衡二叉树概念

- 高度平衡

  在排序二叉树中，任何结点的左右子树的高度差最多为一 ，则称为高度平衡。也被称为AVL树。

- 大致平衡(红黑树)

  1. 红黑树是大致平衡的，确保对于任意一条从根到叶子结点的路径，**没有任何一条路径的长度会比其他路径长过两倍**。红黑树减弱了对平衡的要求，但降低了保持平衡需要的开销，在实际应用中，统计性能高于AVL树。
  2. 红黑树名字由来：因为它对每个结点进行着色，颜色或黑或红，并对结点的着色有一些约束，满足这个约束即可以确保树是大致平衡的。
  3. 在TreeMap的实现中，用的并不是AVL树，而是红黑树。与AVL树类似，红黑树也是一种平衡的排序二叉树，也是在插入和删除结点时通过旋转操作来平衡的。

## 满二叉树和完全二叉树

![](https://javanote.oss-cn-shenzhen.aliyuncs.com/6_满二叉树和完全二叉树.png)

### 1.满二叉树

- 定义： 除了叶结点外，每一个结点都有左右子结点，且叶结点都处在最底层的二叉树,。 

### 2.完全二叉树

- 定义：除了最底层，其他层结点必须是满的。最底层节点必须从左边开始排列。
- 特点
  1.  所有叶子节点都出现在 k 或者 k-1 层，而且从 1 到 k-1 层必须达到最大节点数。
  2.  第 k 层可以不是满的，但是第 k 层的所有节点必须集中在最左边。 
  3.  任何一个节点不能只有左子树没有右子树。
  4.  叶子节点出现在最后一层或者倒数第二层，不能再往上 。



