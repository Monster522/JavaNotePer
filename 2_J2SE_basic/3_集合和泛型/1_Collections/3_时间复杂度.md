## 时间复杂度

### 1.ArrayList

| 方法                        | 作用                                | 时间复杂度 |
| --------------------------- | ----------------------------------- | ---------- |
| `get(int index)`            | 根据索引查找元素,数组访问           | O(1)       |
| `contains(Object o)`        | 根据元素内容查询元素,需要遍历       | O(n)       |
| `add(E e)`                  | 添加元素到末尾,数组添加             | O(1)       |
| `add(int index, E element)` | 添加元素到指定位置,需要移动元素     | O(n)       |
| `remove(int index)`         | 删除指定索引位置的元素,需要移动元素 | O(n)       |
| `remove(Object o)`          | 删除指定对象的元素,需要移动元素     | O(n)       |
| `set(int index, E element)` | 修改指定位置的元素值                | O(1)       |



###2.LinkedList

| 方法                                  | 作用                                 | 时间复杂度 |
| ------------------------------------- | ------------------------------------ | ---------- |
| `get(int index)`                      | 根据索引查询元素,二分法查找,需要遍历 | O(n/2)     |
| `contains(Object o)`                  | 根据内容查找元素,需要遍历            | O(n)       |
| `add(E e)/addLast(E e)/addFirst(E e)` | 添加元素到头部或尾部                 | O(1)       |
| `add(int index, E element)`           | 添加元素到指定索引位置,需要遍历      | O(n)       |
| `remove()/removeFirst()/removeLast()` | 从头部或尾部删除元素                 | O(1)       |
| `remove(int index)/remove(Object o)`  | 删除指定索引或内容的元素             | O(n)       |



### 3.HashMap和LinkedHashMap

- 假设使用了大小为M的桶来储存N个对象(`M≤N`)，则在同一个哈希点，平均存储的个数为 `N/M`。
  1. 如果是链表，则查找时间复杂度为 `O(N/M)`
  2. 如果是红黑树，则查找时间复杂度为 `O(log(N/M))`

| 方法 | 时间复杂度              |
| ---- | ----------------------- |
| 查找 | 最好`O(1)` ，最差`O(n)` |
| 删除 | 最好`O(1)` ，最差`O(n)` |
| 添加 | 最好`O(1)` ，最差`O(n)` |



### 4.TreeMap

- 由于底层采用红黑树实现，所以平均复杂度为`O(h)`，h为树的高度。

| 方法 | 时间复杂度 |
| ---- | ---------- |
| 查找 | `O(logn)`  |
| 删除 | `O(logn)`  |
| 添加 | `O(logn)`  |

