## 基础概念

###1.满二叉树

![](https://javanote.oss-cn-shenzhen.aliyuncs.com/1_满二叉树.jpg)

- 除最后一层外，每一层上的所有结点都有两个子结点。
- 在满二叉树的第k层上有2^(k-1)个结点
- 如果满儿茶是深度为m，总共有2^m－1个结点。

### 2.完全二叉树

- 完全二叉树的构建

  ![](https://javanote.oss-cn-shenzhen.aliyuncs.com/2_完全二叉树.jpg)

  1. 除了倒数第1层和倒数第2层外，每一层的结点都达到最大值。
  2. 添加结点，必定从左到右添加，因此在最后一层只会缺少右边的结点。

- 完全二叉树特点

  ![](https://javanote.oss-cn-shenzhen.aliyuncs.com/3_完全二叉树编号.jpg)

  1. 在完全二叉树中，给定任意一个节点，可以根据其编号直接快速计算出其父节点和孩子节点编号。

  2. 如果编号为i，则父节点编号即为i/2，左孩子编号即为2*i,右孩子编号即为2*i+1。

     实例：节点5，父节点为5/2=2，左子结点为 2乘5=10，右子节点为 2乘5+1=11

### 3.堆的实现

- 堆的底层数据结构为完全二叉树，实现为数组。
- 堆可以分为最大堆和最小堆。

#### 3.1最大堆

- 最大堆是指，每个节点都不大于其父节点。
- 对每个父节点，一定不小于其所有孩子节点，而根节点就是所有节点中最大的。
- 对每个子树，子树的根也是子树所有节点中最大的。

#### 3.2最小堆

- 最小堆与最大堆正好相反，每个节点都不小于其父节点。
- 对每个父节点，一定不大于其所有孩子节点，而根节点就是所有节点中最小的。
- 对每个子树，子树的根也是子树所有节点中最小的。

### 4.堆的应用

####4.1优先级队列

- 一般队列实现类LinkedList是按添加顺序排队的。
- 在实际应用中，队列应该处理当前队列中优先级最高的。
- 高优先级的，即使添加得晚也要被优先处理。

####4.2求前K个最大的元素

- 元素个数不确定，数据量可能很大，并且处于动态变化中。
- 类似的问题有：求前K个最小的元素，求第K个最大的，求第K个最小的。

#### 4.3求中值元素

- 中值不是平均值，而是排序后中间那个元素的值。
- 数据量可能很大，并且处于动态变化中。

### 5.堆的时间复杂度

- 在添加和删除元素时，有两个关键的过程以保持堆的性质，一个是向上调整(siftup)，另一个是向下调整(siftdown)，它们的效率都为O(log2(N))。
- 由无序数组构建堆的过程，是一个自底向上循环的过程，效率为O(N)。
- 查找和遍历就是对数组的查找和遍历，效率为O(N)。

## 具体算法-最小堆/最大堆

### 1.添加元素(最小堆)

- 基本步骤

  1. 添加元素到最后位置，即直接添加到数组的最后一个位置。
  2. 与父节点比较，如果大于等于父节点则不变，否则与父节点进行交换。
  3. 操作指针向上传递，再与父节点比较和交换，直到父节点为空或者大于等于父节点。

- 实例

  <img src="https://javanote.oss-cn-shenzhen.aliyuncs.com/5_最小堆添加元素2.jpg"  />

  1. 在最小堆中添加元素3
  2. 先和父节点8交换，再和父节点6交换，再和父节点4交换，最后到起始结点。  

### 2.从头部删除元素(向下调整)

- 基本步骤
  1. 用最后一个元素替换头部元素，并删掉最后一个元素。(因为是数组实现，所以删除末尾不会耗费太多时间)
  2. 将新的头部与两个孩子节点中较小的比较，如果不大于该孩子节点则不变，否则与较小的孩子进行交换。
  3. 将操作指针向下传递，交换后，再与较小的孩子比较和交换。一直到没有孩子，或者不大于两个孩子节点。

### 3.从中间删除元素(向上或向下调整)

- 基本步骤
  1. 用最后一个元素替换头部元素，并删掉最后一个元素。(因为是数组实现，所以删除末尾不会耗费太多时间)
  2. 在替换后，如果该元素大于某孩子节点，则需向下调整。如果该元素小于父节点，则需向上调整。

### 4.将无序数组构建成一个最小堆

- 基本步骤

  1. 从最后一个非叶子节点开始，向上到根结点。对于每个节点，执行向下调整。
  2. 调整过程是自底向上，先使每个最小子树为堆，然后每对左右子树和其父节点合并，调整为更大的堆。
  3. 因为每个子树已经为堆，对父结点执行向下调整。这样一直合并调整到根结点。

  ```java
  // size表示节点个数, 节点编号从1开始，size/2表示第一个非叶节点的编号。
  void heapify() {
      for (int i=size/2; i >= 1; i--) {
          siftdown(i);
      }  
  }
  ```

  







