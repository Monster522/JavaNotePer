## 习题解析

### 1.位非运算代码

```java
public class Test {
    public static void main(String[] args) {
        int i = 5;
        int j = 10;
        System.out.println(i + ~j);
    }
}
/**
* 打印结果为：-6
* ~表示按位非，就是表示按位取反，比如”1100”取值为”0011”。
* -n = ~n + 1，所以~n = -11，所以结果等于-6。 
*/

```

### 2. 原码反码补码

- 在java虚拟机中整数有byte、short、int、long四种 分别表示 8位、16位、32位、64位有符号整数。
- 在计算机中，正数和负数都使用补码存储。

```java
/*
假设为byte字节，正数10，负数-10
原码：首位为符号位，剩下为数的二进制位
	+10的原码为：0000 1010
	-10的原码为：1000 1010

反码：一个数如果为正，则它的反码与原码相同；一个数如果为负，则符号位不变，其他位取反。
	+10的反码为：0000 1010
	-10的反码为：1111 0101

补码：一个数如果为正，则它的原码反码补码相同；一个数如果为负，取到反码然后加1。
	+10的补码为：0000 1010
	-10的补码为：1111 0110

[位非运算 ~]
操作数的第n位为1，那么结果的第n位为0，反之。位非运算不是求反码，反码符号位不变，位非会变。
	+6的二进制为：0000 0110
	~6的二进制为：1111 1001
	
由于在计算机中以补码存储，则
	~6的补码为：1111 1001
	~6的反码为：1111 1000
	~6的原码为：1000 0111
	~6的原码值为：-7       公式为：-n = ~n + 1 

*/
```



### 3.位运算

除了位非（~）是一元操作符，其他都是二元操作符，元表示操作单元。

- 左移( << ) ：将二进制数向左移动，低位补0。正数或负数都是补0。

  整数5，byte类型。

  5的二进制为：        0000 0101

  5<<2 的二进制为： 0001 0100

  

- 右移( >> ) ：将二进制数向右移动，正数右移高位用0补，负数右移高位用1补。

  正数5，byte类型。

  5的二进制为：        0000 0101

  5>>2 的二进制为： 0000 0001

  

  负数-5，byte类型。

  -5的二进制为：	  1000 0101(原码)   1111 1010(反码)   1111 1011(补码)

  -5>>2 的二进制为：1111 1110(补码)   1111  1101(反码)   1000 0010(补码)   -2

  

- 无符号右移( >>> )：正数/负数 无符号右移时用0进行补位，负数变正数。

  整数5，byte类型。

  5的二进制为：        0000 0101

  5>>2 的二进制为： 0000 0001

  

  负数-5，byte类型。

  -5的二进制为：	  1000 0101(原码)   1111 1010(反码)   1111 1011(补码)

  -5>>2 的二进制为(变为正数)：0011 1110(补码)   0011 1110(反码)   0011 1110(补码)   62

  

- 位与( & )：第一个操作数的的第n位于第二个操作数的第n位如果都是1，那么结果的第n为也为1，否则为0。

  5的二进制为：  0000 0101

  3的二进制为：  0000 0011

  运算  5 & 3  ：  0000 0001     

  

- 位或( | )：第一个操作数的的第n位于第二个操作数的第n位 只要有一个是1，那么结果的第n为也为1，否则为0。

  5的二进制为：  0000 0101

  3的二进制为：  0000 0011

  运算  5 | 3  ：    0000 0111

  

- 位异或( ^ )：第一个操作数的的第n位于第二个操作数的第n位 相反，那么结果的第n为也为1，否则为0。

  5的二进制为：  0000 0101

  3的二进制为：  0000 0011

  运算  5 ^ 3  ：   0000 0110

  

- 位非( ~ )：操作数的第n位为1，那么结果的第n位为0，反之。公式：~n = -n-1

  5的二进制为：  0000 0101

  ~5 的二进制为：1111 1010(补码)   1111 1001(反码)  1000 0110(原码)  -6 



### 4.变量初始化程序代码

```java
public class Person{
    //实例变量：已经分配了内存空间，但是没有初始化
    static int arr[] = new int[5];      
    public static void main(String a[]){
        //输出默认值
   		System.out.println(arr[0]);		 
    }
}
/**
* 编译正确，输出0
* 类的实例变量会被默认初始化，方法里的局部变量不会被默认初始化。
* char类型默认为空格，int类型默认为0，String类型默认为null。
*/
```

### 5.基础类型转换

- 设int x=1,float y=2,则表达式x/y的值是：0.5

  int类型会向float高精度类型转换，所以结果就是float类型0.5。

### 6.静态变量

- 如果是本类使用，可以直接就用静态变量名。
- 如果是其他类使用，可以使用类名来调用，也可以创建一个实例对象来调用。
- 如果静态变量所在的类是静态类，那么不管在本类里或者在其他外部类，都可以直接使用静态变量名。

### 7.基本类型和引用类型

- java语言是强类型语言，支持的类型分为两类：基本类型和引用类型。
- 基本类型包括boolean类型和数值类型，数值类型有整数类型和浮点类型。整数类型包括：byte、short、int、long和char。浮点类型包括：float和double。
- 引用类型包括类、接口和数组类型以及特殊的null类型。

### 8. == 和 !=  运算符

- == 可用于基本类型和引用类型。

  当用于基本类型时候，是比较值是否相同。

  当用于引用类型的时候，是比较对象地址是否相同。

### 9.数组的两种声明方式

- int score[] = new int[10];
- int[] score = new int[10];
- 如果是基本类型数组，未赋值元素则为默认值。如果是引用类型数组，未赋值元素则为null。

### 10.数据类型

- 原始类型和包装类

| 原始类型 | char      | boolean | byte | short | int     | long | float | double |
| -------- | --------- | ------- | ---- | ----- | ------- | ---- | ----- | ------ |
| 包装类   | Character | Boolean | Byte | Short | Integer | Long | Float | Double |

- 不同的原始类型在JVM的空间分配

| 原始类型 |  默认值  | 占用字节 | 位数 |     取值范围     |
| :------: | :------: | :------: | :--: | :--------------: |
|   byte   |    0     |    1     |  8   |  -2^7  ~  2^7-1  |
|  short   |    0     |    2     |  16  | -2^15  ~  2^15-1 |
|   int    |    0     |    4     |  32  | -2^31  ~  2^31-1 |
|   long   |    0     |    8     |  64  | -2^63  ~  2^63-1 |
|  float   |   0.0f   |    4     |  32  | -2^31  ~  2^31-1 |
|  double  |   0.0d   |    8     |  64  | -2^63  ~  2^63-1 |
|   char   | '\u0000' |    2     |  16  |   0  ~  2^16-1   |
| boolean  |  false   |    1     |  8   |   true / false   |

- 枚举类型

  枚举（enum）类型是Java 5新增的特性，它是一种新的类型，允许 **用常量来表示特定的数据片断** ，而且全部都以类型安全的形式来表示，是特殊的类，可以拥有成员变量和方法。

### 11. Math类的四舍五入

- Math.floor(-8.5) = (double) -9.0

  1. floor： 求小于参数的最大整数，返回double类型。

     Math.floor(-4.2) = -5.0

  2. ceil：求大于参数的最小整数，返回double类型。

     Math.ceil(5.6) = 6.0

  3. round：对小数进行四舍五入后的结果，返回int类型。

     Math.round(-4.6) = -5

### 12.小数变量

```java
/**
* 1.1.0默认为double，会发生double转float错误，应该加上f
*/
public class Test{
    private float f=1.0;	//1.0默认为double，会发生double转float错误，应该加上f
    int m=12;
    static int n=1;
    public static void main(String args[]){
        Test t=new Test();
    }
}

```

### 13. this关键字

- 原理：this关键字就是对当前对象的引用。

- 应用：

  1. 调用本类的非静态属性，就是类中的成员变量。
  2. 调用本类中的其他方法。
  3. 调用本类中的其他构造方法，调用时要放在构造方法的首行。

- this不能调用静态变量和静态方法

  static方法是类方法，static变量是类变量，先于任何的实例（对象）存在。对象是在创建时才在内存中生成，this指的是当前对象，所有类变量/类方法不属于当前对象，this不能和static共用。

### 14.数组的机制

- 数组是一种派生类（引用类型），不是原生类（基本类型）。
- 数组大小一旦指定就不准再次改变。

### 15.计算十六进制相加的值

- 变量a是一个64位有符号的整数，初始值用16进制表示为：0x7FFFFFFFFFFFFFFF;变量b是一个64位有符号的整数，初始值用16进制表示为：0x8000000000000000。则a+b的结果用10进制表示为多少？

  a+b = 0xFFFF FFFF FFFF FFFF （十六进制）

  a+b = 1111 1111 1111 1111 1111 1111 1111 1111 （二进制）

  符号位为1，则为负数。

  补码：1111 1111 1111 1111 1111 1111 1111 1111

  反码：1111 1111 1111 1111 1111 1111 1111 1110

  源码：1000 0000 0000 0000 0000 0000 0000 0001      值为 -1

### 16.byte类型计算

```java
byte b1=1,b2=2,b3,b6; 
final byte b4=4,b5=6; 
b6=b4+b5; 
b3=(b1+b2); 
System.out.println(b3+b6);

/**
* 1.被final修饰的变量是常量，这里的b6=b4+b5可以看成是b6=10；在编译时就已经变为b6=10了
* 2.而b1和b2是byte类型，Java中进行计算时候将他们提升为int类型，再进行计算，b1+b2计算后已经是int类型，赋值给
*   b3，b3是byte类型，类型不匹配，编译不会通过，需要进行强制转换。
* 3.Java中的byte，short，char进行计算时都会提升为int类型。
*/
```

### 17.数组复制方法效率对比

- System.arraycopy > clone > Arrays.copyOf > for循环

### 18.二维数组的声明方式

- 数组命名时名称与[]可以随意排列，但声明的二维数组中第一个中括号中必须要有值，它代表的是在该二维数组中有多少个一维数组。

  ```java
  float f[][] = new float[6][6];
  float []f[] = new float[6][6];
  float [][]f = new float[6][6];
  float [][]f = new float[6][];
  ```
### 19.char基本类型

- char类型的字符都可以转换成int类型数字进行运算。

### 20.变量的命名规则

- 标识符可以包括这4种字符：字母、下划线、$、数字；
- 开头不能是数字；
- 不能是关键字

### 21.byte类型溢出

```java
public class Test2
{
    public void add(Byte b)
    {
        b = b++;
    }
    public void test()
    {
        Byte a = 127;
        Byte b = 127;
		//在进入add前，a会自增1。Byte类型值大小为-128~127之间，所以会越界，编程-128
        //add函数并不会改变a和b的值，所以a=-128，b=127
        add(++a);		
        System.out.print(a + " ");
        add(b);
        System.out.print(b + "");
    }
}

```

### 22.基本类型自动转换

- 自动转换按从低到高的顺序转换。向上转换正常，向下转换会发生数据异常。

  byte,short,char -> int -> long -> float -> double

- 低级向高级是隐式转换，高级向低级

- 数据类型的转换，分为自动转换和强制转换。

  自动转换是程序在执行过程中 “ 悄然 ” 转换，不需要用户提前声明，一般是从位数低的类型向位数高的类型转换。

  强制类型转换则必须在代码中声明，转换顺序不受限制。

### 23.Java中的关键字和保留字

- true 、false、null、friendly、sizeof  在Java中不是关键字，也不是保留字，但是不能在程序中作为标识符。
- 其中const和goto是java的保留字，true、false、null都是显示常量值。
- Java所有的关键字都是小写的。

### 24. 关键字和保留字列表

- 关键字

  abstract, assert, boolean, break,byte, case, catch, char, class, const（保留关键字）, continue, default, do, double, else,enum, extends, final, finally, float, for, goto（保留关键字）, if, implements, import, instanceof,int, interface, long, native, new, package, private, protected, public, return,short, static, strictfp, super, switch, synchronized, this, throw, throws,transient, try, void, volatile, while

- 保留字（指现版本尚未使用，不排除以后版本会作为关键字）/
  byValue, cast, false, future, generic,inner, operator, outer, rest, true, var, goto(保留关键字), const(保留关键字), null

- 既是关键字也是保留字：goto、const

### 25.boolean默认值

- boolean的值只有true和false，默认值为false，没有null。
- Boolean的值可以设为null。

### 26.Math类计算余弦值

- cos()方法计算余弦值
- toRadians()是将角度转换为弧度
- toDegrees()是将弧度转换为角度

### 27.赋值运算符 =

- Java 程序中使用赋值运算符进行对象赋值时，只存在一个对象。

  比如A=B，只是把A对象的地址指向了B对象的地址，所以其实内存中对象只有一个。

### 28.整型专属运算符

- Java中只有整型才能使用的运算符为：取余运算符 %

### 29.自动转换类型

- 两个数值进行二元操作时，会有如下的转换操作:
  1. 如果其中有一个是double类型，另一个数就会转换为double类型。
  2. 不是double的情况下，如果其中一个是float类型，另一个将会转换为float类型。
  3. 不是double、float的情况下，如果其中一个操作数是long类型，另一个会转换为long类型。
  4. 不是double、float、long的情况下，两个操作数都转换为int类型。

### 30.switch语句

- switch括号内的控制表达式只能是short、char、int、long整数类型和枚举类型，不能是float，double和boolean类型。
- String类型是java7开始支持。

### 31.Lanbda表达式

- Lanbda表达式的主要作用就是代替匿名内部类的繁琐语法， 由三部分组成：

  1. 形参列表。形参列表允许省略形参类型。如果形参列表中只有一个参数，甚至连形参列表的圆括号也可以省略。
  2. 箭头（ -> ）。必须通过英文中画线和大于符号组成。
  3. 代码块。如果代码块只包含一条语句，Lambda表达式允许省略代码块的花括号，那么那条语句就不要用花括号表示语句结束。Lambda代码块只有一条return语句，甚至可以省略return关键字。Lambda表达式需要返回值，而它的代码块中仅有一套省略了return的语句。Lambda表达式会自动返回这条语句的值。

  ```java
  dir.listFiles((File f)->f.getName().endsWith(“.Java”));
  dir.listFiles( f->f.getName().endsWith(“.Java”));
  
  ```

  





