## 源代码到机器码的编译过程

###编译过程中的编译器分类

| 编译器     | 具体实现的软件                                  |
| ---------- | ----------------------------------------------- |
| 前端编译器 | Sund的Javac、Eclipse JDT中的增量式编译器（ECJ） |
| JIT编译器  | HotSpot VM 的C1、C2编译器                       |
| AOT编译器  | GNU Compiler for the Java（GCJ）、Excelsior JET |



### 1.前端编译器：源代码到字节码

- 主要功能：将Java源码（.java文件）编译成 字节码（.class文件），class文件为一连串的 16 进制二进制流。主要工具为 javac 命令。

  ```shell
  > javac Demo.java
  > ls 
  Demo.java Demo.class
  ```
  
- 执行流程：

  1. Java Source Code   →  Compiler  →  Byte Code。
  2. 运行 javac 命令的过程，其实就是 javac 编译器解析 Java 源代码，并生成字节码文件的过程。
  3. 原理是 javac 编译器把 Java 语言规范转化为字节码语言规范。

  

- Javac 编译器处理过程（四个阶段）：

  1. 词法、语法分析。在这个阶段，JVM 会对源代码的字符进行一次扫描，最终生成一个抽象的语法树。简单地说，在这个阶段 JVM 会分析代码的逻辑，弄清楚代码要表达的意思。
  2. 填充符号表。类之间是会互相引用的，但在编译阶段无法确定其具体的地址，所以使用一个符号来替代。在这个阶段，就是对抽象的类或接口进行符号填充。等到类加载阶段，JVM 会将符号替换成具体的内存地址。
  3. 注解处理。 Java 是支持注解的，在这个阶段会对注解进行分析，根据注解的作用将其还原成具体的指令集。
  4. 分析与字节码生成。到了这个阶段，JVM 便会根据上面几个阶段分析出来的结果，进行字节码的生成，最终输出为 class 文件。

### 2.JIT 编译器：从字节码到机器码

- 当源代码转化为字节码之后，其实要运行程序有两种方式。一种是使用 Java 解释器解释执行字节码，另一种则是使用 JIT 编译器将字节码转化为本地机器代码。在实际情况中，为了运行速度以及效率，我们通常采用两者相结合的方式进行 Java 代码的编译执行。

![](https://github.com/Monster522/ImageBed/blob/master/1_aa17d38a-8769-43e9-bd03-16c7d62cd890.png?raw=true)

| 执行方式                   | 优点                   |                                                              |
| :------------------------- | :--------------------- | ------------------------------------------------------------ |
| 解释器执行字节码           | 启动速度快但运行速度慢 | 解释器不需要像 JIT 编译器一样，将所有字节码都转化为机器码，自然就少去了优化的时间。解释器每次读取部分代码，然后解释运行。 |
| 编译器将字节码转换为机器码 | 启动速度慢但运行速度快 | 当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。机器码的运行效率肯定是高于 Java 解释器的。 |

- HotSpot 虚拟机内置了两个即时编译器（JIT   Just-In-Time）

| 编译器名称        | 特点                                                         |
| ----------------- | ------------------------------------------------------------ |
| Client Compiler | 称为C1 编译模式，会将字节码编译为本地代码，进行简单、可靠的优化，如有必要将加入性能监控的逻辑。编译速度快，编译质量略差。 |
| Server Compiler   | 称为C2 编译模式，也是将字节码编译为本地代码，但是会启用一些编译耗时较长的优化，甚至会根据性能监控信息进行一些不可靠的激进优化。编译速度慢，编译质量好。 |

- 虚拟机选择执行程序的模式

1. 混合模式（Mixed Mode） 。即 C1 和 C2 两种模式混合起来使用，这是默认的运行模式。如果你想单独使用 C1 模式或 C2 模式，使用 `-client` 或 `-server` 打开即可。

2. 解释模式（Interpreted Mode）。即所有代码都解释执行，使用 `-Xint` 参数可以打开这个模式。

3. 编译模式（Compiled Mode）。 此模式优先采用编译，但是无法编译时也会解释执行，使用 `-Xcomp` 打开这种模式。

4. 可以通过 java -version 来查看虚拟机的模式。

   ```shell
   PS C:\Users\Monster_0522> java -version
   java version "1.8.0_181"
   Java(TM) SE Runtime Environment (build 1.8.0_181-b13)
   Java HotSpot(TM) 64-Bit Server VM (build 25.181-b13, mixed mode)
   ```

### 3.AOT 编译器：源代码到机器码

- 基本思想：在程序执行前生成 Java 方法的本地代码，以便在程序运行时直接使用本地代码。但是 Java 语言本身的动态特性带来了额外的复杂性，影响了 Java 程序静态编译代码的质量，例如Java中的动态加载。

- AOT 编译器从编译质量上来看，肯定比不上 JIT 编译器。其存在的目的在于避免 JIT 编译器的运行时性能消耗或内存消耗，或者避免解释程序的早期性能开销。

- 在运行速度上来说，AOT 编译器编译出来的代码比 JIT 编译出来的慢，但是比解释执行的快。而编译时间上，AOT 也是一个始终的速度。所以说，AOT 编译器的存在是 JVM 牺牲质量换取性能的一种策略。

- 编译速度上，解释执行 > AOT 编译器 > JIT 编译器。

  编译质量上，JIT 编译器 > AOT 编译器 > 解释执行。