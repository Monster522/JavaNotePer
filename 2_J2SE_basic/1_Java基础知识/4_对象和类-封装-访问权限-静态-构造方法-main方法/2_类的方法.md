## 类的方法

### 1.构造方法

- 定义命名

  ```java
  /**
  * 书写标准：
  * 1. 方法名和类名一样。
  * 2. 无返回类型，无void。
  * 3. 可以被权限控制符修饰，public/protected/private
  * 使用标准：
  * 1. 只能由系统调用。
  * 2. 对象成员可以由构造方法进行初始化。
  * 3. 可以重载，方法参数个数/参数类型/排序顺序，必须不同。
  **/
  public class test {
      // 实例变量
      private String name;
      
      // 构造方法1
      public test(String name){
          this.name = name;
      }
      
      // 构造方法2
      public test(int val) {
          this.name = val.toString;
  	}
  }
  ```

- 单个或多个构造方法

  如果不显式写出构造方法，类默认生成一个没有参数的构造方法。

  只要声明构造方法，则类不再默认生成。

  一般都要自己声明一个不带参数的构造方法。

- 父类和子类

  新建子类对象时，会自动调用父类的构造方法，再调用子类的构造方法。

  在子类构造方法中，可以使用关键字super来调用父类的构造方法。

  如果父类构造方法只存在有参数的，则在子类中必须采用super来调用，编译器不会自动调用。

- 构造方法的修饰符

  可以用public、private、protected修饰。不能被static、final、synchronized、abstract和native修饰。

  构造方法不能被子类继承，所以用final修饰没有意义。

  构造方法用于创建一个新的对象，不能作为类的静态方法，所以用static修饰没有意义。

  Java语言不支持native或synchronized的构造方法。

###2.静态方法

- 在类方法中不能用this来调用本类的类方法。（this表示本类的一个实例对象）

- 在类方法中调用本类的类方法时可直接调用。

- 静态方法可以被继承，但是不能重写。

  如果父类中有一个静态的方法，子类也有一个与其方法名，参数类型，参数个数都一样的方法，并且也有static关键字修饰，那么该子类的方法会把原来继承过来的父类的方法隐藏，而不是重写。

### 3.普通方法

- 书写标准

  Java类中的方法可以和类名同名，但一般不这样做。

- 修饰符

  **public**（公共控制符）

  **private**（私有控制符）指定此方法只能有自己类等方法访问，其他的类不能访问（包括子类）

  **protected**（保护访问控制符）指定该方法可以被它的类和子类进行访问。

  **final**，指定该方法不能被重载。

  **static**，指定不需要实例化就可以激活的一个方法。

  **synchronize**，同步修饰符，在多个线程中，该修饰符用于在运行前，对他所属的方法加锁，以防止其他线程的访问，运行结束后解锁。

  **native**，本地修饰符。指定此方法的方法体是用其他语言在程序外部编写的。

### 4.main()方法

```java
/**
* 参数说明：
* public: 因为权限必须是最大的。
* static: 不需要对象,直接用主函数所属类名调用即可。
* void: 主函数没有具体的返回值。
* main: 函数名,不是关键字,只是一个 jvm 识别的固定的名字。
* String[] arg: 命令行参数。这是主函数的参数列表,是一个数组类型的参数,而且元素都是字符串类型的。
**/
public class test {
    public static void main(String[] args) {}
}
```

main方法是程序的入口，且必须是特定格式才能被JVM识别，只有args可以改动，其他都不能改动。

main()方法可以重载。

```java
public class test {
    public static void main(String[] args) {}
    private String main(int val) {}
}
```

### 5.finalize()方法

- Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。
- 这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在 Object 类中定义的，因此所有的类都继承了它。
- **子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作**。finalize() 方法是在垃圾收集器删除对象之前对这个对象调用的。
- finalize不一定被jvm调用，只有当垃圾回收器要清除垃圾时才被调用。

### 6.方法中的参数

- 形参和实参

  形式参数，用于定义方法的时候使用的参数，目的用来接收调用该方法时传递的参数。只有在被调用时才会分配内存单元，在调用结束，即刻释放所分配的内存单元。因此，只在方法内才有效。

  实际参数，用于调用时传递给方法的参数，即传递给被调用方法的值。预先创建并赋予确定值。

- 形式参数的修饰符

  对于形式参数只能用final修饰符，其它任何修饰符都会引起编译器错误 。

  用这个修饰符也有一定的限制，就是在方法中不能对参数做任何修改。

  一般情况下，一个方法的形参不用final修饰。只有在特殊情况下，那就是 **方法内部类** 。一个方法内的内部类如果使用了这个方法的参数或者局部变量的话，这个参数或局部变量应该是final。

- 相同和区别

  形参只在函数内部有效,函数调用结束返回主调用函数后则不能再使用该形参变量。

  实参可以是常量、变量、表达式、函数等。必须预先使参数获得确定值，才能进行函数调用。

  实参和形参在数量上，类型上、顺序上应严格一致，否则就会发生类型不匹配的错误。

  实参到形参的传递方式分为值传递和引用传递。

### 7.值传递和引用传递

```java
//第一个例子：基本类型 --值传递
void foo(int value) {
    value = 100;
}
foo(num); // num 没有被改变

//第二个例子：没有提供改变自身方法的引用类型 --引用传递但值不改变
void foo(String text) {
    text = "windows";
}
foo(str); // str 也没有被改变

//第三个例子：提供了改变自身方法的引用类型 --引用传递值改变
StringBuilder sb = new StringBuilder("iphone");
void foo(StringBuilder builder) {
    builder.append("4");
}
foo(sb); // sb 被改变了，变成了"iphone4"。

//第四个例子：提供了改变自身方法的引用类型，但是不使用，而是使用赋值运算符。 --引用传递值不改变
StringBuilder sb = new StringBuilder("iphone");
void foo(StringBuilder builder) {
    builder = new StringBuilder("ipad");
}
foo(sb); // sb 没有被改变，还是 "iphone"。

/**
* 总结：
* 如果参数是基本类型(String)，传递的是基本类型的字面量值的拷贝，方法内部有自己的存储单元。称为值传递。
* 如果参数是引用类型，传递的是该参量所引用的对象在堆中地址值的拷贝。称为引用传递。
*/
```

### 8.方法的重载

```java
/**
* 定义标准：
* 1. 所有方法必须放在同一个类。
* 2. 方法名必须相同。
* 3. 方法参数必须不同，类型/数量/顺序 上不同。 
* 4. 返回值可以相同，可以不相同。
**/
public String logo(int i);
public String logo(String str);
public int logo(char ch);
```

### 9.系统打印方法

```java
/**
* System 是java.lang中的类
* out为System中的一个静态成员,out是java.io.PrintStream类的对象
* println()是java.io.PrintStream类的方法
* 所以可以调用  类.静态成员.静态方法println() 方法
**/
System.out.printf();
```



### 

