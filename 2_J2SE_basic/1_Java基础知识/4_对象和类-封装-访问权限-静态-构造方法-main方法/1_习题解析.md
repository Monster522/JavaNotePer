## 习题解析

### 1.类的访问权限

|            | private | default | protected | public |
| ---------- | :-----: | :-----: | :-------: | :----: |
| 同一个类中 |    √    |    √    |     √     |   √    |
| 同一个包中 |         |    √    |     √     |   √    |
| 子类中     |         |         |     √     |   √    |
| 全局范围内 |         |         |           |   √    |

### 2.char类型和中文字符

- char foo='中'，是否正确？（假设源文件以GB2312编码存储，并且以javac – encoding GB2312命令编译）

  java的char类型占两个字节，默认使用GBK编码存储，所以可以使用char存储中文字符。

### 3.   .java文件中公共类必须和文件名一样

- 文件的非公共类，公共的内部类不需要和文件名一样。

### 4.对象序列化正确的说法

- 使用ObjectOutputStream和ObjectInputStream可以将对象进行传输。
- transient 修饰的变量在对象串化的时侯并不会将所赋值的值保存到传中，串化的对象从磁盘读取出来仍然是null。
- 对象序列化的所属类需要实现Serializable接口。

### 5.transient关键字的作用

- 一个对象只要实现了Serilizable接口，这个对象就可以被序列化。将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中。

```java
/**
* 1.一旦变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问。
* 2.transient关键字只能修饰变量，而不能修饰方法和类。注意，本地变量(局部变量)是不能被transient关键字修饰的。
*   变量如果是用户自定义类变量，则该类需要实现Serializable接口。 
* 3.被transient关键字修饰的变量不再能被序列化，一个静态变量不管是否被transient修饰，均不能被序列化。
* 4.对象的序列化可以通过实现两种接口来实现。若实现的是Serializable接口，则所有的序列化将会自动进行。若实现的
*   是Externalizable接口，则没有任何东西可以自动序列化，需要在writeExternal方法中进行手工指定所要序列化的变
*   量，这与是否被transient修饰无关。
*/
class User implements Serializable {
    private static final long serialVersionUID = 8294180014912103005L;  
    
    private String username;
    private transient String passwd; //passwd属性不会被序列化
    
    public String getUsername() {
        return username;
    }
    
    public void setUsername(String username) {
        this.username = username;
    }
    
    public String getPasswd() {
        return passwd;
    }
    
    public void setPasswd(String passwd) {
        this.passwd = passwd;
    }

}
```

### 6.构造方法正确的说法

- 构造方法的方法名必须与类名（public 类）相同。构造方法没有返回类型，也不能定义为void，在方法名前面不声明方法类型。

- 构造方法的主要作用是完成对象的初始化工作，它能够把定义对象时的参数传给对象的域。

- 一个类可以定义多个构造方法，如果在定义类时没有定义构造方法，则编译系统会自动插入一个无参数的默认构造器，这个构造器不执行任何代码。构造方法可以重载，以参数的个数，类型，顺序。

- 不能被static、final、synchronized、abstract和native修饰；访问权限修饰符是可以的。

### 7.static关键字

- static关键字，修饰实例变量为静态变量，修饰方法为静态方法。
- 静态变量和静态方法，可以直接通过类名进行调用；其他的成员和方法则需要进行实例化成对象之后，通过对象来调用。
- 静态变量在第一次使用的时候就会初始化，有且只有一个成员对象，可以通过对象调用或者类名.变量名的方式来调用。

### 8.静态变量运行代码

```java
/**
* 方法是static静态方法，直接使用"类.方法"即可，因为静态方法使用不依赖对象是否被创建。
* null可以被强制类型转换成任意类型（不是任意类型对象），于是可以通过它来执行静态方法。
*/

public class TestClass {
    private static void testMethod(){
        System.out.println("testMethod");
    }
    public static void main(String[] args) {
        ((TestClass)null).testMethod();	//null不是实例对象，可以转换成任意类型
    }
}

```

### 9.对象的初始化方式

- 构造器方法

- 通过Class反射

  实例化无参构造的类，通过forName()方法实例化Class对象(即反射操作)，然后用Class类中的newInstance()方法。

  实例化带参数构造的类，需要使用Class类中的getConstructors()方法获取所有的构造。

### 10. Java中类的加载顺序

- 父类静态代码块(包括静态初始化块，静态属性，但不包括静态方法)
- 子类静态代码块(包括静态初始化块，静态属性，但不包括静态方法 )
- 父类非静态代码块( 包括非静态初始化块，非静态属性 )
- 父类构造函数
- 子类非静态代码块 ( 包括非静态初始化块，非静态属性 )
- 子类构造函数
- **类中静态块按照声明顺序执行**，并且 **父类和子类的静态代码块** 不需要调用new类实例的时候就执行了(意思就是在类加载到方法区的时候执行的)

### 11.系统打印方法

- System.out.printf()

  System是java.lang中的类，out为System中的一个静态成员，out是java.io.PrintStream类的对象，而println()是java.io.PrintStream类的方法，所以可以调用  类.静态成员.静态方法println() 方法。

### 12.方法的形式参数

-  形式参数可被视为local variable(局部变量)，形参和局部变量一样都不能离开方法。都只有在方法内才会发生作用，也只有在方法中使用，不会在方法外可见。

- 对于形式参数只能用final修饰符，其它任何修饰符都会引起编译器错误。用这个修饰符的限制就是在方法中不能对参数做任何修改。
- 不过一般情况下，一个方法的形参不用final修饰。只有在特殊情况下，那就是 **方法内部类** 。  一个方法内的内部类如果使用了这个方法的参数或者局部变量的话，这个参数或局部变量应该是final。
- 方法的参数列表指定要传递给方法什么样的信息，采用的都是对象的形式，引用传递。

### 13.方法的值传递和引用传递

```java
//第一个例子：基本类型
void foo(int value) {
    value = 100;
}
foo(num); // num 没有被改变

//第二个例子：没有提供改变自身方法的引用类型
void foo(String text) {
    text = "windows";
}
foo(str); // str 也没有被改变

//第三个例子：提供了改变自身方法的引用类型
StringBuilder sb = new StringBuilder("iphone");
void foo(StringBuilder builder) {
    builder.append("4");
}
foo(sb); // sb 被改变了，变成了"iphone4"。

//第四个例子：提供了改变自身方法的引用类型，但是不使用，而是使用赋值运算符。
StringBuilder sb = new StringBuilder("iphone");
void foo(StringBuilder builder) {
    builder = new StringBuilder("ipad");
}
foo(sb); // sb 没有被改变，还是 "iphone"。

/**
* 总结：
* 如果参数是基本类型，传递的是基本类型的字面量值的拷贝。
* 如果参数是引用类型，传递的是该参量所引用的对象在堆中地址值的拷贝。     
*/
```

### 14.finalize()方法

- Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。
- 这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在 Object 类中定义的，因此所有的类都继承了它。
- **子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作**。finalize() 方法是在垃圾收集器删除对象之前对这个对象调用的。
- finalize不一定被jvm调用，只有当垃圾回收器要清除垃圾时才被调用。

### 15.类名和方法名

- Java类中的方法可以和类名同名，但一般不这样做。

### 16.静态代码块

- 无法直接调用静态初始化块。
- 在创建第一个实例前或引用任何静态成员之前，将自动调用静态初始化块来初始化。
- 静态初始化块既没有访问修饰符，也没有参数。

### 17. package语句

- package语句必须作为源文件的第一条非注释性语句，一个源文件只能指定一个包，只能包含一条package语句。

### 18.静态方法

- 在类方法中不能用this来调用本类的类方法。
- 在类方法中调用本类的类方法时可直接调用。

### 19.类的修饰符

- 因为普通类也就是外部类，只能用 public, abstract 和 final 修饰。
- 内部类则可以用 修饰成员变量的修饰符修饰内部类，比如 private、static、protected 修饰。

### 20.final关键字

- final修饰的成员变量在赋值时可以有三种方式

  在声明时直接赋值

  在构造器中赋值

  在初始代码块中进行赋值
  
- 用final修饰的方法不能被重写，但是可以被重载。