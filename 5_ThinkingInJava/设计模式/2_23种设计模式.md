



## 设计模式的分类

### 1.软件模式概念

- 软件模式是将模式的一般概念应用于软件开发领域，即软件开发的 总体指导思路或参照样板。
- 软件模式并非仅限于设计模式，还包括架构模式、分析模式和过程模式等，实际上，在软件生存期的每一 个阶段都存在着一些被认同的模式。

### 2.目标

- 能在白纸上画出所有的模式结构和时序图。
- 能用代码实现，如果模式的代码都没有实现过，是用不出来的。即所谓，看得懂，不会用。
- 灵活应用到工作中的项目中。

###3.创建型模式
- 创建型模式涉及对象的实例化，特点是不让用户代码依赖于对象的创建或排列方式，避免直接使用new创建对象。
- 5种创建型模式
  1. 工厂方法模式（简单工厂模式）
  2. 抽象工厂模式
  3. 单例模式
  4. 建造者模式（生成器模式）
  5. 原型模式

###4.结构型模式
- 结构型模式涉及如何组合类和对象以形成更大的结构，和类有关的结构型模式涉及如何合理使用继承机制，和对象有关的结构型模式涉及如何合理的使用对象组合机制。
- 7种结构型模式
  1. 适配器模式
  2. 装饰器模式
  3. 代理模式
  4. 外观模式（门面模式）
  5. 桥接模式
  6. 组合模式
  7. 享元模式

###5.行为型模式
- 行为型模式涉及怎样合理的设计对象之间的交互通信，以及怎样合理为对象分配职责，让设计富有弹性，易维护，易复用。
- 11种行为型模式
  1. 策略模式
  2. 模板方法模式
  3. 观察者模式
  4. 迭代子模式
  5. 责任链模式
  6. 命令模式
  7. 备忘录模式
  8. 状态模式
  9. 访问者模式
  10. 中介者模式
  11. 解释器模式
- 其实还有两类：并发型模式和线程池模式。

### 6.设计模式之间的关系

![](https://github.com/Monster522/ImageBed/blob/master/3_5dd3af5c-a40c-43de-9f83-30aa5755c2a7.jpg?raw=true)

## 设计模式六大原则


###1.开闭原则（Open Close Principle）
就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。

###2.里氏代换原则（Liskov Substitution Principle）
面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。

###3.依赖倒转原则（Dependence Inversion Principle）
开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。

###4.接口隔离原则（Interface Segregation Principle）
使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。

###5.迪米特法则（最少知道原则）（Demeter Principle）
一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。

###6.合成复用原则（Composite Reuse Principle）
原则是尽量使用合成/聚合的方式，而不是使用继承。



## 创建型设计模式

###1.单例模式（Singleton Pattern）

- 定义

  单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。

- **特点**

  1. 单例类 只能有一个实例。
  2. 单例类 必须自行创建这个实例。
  3. 单例类 必须自行向整个系统提供这个实例。

- 代码层面要点

  1. 单例类的构造函数为私有。 -- 自行创建
  2. 提供一个自身的静态私有成员变量。-- 只能有一个实例  / 自己向系统提供实例
  3. 提供一个公有的静态工厂方法。 -- 向系统提供实例

- 应用环境

  1. 系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器，或者需要考虑资源消耗太大而只允许创建一个对象。
  2. 客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例。
  3. 在一个系统中要求一个类只有一个实例时才应当使用单例模式。反过来，如果一个类可以有几个实例共存，就需要对单例模式进行改进，使之成为多例模式。

- 优点

  1. 提供了对唯一实例的受控访问。因为单例类封装了它的唯一实例，所以可以**严格控制客户怎样以及何时访问它**，并为设计及开发团队提供了共享的概念。
  2. 由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象，单例模式无疑可以提高系统的性能。
  3. 允许可变数目的实例。我们可以基于单例模式进行扩展，使用与单例控制相似的方法来获得指定个数的对象实例。

- 缺点

  1. 由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。
  2. 单例类的职责过重，在一定程度上违背了“单一职责原则”。因为单例类既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法，将产品的创建和产品的本身的功能融合到一起。
  3. 滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出。现在很多面向对象语言(如Java、C#)的运行环境都提供了自动垃圾回收的技术，因此，如果实例化的对象长时间不被利用，系统会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致对象状态的丢失。

###2.简单工厂模式(Simple Factory Pattern)

- 定义

  简单工厂模式中，**可以根据参数的不同返回不同类的实例**。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。又称为静态工厂方法(Static Factory Method)模式。

- 模式结构

  ![](https://github.com/Monster522/ImageBed/blob/master/6_9d2b17af-7a7a-4e89-bd98-ef377626c118.jpg?raw=true)

  1. Factory(工厂角色)：工厂角色负责实现创建所有实例的内部逻辑。
  2. Product(抽象产品角色)：抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口。
  3. ConcreteProduct(具体产品角色)：具体产品角色是创建目标，所有创建的对象 都是这个角色的实例。

- 应用环境

  1. 工厂类负责创建的对象比较少,由于创建的对象较少,不会造成工厂方法中的业务逻辑太过复杂。
  2. 客户端只知道传入工厂类的参数,对于如何创建对象不关心.客户端既不需要关心创建细节,甚至连类名都不需要记住,只需要知道类型所对应的参数。

- 优点

  1. 工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例。客户端可以免除直接创建产品对象的责任，而仅仅“消费”产品。简单工厂模式通过这种做法**实现了对责任的分割**，它提供了专门的工厂类用于创建对象。
  2. 客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可。对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量。
  3. 通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。

- 缺点

  1. 由于工厂类集中了所有产品创建逻辑，一旦不能正常工作，整个系统都要受到影响。
  2. 使用简单工厂模式将会增加系统中类的个数，在一定程序上增加了系统的复杂度和理解难度。
  3. 系统扩展困难，一旦添加新产品就不得不修改工厂逻辑。在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。
  4. 简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。

- 代码应用实例

  ```java
  //JDK类库中广泛使用了简单工厂模式，如工具类java.text.DateFormat，它用于格式化一个本地日期或者时间。
  public final static DateFormat getDateInstance();
  public final static DateFormat getDateInstance(int style);
  public final static DateFormat getDateInstance(int style,Localelocale);
  
  //Java加密技术
  KeyGenerator keyGen=KeyGenerator.getInstance("DESede");//获取不同加密算法的密钥生成器
  Cipher cp=Cipher.getInstance("DESede");//创建密码器
  ```

### 3.工厂方法模式(Factory Method Pattern)

- 定义

  在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而**工厂子类则负责生成具体的产品对象**，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类，更适合扩展新产品。又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。

  工厂方法也具有唯一性，一般情况下，一个具体工厂中只有一个工厂方法或者一组重载的工厂方法。

- 模式结构

  ![](https://github.com/Monster522/ImageBed/blob/master/7_06eb3ca4-d99e-43c5-b5f4-ba33ba14c162.jpg?raw=true)

  1. Product(抽象产品)：所有产品的父类接口。
  2. ConcreteProduct(具体产品)：所有被创建产品的实例。
  3. Factory(抽象工厂)：拥有创建方法的父类接口，便于扩展。
  4. ConcreteFactory(具体工厂)：创建产品的具体实例工厂。

- 应用环境

  1. 一个类不知道它所需要的对象的类。在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可。具体的产品对象由具体工厂类创建，客户端需要知道创建具体产品的工厂类。
  2. 一个类通过其子类来指定创建哪个对象。在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象。利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而**使得系统更容易扩展**。
  3. 将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，**需要时再动态指定**，可将具体工厂类的类名存储在配置文件或数据库中。

- 优点

  1. 在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节。**用户只需要关心所需产品对应的工厂，无须关心创建细节**，甚至无须知道具体产品类的类名。
  2. 基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。**它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。**工厂方法模式之所以又被称为多态工厂模式，是因为所有的具体工厂类都具有同一抽象父类。
  3. 使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。这样，系统的**可扩展性**也就变得非常好，完全符合“开闭原则”。

- 缺点

  1. 在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。
  2. 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。

- 代码应用实例

  ```java
  //JDBC工厂方法
  Connection conn = DriverManager.getConnection("jdbc:microsoft:sqlserver://localhost:1433; DatabaseName=DB;user=sa;password=");
  Statement statement = conn.createStatement();
  ResultSet rs = statement.executeQuery("select * from UserInfo");
  ```



### 4.抽象工厂模式(Abstract Factory Pattern)

- 定义

  1. 产品等级结构：产品等级结构即产品的继承结构，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。
  2. 产品族：在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品。如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中。

  3. 抽象工厂模式与工厂方法模式最大的区别在于，**工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构。**一个工厂等级结构 可以负责多个 不同产品等级结构中的产品对象 的创建 。当一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象时，抽象工厂模式比工厂方法模式更为简单、有效率。

- 模式结构

  

  ![](https://github.com/Monster522/ImageBed/blob/master/8_b17ec1b4-45e3-4429-85a9-c409813ffddb.jpg?raw=true)

  1. AbstractFactory(抽象工厂)：定义了多个方法，可以创建出产品族的对象。工厂方法模式一般只定义一个方法。
  2. ConcreteFactory(具体工厂)：可以同时创建出多个产品族中的对象。
  3. AbstractProduct(抽象产品)：有多个抽象产品，不同的产品等级结构。
  4. Product(具体产品)：不同的产品等级结构中的产品，可以在同一个工厂里创建。

- 应用环境

  1. 一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是重要的。
  2. 系统中有多于一个的产品族，而每次只使用其中某一产品族。
  3. 属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。
  4. 系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。

- 优点

  1. 抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易。所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。另外，应用抽象工厂模式可以实现高内聚低耦合的设计目的，因此抽象工厂模式得到了广泛的应用。
  2. 当一个产品族中的多个对象被设计成一起工作时，它能够**保证客户端始终只使用同一个产品族中的对象**。这对一些需要根据当前环境来决定其行为的软件系统来说，是一种非常实用的设计模式。
  3. 增加新的具体工厂和产品族很方便，无须修改已有系统，符合“开闭原则”。

- 缺点

  1. 在添加新的产品对象时，难以扩展抽象工厂来生产新种类的产品，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其所有子类的修改，显然会带来较大的不便。

  2. 开闭原则的倾斜性（增加新的工厂和产品族容易，增加新的产品等级结构麻烦）。

- 扩展性

  **“开闭原则”要求系统对扩展开放，对修改封闭，通过扩展达到增强其功能的目的。**

  1. 增加产品族：对于增加新的产品族，工厂方法模式很好的支持了“开闭原则”，对于新增加的产品族，只需要对应增加一个新的具体工厂即可，对已有代码无须做任何修改。
  2. 增加新的产品等级结构：对于增加新的产品等级结构，需要修改所有的工厂角色，包括抽象工厂类，在所有的工厂类中都需要增加生产新产品的方法，不能很好地支持“开闭原则”。

- 工厂模式的演化
  1. 当抽象工厂模式中每一个具体工厂类只创建一个产品对象，也就是只存在一个产品等级结构时，抽象工厂模式退化成工厂方法模式。
  2. 当工厂方法模式中抽象工厂与具体工厂合并，提供一个统一的工厂来创建产品对象，并将创建对象的工厂方法设计为静态方法时，工厂方法模式退化成简单工厂模式。



###5. 建造者模式(Builder Pattern)

- 定义

  建造者模式是一步一步创建一个复杂的对象，**用户只需要通过指定复杂对象的类型和内容就可以构建一个复杂对象**，用户不需要知道内部的具体构建细节。建造者模式属于对象创建型模式，又称为生成器模式。

- 模式结构

  ![](https://github.com/Monster522/ImageBed/blob/master/9_e55c510e-d61f-4356-9671-f9e7c2585e19.jpg?raw=true)

  1. Builder(抽象建造者)：抽象类定义了建造者的基本方法。
  2. ConcreteBuilder(具体建造者)：具体建造者决定了 产品对象的建造过程。
  3. Director(指挥者)：隔离客户和生产的过程，负责控制产品的生成过程。
  4. Product(产品角色)：建造者的具体对象。

- 应用环境
  1. 需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性。
  2. 需要生成的产品对象的属性相互依赖，需要指定其生成顺序。
  3. 对象的创建过程独立于创建该对象的类。在建造者模式中引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类中。
  4. 隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。
- 优点
  1. 在建造者模式中， 客户端不必知道产品内部组成的细节，**将产品本身与产品的创建过程解耦**，使得相同的创建过程可以创建不同的产品对象。
  2. 每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者， 用户使用不同的具体建造者即可得到不同的产品对象 。
  3. 可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。
  4. 增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合“开闭原则”。
- 缺点
  1. **建造者模式所创建的产品一般具有较多的共同点，其组成部分相似**，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。
  2. 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。

- 建造者和抽象工厂模式比较
  1. 与抽象工厂模式相比，建造者模式返回一个组装好的完整产品 ，而 抽象工厂模式返回一系列相关的产品，这些产品位于不同的产品等级结构，构成了一个产品族。
  2. 在抽象工厂模式中，客户端实例化工厂类，然后调用工厂方法获取所需产品对象，而在建造者模式中，客户端可以不直接调用建造者的相关方法，而是通过指挥者类来指导如何生成对象，包括对象的组装过程和建造步骤，它侧重于一步步构造一个复杂对象，返回一个完整的对象。
  3. 如果将抽象工厂模式看成 汽车配件生产工厂 ，生产一个产品族的产品，那么建造者模式就是一个 汽车组装工厂 ，通过对部件的组装可以返回一辆完整的汽车。
  4. **如果抽象工厂中实例化对象的过程进行扩充，就会变成建造者模式。简单来说，抽象工厂注重于面，建造者注重于点。**









































































































## 结构型设计模式

##行为型模式