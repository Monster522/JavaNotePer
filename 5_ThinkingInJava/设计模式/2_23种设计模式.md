



## 设计模式的分类

### 1.软件模式概念

- 软件模式是将模式的一般概念应用于软件开发领域，即软件开发的 总体指导思路或参照样板。
- 软件模式并非仅限于设计模式，还包括架构模式、分析模式和过程模式等，实际上，在软件生存期的每一 个阶段都存在着一些被认同的模式。

### 2.目标

- 能在白纸上画出所有的模式结构和时序图。
- 能用代码实现，如果模式的代码都没有实现过，是用不出来的。即所谓，看得懂，不会用。
- 灵活应用到工作中的项目中。

###3.创建型模式
- 创建型模式涉及对象的实例化，特点是不让用户代码依赖于对象的创建或排列方式，避免直接使用new创建对象。
- 5种创建型模式
  1. 工厂方法模式（简单工厂模式）
  2. 抽象工厂模式
  3. 单例模式
  4. 建造者模式（生成器模式）
  5. 原型模式

###4.结构型模式
- 结构型模式涉及如何组合类和对象以形成更大的结构，和类有关的结构型模式涉及如何合理使用继承机制，和对象有关的结构型模式涉及如何合理的使用对象组合机制。
- 7种结构型模式
  1. 适配器模式
  2. 装饰器模式
  3. 代理模式
  4. 外观模式（门面模式）
  5. 桥接模式
  6. 组合模式
  7. 享元模式

###5.行为型模式
- 行为型模式涉及怎样合理的设计对象之间的交互通信，以及怎样合理为对象分配职责，让设计富有弹性，易维护，易复用。
- 11种行为型模式
  1. 策略模式
  2. 模板方法模式
  3. 观察者模式
  4. 迭代子模式
  5. 责任链模式
  6. 命令模式
  7. 备忘录模式
  8. 状态模式
  9. 访问者模式
  10. 中介者模式
  11. 解释器模式
- 其实还有两类：并发型模式和线程池模式。

### 6.设计模式之间的关系

![](https://javanote.oss-cn-shenzhen.aliyuncs.com/3_5dd3af5c-a40c-43de-9f83-30aa5755c2a7.jpg)

## 设计模式六大原则


###1.开闭原则（Open Close Principle）
就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。

###2.里氏代换原则（Liskov Substitution Principle）
面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。

###3.依赖倒转原则（Dependence Inversion Principle）
开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。

###4.接口隔离原则（Interface Segregation Principle）
使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。

###5.迪米特法则（最少知道原则）（Demeter Principle）
一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。

###6.合成复用原则（Composite Reuse Principle）
原则是尽量使用合成/聚合的方式，而不是使用继承。



## 创建型设计模式

1. 创建型模式(Creational Pattern)对类的实例化过程进行了抽象，**能够将软件模块中对象的创建和对象的使用分离**。
2. 为了使软件的结构更加清晰，外界对于这些对象只需要知道它们共同的接口，而不清楚其具体的实现细节，使整个系统的设计更加符合单一职责原则。
3. 创建型模式**隐藏了类的实例的创建细节**，通过隐藏对象如何被创建和组合在一起达到使整个系统独立的目的。



###1.单例模式(Singleton Pattern)

- 定义

  单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。

- **特点**

  1. 单例类 只能有一个实例。
  2. 单例类 必须自行创建这个实例。
  3. 单例类 必须自行向整个系统提供这个实例。

- 代码层面要点

  1. 单例类的构造函数为私有。 -- 自行创建
  2. 提供一个自身的静态私有成员变量。-- 只能有一个实例  / 自己向系统提供实例
  3. 提供一个公有的静态工厂方法。 -- 向系统提供实例

- 应用环境

  1. 系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器，或者需要考虑资源消耗太大而只允许创建一个对象。
  2. 客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例。
  3. 在一个系统中要求一个类只有一个实例时才应当使用单例模式。反过来，如果一个类可以有几个实例共存，就需要对单例模式进行改进，使之成为多例模式。

- 优点

  1. 提供了对唯一实例的受控访问。因为单例类封装了它的唯一实例，所以可以**严格控制客户怎样以及何时访问它**，并为设计及开发团队提供了共享的概念。
  2. 由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象，单例模式无疑可以提高系统的性能。
  3. 允许可变数目的实例。我们可以基于单例模式进行扩展，使用与单例控制相似的方法来获得指定个数的对象实例。

- 缺点

  1. 由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。
  2. 单例类的职责过重，在一定程度上违背了“单一职责原则”。因为单例类既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法，将产品的创建和产品的本身的功能融合到一起。
  3. 滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出。现在很多面向对象语言(如Java、C#)的运行环境都提供了自动垃圾回收的技术，因此，如果实例化的对象长时间不被利用，系统会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致对象状态的丢失。

###2.简单工厂模式(Simple Factory Pattern)

- 定义

  简单工厂模式中，**可以根据参数的不同返回不同类的实例**。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。又称为静态工厂方法(Static Factory Method)模式。

- 模式结构

  ![](https://javanote.oss-cn-shenzhen.aliyuncs.com/6_9d2b17af-7a7a-4e89-bd98-ef377626c118.jpg)

  1. Factory(工厂角色)：工厂角色负责实现创建所有实例的内部逻辑。
  2. Product(抽象产品角色)：抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口。
  3. ConcreteProduct(具体产品角色)：具体产品角色是创建目标，所有创建的对象 都是这个角色的实例。

- 应用环境

  1. 工厂类负责创建的对象比较少,由于创建的对象较少,不会造成工厂方法中的业务逻辑太过复杂。
  2. 客户端只知道传入工厂类的参数,对于如何创建对象不关心.客户端既不需要关心创建细节,甚至连类名都不需要记住,只需要知道类型所对应的参数。

- 优点

  1. 工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例。客户端可以免除直接创建产品对象的责任，而仅仅“消费”产品。简单工厂模式通过这种做法**实现了对责任的分割**，它提供了专门的工厂类用于创建对象。
  2. 客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可。对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量。
  3. 通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。

- 缺点

  1. 由于工厂类集中了所有产品创建逻辑，一旦不能正常工作，整个系统都要受到影响。
  2. 使用简单工厂模式将会增加系统中类的个数，在一定程序上增加了系统的复杂度和理解难度。
  3. 系统扩展困难，一旦添加新产品就不得不修改工厂逻辑。在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。
  4. 简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。

- 代码应用实例

  ```java
  //JDK类库中广泛使用了简单工厂模式，如工具类java.text.DateFormat，它用于格式化一个本地日期或者时间。
  public final static DateFormat getDateInstance();
  public final static DateFormat getDateInstance(int style);
  public final static DateFormat getDateInstance(int style,Localelocale);
  
  //Java加密技术
  KeyGenerator keyGen=KeyGenerator.getInstance("DESede");//获取不同加密算法的密钥生成器
  Cipher cp=Cipher.getInstance("DESede");//创建密码器
  ```

### 3.工厂方法模式(Factory Method Pattern)

- 定义

  在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而**工厂子类则负责生成具体的产品对象**，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类，更适合扩展新产品。又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。

  工厂方法也具有唯一性，一般情况下，一个具体工厂中只有一个工厂方法或者一组重载的工厂方法。

- 模式结构

  ![](https://javanote.oss-cn-shenzhen.aliyuncs.com/7_06eb3ca4-d99e-43c5-b5f4-ba33ba14c162.jpg)

  1. Product(抽象产品)：所有产品的父类接口。
  2. ConcreteProduct(具体产品)：所有被创建产品的实例。
  3. Factory(抽象工厂)：拥有创建方法的父类接口，便于扩展。
  4. ConcreteFactory(具体工厂)：创建产品的具体实例工厂。

- 应用环境

  1. 一个类不知道它所需要的对象的类。在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可。具体的产品对象由具体工厂类创建，客户端需要知道创建具体产品的工厂类。
  2. 一个类通过其子类来指定创建哪个对象。在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象。利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而**使得系统更容易扩展**。
  3. 将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，**需要时再动态指定**，可将具体工厂类的类名存储在配置文件或数据库中。

- 优点

  1. 在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节。**用户只需要关心所需产品对应的工厂，无须关心创建细节**，甚至无须知道具体产品类的类名。
  2. 基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。**它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。**工厂方法模式之所以又被称为多态工厂模式，是因为所有的具体工厂类都具有同一抽象父类。
  3. 使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而**只要添加一个具体工厂和具体产品就可以了**。这样，系统的**可扩展性**也就变得非常好，完全符合“开闭原则”。
  4. 工厂方法把简单工厂的内部逻辑判断移到了客户端代码来运行。工厂方法模式实现时，客户端需要决定实例化哪一个工厂来实现运算类。**修改创建产品的逻辑，从工厂类内部，转换到了客户端内部。**

- 缺点

  1. 在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。
  2. 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。

- 代码应用实例

  ```java
  //JDBC工厂方法
  Connection conn = DriverManager.getConnection("jdbc:microsoft:sqlserver://localhost:1433; DatabaseName=DB;user=sa;password=");
  Statement statement = conn.createStatement();
  ResultSet rs = statement.executeQuery("select * from UserInfo");
  ```



### 4.抽象工厂模式(Abstract Factory Pattern)

- 定义

  1. 产品等级结构：产品等级结构即产品的继承结构，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。
  2. 产品族：在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品。如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中。

  3. 抽象工厂模式与工厂方法模式最大的区别在于，**工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构。**一个工厂等级结构 可以负责多个 不同产品等级结构中的产品对象 的创建 。当一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象时，抽象工厂模式比工厂方法模式更为简单、有效率。

- 模式结构

  ![](https://javanote.oss-cn-shenzhen.aliyuncs.com/8_b17ec1b4-45e3-4429-85a9-c409813ffddb.jpg)

  1. AbstractFactory(抽象工厂)：定义了多个方法，可以创建出产品族的对象。工厂方法模式一般只定义一个方法。
2. ConcreteFactory(具体工厂)：可以同时创建出多个产品族中的对象。
  3. AbstractProduct(抽象产品)：有多个抽象产品，不同的产品等级结构。
  4. Product(具体产品)：不同的产品等级结构中的产品，可以在同一个工厂里创建。
  
- 应用环境

  1. 一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是重要的。
  2. 系统中有多于一个的产品族，而每次只使用其中某一产品族。
  3. 属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。
  4. 系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。

- 优点

  1. 抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易。所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。另外，应用抽象工厂模式可以实现高内聚低耦合的设计目的，因此抽象工厂模式得到了广泛的应用。
  2. 当一个产品族中的多个对象被设计成一起工作时，它能够**保证客户端始终只使用同一个产品族中的对象**。这对一些需要根据当前环境来决定其行为的软件系统来说，是一种非常实用的设计模式。
  3. 增加新的具体工厂和产品族很方便，无须修改已有系统，符合“开闭原则”。

- 缺点

  1. 在添加新的产品对象时，难以扩展抽象工厂来生产新种类的产品，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其所有子类的修改，显然会带来较大的不便。

  2. 开闭原则的倾斜性（增加新的工厂和产品族容易，增加新的产品等级结构麻烦）。

- 扩展性

  **“开闭原则”要求系统对扩展开放，对修改封闭，通过扩展达到增强其功能的目的。**

  1. 增加产品族：对于增加新的产品族，工厂方法模式很好的支持了“开闭原则”，对于新增加的产品族，只需要对应增加一个新的具体工厂即可，对已有代码无须做任何修改。
  2. 增加新的产品等级结构：对于增加新的产品等级结构，需要修改所有的工厂角色，包括抽象工厂类，在所有的工厂类中都需要增加生产新产品的方法，不能很好地支持“开闭原则”。

- 工厂模式的演化
  1. 当抽象工厂模式中每一个具体工厂类只创建一个产品对象，也就是只存在一个产品等级结构时，抽象工厂模式退化成工厂方法模式。
  2. 当工厂方法模式中抽象工厂与具体工厂合并，提供一个统一的工厂来创建产品对象，并将创建对象的工厂方法设计为静态方法时，工厂方法模式退化成简单工厂模式。



###5. 建造者模式(Builder Pattern)

- 定义

  建造者模式是一步一步创建一个复杂的对象，**用户只需要通过指定复杂对象的类型和内容就可以构建一个复杂对象**，用户不需要知道内部的具体构建细节。建造者模式属于对象创建型模式，又称为生成器模式。

- 模式结构

  ![](https://javanote.oss-cn-shenzhen.aliyuncs.com/9_e55c510e-d61f-4356-9671-f9e7c2585e19.jpg)

  1. Builder(抽象建造者)：抽象类定义了建造者的基本方法。
  2. ConcreteBuilder(具体建造者)：具体建造者决定了 产品对象的建造过程。
  3. Director(指挥者)：隔离客户和生产的过程，负责控制产品的生成过程。
  4. Product(产品角色)：建造者的具体对象。

- 应用环境
  1. 需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性。
  2. 需要生成的产品对象的属性相互依赖，需要指定其生成顺序。
  3. 对象的创建过程独立于创建该对象的类。在建造者模式中引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类中。
  4. 隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。
- 优点
  1. 在建造者模式中， 客户端不必知道产品内部组成的细节，**将产品本身与产品的创建过程解耦**，使得相同的创建过程可以创建不同的产品对象。
  2. 每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者， 用户使用不同的具体建造者即可得到不同的产品对象 。
  3. 可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。
  4. 增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合“开闭原则”。
- 缺点
  1. **建造者模式所创建的产品一般具有较多的共同点，其组成部分相似**，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。
  2. 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。

- 建造者和抽象工厂模式比较
  1. 与抽象工厂模式相比，建造者模式返回一个组装好的完整产品 ，而 抽象工厂模式返回一系列相关的产品，这些产品位于不同的产品等级结构，构成了一个产品族。
  2. 在抽象工厂模式中，客户端实例化工厂类，然后调用工厂方法获取所需产品对象，而在建造者模式中，客户端可以不直接调用建造者的相关方法，而是通过指挥者类来指导如何生成对象，包括对象的组装过程和建造步骤，它侧重于一步步构造一个复杂对象，返回一个完整的对象。
  3. 如果将抽象工厂模式看成 汽车配件生产工厂 ，生产一个产品族的产品，那么建造者模式就是一个 汽车组装工厂 ，通过对部件的组装可以返回一辆完整的汽车。
  4. **如果抽象工厂中实例化对象的过程进行扩充，就会变成建造者模式。简单来说，抽象工厂注重于面，建造者注重于点。**



## 结构型设计模式

1. 结构型模式(Structural Pattern)描述如何将类或者对象结合在一起形成更大的结构，就像搭积木，可以通过简单积木的组合形成复杂的、功能更为强大的结构。

   - 类结构型模式

     类结构型模式关心类的组合，由多个类可以组合成一个更大的系统，在类结构型模式中**一般只存在继承关系和实现关系**。

   - 对象结构型模式
   
     对象结构型模式关心类与对象的组合，通过关联关系使得**在一个类中定义另一个类的实例对象**，然后通过该对象调用其方法。
   
2. 根据“合成复用原则”，在系统中尽量使用关联关系来替代继 承关系，因此大部分结构型模式都是对象结构型模式。



### 1.适配器模式(Adapter Pattern)

- 定义

  客户端通过适配类，将对接口A的访问，转换成对接口B的访问。从而在不改原有逻辑代码的情况下，完成对新接口的访问。适配器模式使接口不兼容的类可以一起工作，分为类适配器模式和对象适配器模式。

- 模式结构

  类适配器模式：适配器类实现原接口，继承被适配的类

  ![](https://javanote.oss-cn-shenzhen.aliyuncs.com/12_cc6c87ae-42b2-42b8-999a-94c5bffc6156.png)

  对象适配器模式：适配器类实现原接口，内部实例化被适配的类

  ![](https://javanote.oss-cn-shenzhen.aliyuncs.com/11_cc6c87ae-42b2-42b8-999a-94c5bffc6156.png)

  1. Target：原调用接口或者抽象类
  2. Adapter：适配器类，客户端用来实现原调用接口的类
  3. Adaptee：适配者类，新调用类
  4. Client：客户端类

- 应用环境

  1. 系统需要使用现有的类，而这些类的接口不符合系统的需要。
  2. 想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。
  3. JDBC给出一个客户端通用的抽象接口，每一个具体数据库引擎（如SQL Server、Oracle、MySQL等）的JDBC驱动软件都是一个介于JDBC接口和数据库引擎接口之间的适配器软件。

- 优点

  1. 将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，而无须修改原有代码。
  2. 增加了类的透明性和复用性，将具体的实现封装在适配者类中，对于客户端类来说是透明的，而且提高了适配者的复用性。
  3. 灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。
  4. 类适配器：由于适配器类继承被适配的类，可以在适配器类中置换一些适配者的方法，灵活性更强。
  5. 对象适配器：在适配器类中，可以实例化被适配的类及其多个子类。

- 缺点

  1. 类适配器模式：对于Java、C#等不支持多重继承的语言，一次最多只能适配一个适配者类，而且目标抽象类只能为抽象类，不能为具体类，其使用有一定的局限性，不能将一个适配者类和它的子类都适配到目标接口。
  2. 对象适配器模式：与类适配器模式相比，要想置换适配者类的方法就不容易。

### 2.桥接模式(Bridge Pattern)

- 定义

  将抽象部分与它的实现部分分离，使它们都可以独立地变化。

  桥接模式主要应对的是由于实际的需要，某个类具有两个或者两个以上的维度变化（违反了SRP原则），如果只是用继承将无法实现这种需要，或者使得设计变得相当臃肿。

- 模式结构

  ![](https://javanote.oss-cn-shenzhen.aliyuncs.com/10_桥接模式.jpg)

  1. Abstraction：抽象类
  2. RefinedAbstraction：扩充抽象类（不继承Abstraction类，将其作为实例变量使用）（扩展属性1）
  3. Implementor：实现类接口（继承Abstraction，扩展属性2）
  4. ConcreteImplementor：具体实现类

- 桥接模式中的抽象化和实现化

  1. 抽象化：抽象化就是忽略一些信息，把不同的实体当作同样的实体对待。在面向对象中，将对象的共同性质抽取出来形成类的过程即为抽象化的过程。
  2. 实现化：针对抽象化给出的具体实现，就是实现化，抽象化与实现化是一对互逆的概念，实现化产生的对象比抽象化更具体，是对抽象化事物的进一步具体化的产物。
  3. 脱耦：脱耦就是将抽象化和实现化之间的耦合解脱开，或者说是将它们之间的强关联改换成弱关联，将两个角色之间的继承关系改为关联关系。桥接模式中的所谓脱耦，就是指在一个软件系统的抽象化和实现化之间使用关联关系（组合或者聚合关系）而不是继承关系，从而使两者可以相对独立地变化，这就是桥接模式的用意。

- 应用环境

  1. 如果需要开发一个跨平台视频播放器，可以在不同操作系统平台（如Windows、Linux、Unix等）上播放多种格式的视频文件，常见的视频格式包括MPEG、RMVB、AVI、WMV等。现使用桥接模式设计该播放器。
  2. 一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。
  3. 如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。
  4. 对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。

- 优点

  1. 分离抽象接口及其实现部分。
  2. 桥接模式有时类似于多继承方案，但是多继承方案违背了类的单一职责原则（即一个类只有一个变化的原因），复用性比较差，而且多继承结构中类的个数非常庞大，桥接模式是比多继承方案更好的解决方法。
  3. 桥接模式提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。
  4. 实现细节对客户透明，可以对用户隐藏实现细节。

- 缺点

  1. 桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。
  2.  桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性。

  

### 3.装饰模式(Decorator Pattern)

- 定义

  动态地给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更为灵活。

- 给一个类或对象增加行为的两种方式

  1. 继承机制，使用继承机制是给现有类添加功能的一种有效途径，通过继承一个现有类可以使得子类在拥有自身方法的同时还拥有父类的方法。这种方法是静态的，用户不能控制增加行为的方式和时机。
  2. 关联机制，即将一个类的对象嵌入另一个对象中，由另一个对象来决定是否调用嵌入对象的行为以便扩展自己的行为，这个嵌入的对象为装饰器(Decorator)

- 模式结构

  ![](https://javanote.oss-cn-shenzhen.aliyuncs.com/11_装饰模式.jpg)

  1. Component：抽象构件（给出一个抽象接口，以规范准备接受附加责任的对象）
  2. ConcreteComponent：具体构件（定义一个将要接收附加责任的类）
  3. Decorator：抽象装饰类（持有一个构件[Component]对象的实例，并定义一个与抽象构件接口一致的接口）
  4. ConcreteDecorator：具体装饰类（负责给构件对象“贴上”附加的责任）

- 应用环境

  1. 在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。

  2. 需要动态地给一个对象增加功能，这些功能也可以动态地被撤销。

  3. 当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。

     不能采用继承的情况主要有两类：

     - 第一类是系统中存在大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长
     - 第二类是因为类定义不能继承（如final类）

- 优点

  1. 与继承关系相比，关联关系的主要优势在于不会破坏类的封装性，而且继承是一种耦合度较大的静态关系，无法在程序运行时动态扩展。
  2. 在软件开发阶段，关联关系虽然不会比继承关系减少编码量，但是到了软件维护阶段，由于关联关系使系统具有较好的松耦合性，因此使得系统更加容易维护。
  3. 使用装饰模式来实现扩展比继承更加灵活，它以对客户透明的方式动态地给一个对象附加更多的责任。装饰模式可以在不需要创造更多子类的情况下，将对象的功能加以扩展。
  4. 具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，在使用时再对其进行组合，原有代码无须改变，符合“开闭原则”
  5. 通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合。可以使用多个具体装饰类来装饰同一对象，得到功能更为强大的对象。

- 缺点

  1. 装饰器模式中，关联关系的缺点是比继承关系要创建更多的对象。
  2. 使用装饰模式进行系统设计时将产生很多小对象，这些对象的区别在于它们之间相互连接的方式有所不同，而不是它们的类或者属性值有所不同，同时还将产生很多具体装饰类。这些装饰类和小对象的产生将增加系统的复杂度，加大学习与理解的难度。
  3. 这种比继承更加灵活机动的特性，也同时意味着装饰模式比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐。
  
- 实际应用

  1. JavaIO流的应用
![](https://javanote.oss-cn-shenzhen.aliyuncs.com/12_装饰模式JavaIO应用.png)

     

### 4.外观模式(Facade Pattern)

- 定义

  外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

- 模式结构

  ![](https://javanote.oss-cn-shenzhen.aliyuncs.com/13_外观模式.jpg)

  1. Facade: 外观角色（客户端的统一操作对象）
  2. SubSystem:子系统角色（外观角色控制的，作为实例变量）

- 模式分析

  1. 符合“单一职责原则”，在软件中将一个系统划分为若干个子系统有利于降低整个系统的复杂性，一个常见的设计目标是使子系统间的通信和相互依赖关系达到最小，而达到该目标的途径之一就是引入一个外观对象，它为子系统的访问提供了一个简单而单一的入口。 
  2. 符合“迪米特法则”，通过引入一个新的外观类可以降低原有系统的复杂度，同时降低客户类与子系统类的耦合度。
  3. 违背了“开闭原则”，当增加新的子系统或者移除子系统时需要修改外观类，可以通过引入抽象外观类在一定程度上解决该问题，客户端针对抽象外观类进行编程。

- 应用环境

  1. 客户程序与多个子系统之间存在很大的依赖性。引入外观类将子系统与客户以及其他子系统解耦，可以提高子系统的独立性和可移植性。
  2. 在层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度。
  3. 当要为一个复杂子系统提供一个简单接口时可以使用外观模式。

- 优点

  1. 对客户屏蔽子系统组件，减少了客户处理的对象数目并使得子系统使用起来更加容易。通过引入外观模式，客户代码将变得很简单，与之关联的对象也很少。
  2. 实现了子系统与客户之间的松耦合关系，这使得子系统的组件变化不会影响到调用它的客户类，只需要调整外观类即可。
  3. 降低了大型软件系统中的编译依赖性，并简化了系统在不同平台之间的移植过程，因为编译一个子系统一般不需要编译所有其他的子系统。一个子系统的修改对其他子系统没有任何影响，而且子系统内部变化也不会影响到外观对象。
  4. 只是提供了一个访问子系统的统一入口，并不影响用户直接使用子系统类。

- 缺点

  1. 不能很好地限制客户使用子系统类，如果对客户访问子系统类做太多的限制则减少了可变性和灵活性。
  2. 在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。

- 实例应用

  1. SLF4J 中的外观模式
  
     SLF4J 是简单的日志外观模式框架，抽象了各种日志框架例如 Logback、Log4j、Commons-logging 和 JDK 自带的 logging 实现接口。
     
     SLF4J 没有替代任何日志框架，它仅仅是标准日志框架的外观模式。如果在类路径下除了 SLF4J 再没有任何日志框架，那么默认状态是在控制台输出日志。
     
      Logback＋SLF4J 的组合是日志框架的最佳选择，比 SLF4J+其它日志框架 的组合要快一些。而且Logback的配置可以是XML或Groovy代码。

### 5.享元模式(Flyweight Pattern)

- 定义

  运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。由于享元模式要求能够共享的对象必须是细粒度对象，因此又称为轻量级模式，是一种对象结构型模式。

- 模式结构

  ![](https://javanote.oss-cn-shenzhen.aliyuncs.com/14_享元模式.jpg)

  1. Flyweight：抽象享元类。通常是一个接口或抽象类，在抽象享元类中声明了具体享元类公共的方法。可以向外界提供享元对象的内部数据(内部状态)，同时也可以通过这些方法来设置外部数据(外部状态)。
  2. ConcreteFlyweight:：具体享元类。内部状态为实例变量，是所有享元类中都存在的。实现了抽象享元类，其实例称为享元对象，在具体享元类中为内部状态提供了存储空间。可以结合单例模式来设计具体享元类，为每一个具体享元类提供唯一的享元对象。
  3. UnsharedConcreteFlyweight:：非共享具体享元类。不能被共享的子类可设计为非共享具体享元类，当需要一个非共享具体享元类的对象时可以直接通过实例化创建。
  4. FlyweightFactory：享元工厂类。享元工厂类用于创建并管理享元对象。针对抽象享元类编程，将各种类型的具体享元对象存储在一个享元池中，享元池一般设计为一个存储“键值对”的集合（也可以是其他类型的集合），可以结合工厂模式进行设计。当用户请求一个具体享元对象时，享元工厂提供一个存储在享元池中已创建的实例或者创建一个新的实例（如果不存在的话），返回新创建的实例并将其存储在享元池中。

- 模式分析

  享元模式以共享的方式高效地支持大量的细粒度对象，享元对象能做到共享的关键是区分内部状态(Internal State)和外部状态(External State)。

  1. 内部状态是存储在享元对象内部并且不会随环境改变而改变的状态，因此内部状态可以共享。
  2. 外部状态是随环境改变而改变的、不可以共享的状态。享元对象的外部状态必须由客户端保存，并在享元对象被创建之后，在需要使用的时候再传入到享元对象内部。一个外部状态与另一个外部状态之间是相互独立的。

- 应用环境

  1. 一个系统有大量相同或者相似的对象，由于这类对象的大量使用，造成内存的大量耗费。
  2. 对象的大部分状态都可以外部化，可以将这些外部状态传入对象中。
  3. 使用享元模式需要维护一个存储享元对象的享元池，而这需要耗费资源，因此，应当在多次重复使用享元对象时才值得使用享元模式。

- 优点

  1. 享元模式的优点在于它可以极大减少内存中对象的数量，使得相同对象或相似对象在内存中只保存一份。
  2. 享元模式的外部状态相对独立，而且不会影响其内部状态，从而使得享元对象可以在不同的环境中被共享。

- 缺点

  1. 享元模式使得系统更加复杂，需要分离出内部状态和外部状态，这使得程序的逻辑复杂化。
  2. 为了使对象可以共享，享元模式需要将享元对象的状态外部化，而读取外部状态使得运行时间变长。

- 享元模式和单例模式的区别

  1. 享元模式中，一个类可以存着多个对象，只是合并其中相同的对象。为了节约内存空间，提升程序性能。
  2. 单例模式中，一个类智能存着一个对象，目的是为了全局共享。

###6.代理模式(Proxy Pattern)

- 定义

  在某些情况下，一个客户不想或者不能直接引用一个对 象，此时可以通过一个称之为“代理”的第三者来实现间接引用。给某一个对象提供一个代 理，并由代理对象控制对原对象的引用。

- 模式结构

  ![](https://javanote.oss-cn-shenzhen.aliyuncs.com/15_代理模式.jpg)

  1. Subject：抽象角色。声明真实对象和代理对象的共同接口。
  2. Proxy：代理角色。代理对象角色内部含有对真实对象的引用，从而可以操作真实对象。
  3. RealSubject： 真实角色。代理角色所代表的真实对象，是我们最终要引用的对象。

- 模式分析

  1. 静态代理。

     真实角色必须是事先已经存在的，并将其作为代理对象的内部属性。

     实际使用时，一个真实角色必须对应一个代理角色。

  2. 动态代理。

     相当于代理者不仅仅只是代理一个真实对象，也可以代理很多对象，而且对象是动态指定的。

- 应用环境

  1. 远程(Remote)代理：为一个位于不同的地址空间的对象提供一个本地 的代理对象，这个不同的地址空间可以是在同一台主机中，也可是在 另一台主机中，远程代理又叫做大使(Ambassador)。
  2. 虚拟(Virtual)代理：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。
  3. Copy-on-Write代理：它是虚拟代理的一种，把复制（克隆）操作延迟 到只有在客户端真正需要时才执行。一般来说，对象的深克隆是一个 开销较大的操作，Copy-on-Write代理可以让这个操作延迟，只有对象被用到的时候才被克隆。
  4. 保护(Protect or Access)代理：控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。
  5. 缓冲(Cache)代理：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。
  6. 防火墙(Firewall)代理：保护目标不让恶意用户接近。
  7. 同步化(Synchronization)代理：使几个用户能够同时使用一个对象而没有冲突。
  8. 智能引用(Smart Reference)代理：当一个对象被引用时，提供一些额外的操作，如将此对象被调用的次数记录下来等。

- 优点

  1. 代理模式能够协调调用者和被调用者，在一定程度上降低了系 统的耦合度。
  2. 远程代理使得客户端可以访问在远程机器上的对象，远程机器 可能具有更好的计算性能与处理速度，可以快速响应并处理客户端请求。
  3. 虚拟代理通过使用一个小对象来代表一个大对象，可以减少系 统资源的消耗，对系统进行优化并提高运行速度。
  4. 保护代理可以控制对真实对象的使用权限。

- 缺点

  1. 由于在客户端和真实主题之间增加了代理对象，因此 有些类型的代理模式可能会造成请求的处理速度变慢。
  2. 实现代理模式需要额外的工作，有些代理模式的实现 非常复杂。

##行为型模式

1. 行为型模式(Behavioral Pattern)是对**在不同的对象之间划分责任和算法的抽象化**。

   - 行为型模式不仅仅关注类和对象的结构，而且重点关注它们之间的相互作用。
   - 更加清晰地划分类与对象的职责，并研究系统在运行时实例对象 之间的交互。
   - 在系统运行时，对象并不是孤立的，它们可以通过相互通信与协作完成某些复杂功能，一个对象在运行时也将影响到其他对象的运行。

2. 行为型模式分为类行为型模式和对象行为型模式两种

   - 类行为型模式。

     使用继承关系在几个类之间分配行为，类行为型模式主要通过多态等方式来分配父类与子类的职责。

   - 对象行为型模式

     使用对象的聚合关联关系来分配行为，对象行为型模式主要是通过对象关联等方式来分配两个或多个类的职责。根据“合成复用原则”，系统中要尽量使用关联关系来取代继承关系，因此大部分行为型设计模式都属于对象行为型设计模式。

### 1. 命令模式(Command Pattern)

- 定义

  对命令的封装，把发送命令和执行命令的责任分割开，分别委派给不同的对象。

  每一个命令都是一个操作，允许请求方与接收方独立开来，使之请求方不必清楚接收方的接口，更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。

- 模式结构

  ![](https://javanote.oss-cn-shenzhen.aliyuncs.com/16_命令模式.jpg)

  1. Command：抽象命令类。对需要执行的命令进行声明， 声明了用于执行请求的的`exceute()`等方法。
  2. ConcreteCommand：具体命令类。实现抽象类exceute()方法，持有接收者类。
  3. Invoker：调用者。调用命令的类，可以在命令前后进行处理。
  4. Receiver：接收者。负责接收命令并且执行命令。
  5. Client：客户类。利用调用者去调用命令。

- 模式分析

  命令模式的本质是对命令进行封装，将发出命令的责任和执行命令的责任分割开。

- 应用环境

  1. 系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。
  2. 系统需要在不同的时间指定请求、将请求排队和执行请求。
  3. 系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作。
  4. 系统需要将一组操作组合在一起，即支持宏命令

- 优点

  1. 降低系统的耦合度。
  2. 新的命令可以很容易地加入到系统中。
  3. 可以比较容易地设计一个命令队列和宏命令（组合命令）。
  4. 可以方便地实现对请求的Undo和Redo。

- 缺点

  1. 使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个命令都需要设计一个具体命令类，因此某些系统可能需要大量具体命令类，这将影响命令模式的使用。

### 2. 中介者模式(Mediator Pattern)

- 定义

  用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。

- 模式结构

  ![](https://javanote.oss-cn-shenzhen.aliyuncs.com/17_中介者模式.jpg)

  1. Mediator：抽象中介者。定义了同事对象调用中介对象的方法，也就是交互方法。
  2. ConcreteMediator：具体中介者。实现中介者接口的方法，需要从同事对象中接收信息，并且向同事对象发送信息。
  3. Colleague：抽象同事类。定义了同事对象公有的方法，持有一个中介者引用，子类通过该引用与中介者通信。
  4. ConcreteColleague：具体同事类。两个同事类进行通信时，一个同事类先与中介者通信，中介者再与另一个同事类通信。

- 模式分析

  中介者承担两方面的职责：

  1. 中转作用（结构性）

     通过中介者提供的中转作用，各个同事对象就不再需要显式引用其他同事，当需要和其他同事进行通信时，通过中介者即可。

  2. 协调作用（行为性）

     中介者可以更进一步的对同事之间的关系进行封装，同事可以一致地和中介者进行交互，而不需要指明中介者需要具体怎么做，中介者根据封装在自身内部的协调逻辑，对同事的请求进行进一步处理，将同事成员之间的关系行为进行分离和封装。

- 应用环境

  1. 系统中对象之间存在复杂的引用关系，产生的相互依赖关系结构混乱且难以理解。
  2. 一个对象由于引用了其他很多对象并且直接和这些对象通信，导致难以复用该对象。
  3. 想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。可以通过引入中介者类来实现，在中介者中定义对象。
  4. 交互的公共行为，如果需要改变行为则可以增加新的中介者类。

- 优点

  1. 简化了对象之间的交互。
  2. 将各同事解耦。
  3. 减少子类生成。
  4. 可以简化各同事类的设计和实现。

- 缺点

  1. 在具体中介者类中包含了同事之间的交互细节，可能会导致具体中介者类非常复杂，使得系统难以维护。

### 3.观察者模式(Observer Pattern)

- 定义
- 模式结构
- 模式分析
- 应用环境
- 优点
- 缺点

### 4.状态模式(State Pattern) 

- 定义
- 模式结构
- 模式分析
- 应用环境
- 优点
- 缺点

### 5.策略模式(Strategy Pattern)

- 定义
- 模式结构
- 模式分析
- 应用环境
- 优点
- 缺点

