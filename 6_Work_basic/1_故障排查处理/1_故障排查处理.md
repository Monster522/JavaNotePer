故障排查处理

### 1.Linux服务器基础

#### 1.1CPU处理器

##### 1.1.1CPU的主要功能

- **定义**
  1. 中央处理器`(CPU)`是计算机的主要设备之一，功能主要是**解释计算机指令**以及**处理计算机软件中的数据**。
  2.  中央处理器广义上指一系列可以执行复杂的计算机程序的逻辑机器。 
  3.  CPU的主要运作原理，不论其外观，都是执行储存于被称为程序里的一系列指令。 
- **CPU运作原理**
  1. **提取**
     - 从程序内存中检索指令(为数值或一系列数值)。由程序计数器指定程序存储器的位置，程序计数器保存供识别当前程序位置的数值。
     - 指令的提取常常必须从相对较慢的存储器查找，导致CPU等候指令的送入。
     - CPU根据从存储器提取到的指令来决定其执行行为。
  2. **解码**
     - 在解码阶段，指令被拆解为有意义的片断。
     - 根据CPU的指令集架构`(ISA)`定义将数值解译为指令
  3. **执行**
     - 在执行阶段，连接到各种能够进行所需运算的CPU部件。
     - 例如，要求一个加法运算，算术逻辑单元将会连接到一组输入和一组输出。
  4. **写回**
     - 在写回阶段，以一定格式将执行阶段的结果简单的写回。
     - 运算结果经常被写进CPU内部的寄存器，以供随后指令快速访问。

##### 1.1.1CPU占用率高的原因

-  计算密集型程序的CPU密集程度更高，计算操作比较多会导致CPU占用率过高。

##### 1.1.1CPU占用率过高会导致什么问题?

- CPU是用来运行各种程序，做各种计算的。
- 一旦CPU处于高负荷状态，容易引起服务响应速度变慢，进而导致整个服务不可用，特别是在业务高峰期可能导致雪崩效应，最终整个系统出现瘫痪。

####1.2内存

##### 1.2.1内存的主要功能

1. 随机存取存储器(RAM)是**与CPU直接交换数据的内部存储器**。
2. 可以随时读写(刷新时除外)，而且速度很快，通常作为操作系统或其他正在运行中的程序的临时数据存储介质。
3. 内存是电脑内部最主要的存储器，用来加载各式各样的程序与数据以供CPU直接运行与运用。

##### 1.2.1内存占用率高的原因

- **Linux内存占用率高**
  1. Linux 上的内存管理很复杂。尽管使用率高但未必存在问题。 
  2. Linux系统会在内存中缓存磁盘活动，基本上占用掉了未被使用的内存。使用空闲的内存增加磁盘访问速度，并且不占用运行中应用程序的内存。
  3. 用作磁盘缓存的内存空间当被需要时会立即归还，并且磁盘内容会被更新。
  4. 因此，**即使Linux内存占用率高，也不能说明性能下降**。
- **占用内存的操作**
  1. 和磁盘频繁进行数据交换，就会导致内存被占用。
  2. 处理大数据量，也会导致内存占用过高。

##### 1.2.1内存占用率过高会导致什么问题?

- **Linu的OOM(`Out Of Memory Killer`)机制**
  1. swap
     - 在linux里面，当物理内存不够用了，而又有新的程序请求分配内存，那么linux就会选择将其他程序暂时不用的数据交换到物理磁盘上(swap out)，等程序要用的时候再读进来(swap in)。
     - 这样做的坏处显而易见，swap in/swap out这里的代价比较大，相比数据一直放在内存里面，多了读磁盘的操作。而磁盘IO速度太慢，而且会有阻塞。
  2. OOM
     - 指在linux里面，由于系统内存压力，系统会选择保护一些系统进程，而将一些其他的进程kill掉，释放内存。 
- **性能下降**
  1. 内存使用率过高，容易引起服务响应速度变慢、服务器登录不上等问题 

####1.3Unix五大I/O模型

##### 1.3.1基础概念

- **用户空间和内核空间**
  1. 现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间(虚拟存储空间)为4G。
  2. 操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。
  3. 为了保证用户进程不能直接操作内核(kernel)，保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。
  4. 针对linux操作系统而言，将最高的1G字节(`从虚拟地址0xC0000000到0xFFFFFFFF`)，供内核使用，称为**内核空间**，而将较低的3G字节(`从虚拟地址0x00000000到0xBFFFFFFF`)，供各个进程使用，称为**用户空间**。
- **进程切换**
  1. 为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。
  2. 因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。
  3. 进程切换很耗费内存和CPU资源。
  4. 进程切换的流程
     - 保存处理机上下文，包括程序计数器和其他寄存器。
     - 更新PCB信息。
     - 把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。
     - 选择另一个进程执行，并更新其PCB。
     - 更新内存管理的数据结构。
     - 恢复处理机上下文。
- **进程的阻塞**
  1. 正在执行的进程，由于期待的某些事件未发生，如**请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做**等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。
  2. 可见，**进程的阻塞是进程自身的一种主动行为**，也因此只有处于运行态的进程(获得CPU)，才可能将其转为阻塞状态。
  3. 当进程进入阻塞状态，是不占用CPU资源的。简单点说就是等别人完成事务后你才能继续你的工作。
- **文件描述符fd**
  1. 文件描述符(`File descriptor`)是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。
  2. 文件描述符在形式上是一个非负整数。实际上，它是一个索引值，**指向内核为每一个进程所维护的该进程打开文件的记录表**。
  3. 当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。
  4. 在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。
- **缓存 I/O**
  1. 缓冲区及操作是所有I/O的基础
     进程执行I/O操作，归结起来就是向操作系统发出请求，让它要么把缓冲区里的数据排干(写)，要么把缓冲区填满(读)。
     ![](https://javanote.oss-cn-shenzhen.aliyuncs.com/1_缓存IO图.png)

  2. 缓存I/O的缺点
     数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作(先将数据准备到内核空间，再将数据拷贝到用户空间)，这些数据拷贝操作所带来的CPU以及内存开销是非常大的。

#####1.3.2I/O模型

- **基本流程**

  1. 对于一次IO访问(以read举例)，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。
  2. 所以说，当一个read操作发生时，它会经历两个阶段：
     - 等待数据准备(`Waiting for the data to be ready`)
     - 将数据从内核拷贝到进程中(`Copying the data from the kernel to the process`)

- **五大模型**

  1. 阻塞I/O`(blocking IO`)
  2. 非阻塞I/O(`nonblocking IO`)
  3. I/O多路复用(`IO multiplexing`)
  4. 信号驱动I/O(`signaldriven IO`)
  5. 异步I/O(`asynchronous IO`)

- **阻塞I/O**

  ![](https://javanote.oss-cn-shenzhen.aliyuncs.com/2_阻塞式IO.png)

  1. 当用户进程调用了recvfrom这个系统调用，kernel(内核)就开始了IO的第一个阶段：准备数据
     - 对于网络IO来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的UDP包。这个时候kernel就要等待足够的数据到来，磁盘I/O的情况就是等待磁盘数据从磁盘上读取到内核态内存中。
     - 数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。
  2. 在用户进程这边，整个进程会被阻塞（是进程自己选择的阻塞）。
  3. 当kernel一直等到数据准备好了，第二阶段开始，将数据从kernel中拷贝到用户内存。
     - 出于系统安全,用户态的程序没有权限直接读取内核态内存,因此内核负责把内核态内存中的数据拷贝一份到用户态内存中。
  4. 然后kernel返回结果，用户进程才解除block的状态，重新运行起来。
  5. blocking IO的特点就是在IO执行的两个阶段都被block了。

- **非阻塞I/O**

  <img src="https://javanote.oss-cn-shenzhen.aliyuncs.com/3_非阻塞式IO.png"  />

  1. socket设置为`NONBLOCK`(非阻塞)就是告诉内核，当所请求的I/O操作无法完成时，不要将进程睡眠，而是返回一个错误码(`EWOULDBLOCK`)，这样请求就不会阻塞。
  2. 当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么并不会block用户进程，而是立刻返回一个error。
  3. 从用户进程角度讲，发起一个read操作后，并不需要等待，而是马上就得到了一个结果。
     - 用户进程判断结果是一个error时，就知道数据还没有准备好，于是可以再次发送read操作。
     - 一旦kernel中的数据准备好了，并且又再次收到了用户进程的systemcall，那么kernel马上就将数据拷贝到了用户内存，然后返回。
  4. I/O操作函数将不断的测试数据是否已经准备好，如果没有准备好，继续测试，直到数据准备好为止。
     - 整个I/O请求的过程中，虽然用户线程每次发起I/O请求后可以立即返回。
     - 但是为了等到数据，仍需要不断地轮询、重复请求，消耗了大量的CPU的资源
  5. nonblockingIO的特点是，用户进程需要不断的主动询问kernel数据好了没有。在数据拷贝阶段，用户进程还是阻塞的。
  6. **一般很少直接使用这种模型**，而是在其他I/O模型中使用非阻塞I/O这一特性。**这种方式对单个I/O请求意义不大,但给I/O多路复用铺平了道路**。

- **I/O多路复用**

  ![](https://javanote.oss-cn-shenzhen.aliyuncs.com/4_IO多路复用.png)

  1. I/O多路复用会用到select或者poll函数，这两个函数会使进程阻塞，可以同时阻塞多个I/O操作。
     可以同时对多个读操作，多个写操作的I/O函数进行检测，直到有数据可读或可写时，才真正调用I/O操作函数。
  2. 从流程上来看，使用select函数进行I/O请求和同步阻塞模型没有太大的区别，甚至还多了添加监视socket，以及调用select函数的额外操作，效率更差。
  3. 最大的优势是，**用户可以在一个线程内同时处理多个socket的I/O请求**。
     用户可以注册多个socket，然后不断地调用select读取被激活的socket，即可达到在同一个线程内同时处理多个I/O请求的目的。
  4. 在同步阻塞模型中，必须通过多线程的方式才能达到这个目的。其实多路复用是同步非阻塞模型的Reactor模式的实现。

- **信号驱动IO**

  ![](https://javanote.oss-cn-shenzhen.aliyuncs.com/5_信号驱动.png)

  1. 首先允许socket进行信号驱动I/O,并安装一个信号处理函数，进程继续运行并不阻塞。
  2. 当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据。

- **异步IO**

  ![](https://javanote.oss-cn-shenzhen.aliyuncs.com/6_异步IO.png)

  1. 用户进程发起read操作之后，可以立刻返回，继续执行其他逻辑。
  2. 从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。
  3. 然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存。
  4. 当这一切都完成之后，kernel会给用户进程发送一个signal，通知read操作完成了。

#### 1.4IO负载

##### 1.4.1IO负载高的原因

- **负载的定义**
  1. 负载就是cpu在一段时间内正在处理以及等待cpu处理的进程数之和的统计信息，也就是**cpu使用队列的长度统计信息**，这个数字越小越好（如果超过CPU核心*0.7就是不正常）
  2. 负载分为两大部分：CPU负载、IO负载。
  3. 负载就是，需要运行处理但又必须等待队列前的进程处理完成的进程个数。 
  4. 事实证明，只有进程处于运行态(running)和不可中断状态(interruptible)才会被加入到负载等待进程中，也就是下面这两种情况的进程才会表现为负载的值。 
     - 即便需要立即使用CPU，也还需等待其他进程用完CPU。
     - 即便需要继续处理，也必须等待磁盘输入输出完成才能进行。
- **CPU负载**
  1. 程序主要被用来做计算、逻辑判断等处理，所以程序的处理速度主要依赖于cpu的计算速度。此类cpu负载的程序称为“计算密集型程序”。
- **IO负载**
  1. 程序主要从磁盘保存的大量数据中搜索找出任意文件。依赖于磁盘的读取速度，也就是输入输出(I/O)。此类I/O负载的程序，称为“I/O密集型程序”。
- **IO负载高的原因**
  1. 比如在Mysql中，如果没有加索引需要加载大量的数据到内存，导致等待IO的线程队列长负载高。
  2. 在网络IO中，如果是阻塞式IO，也会出现负载过高。

##### 1.4.2IO负载过高会导致什么问题?

- **IO和CPU的关系**
  1. **IO所需要的CPU资源非常少。大部分工作是分派给DMA完成的。**
  2. 现代计算机一般采用通道处理机，通道处理机是一个独立于cpu的外围设备，有少量的存储空间，可以独立完成输入输出操作。通道处理机完成了cpu指定的I/O操作，返回一个I/O中断。DMA和外围处理机也是完成I/O的方式，当然还有纯I/O程序控制。
  3. IO的五种方式：程序直接控制、中断、DMA、外围处理机、通道。
- **负载高导致的问题**
  1. CPU低而负载高，也就是说等待磁盘I/O完成的进程过多，就会导致队列长度过大。当需要进行同样IO的进程时，系统的反应就很慢。所以，当有多个进程需要进行磁盘I/O，就会导致服务阻塞住不可用。
  2. MySQL的数据是存储在硬盘中，如果需要进行sql查询，需要先把数据从磁盘加载到内存中。当在数据特别大的时候，如果执行的sql语句没有索引，就会造成扫描表的行数过大导致I/O阻塞，或者是语句中存在死锁，也会造成I/O阻塞，从而导致不可中断睡眠进程过多，导致负载过大。
     -  在MySQL中运行`show full processlist`命令查看线程等待情况，把其中的语句拿出来进行优化。 

### 2.CPU占用率过高或CPU异常

#### 2.1导致Java应用程序CPU使用率过高的原因

- **JAVA应用程序中CPU密集型操作**
  1. 频繁的GC
     - 如果访问量很高，可能会导致频繁的GC甚至FGC。
     - 当调用量很大时，内存分配将如此之快以至于GC线程将连续执行，这将导致CPU飙升。
  2. 序列化和反序列化。
     - 当程序执行xml解析时，调用量会增加，从而导致CPU变满。
  4. 正则表达式。 
     - 原因可能是Java正则表达式使用的引擎实现是NFA自动机，它将在字符匹配期间执行回溯。
  5. 线程上下文切换
     - 有许多已启动的线程，这些线程的状态在Blocked(锁定等待，IO等待等)和Running之间发生变化。
     - 当锁争用激烈时，这种情况很容易发生。
  6. 有些线程正在执行非阻塞操作，例如while(true)语句。如果在程序中计算需要很长时间，则可以使线程休眠。
- **导致CPU使用率过高的场景**
  1. while的无限循环。
     - 无限循环将调用CPU寄存器进行计数，此操作将占用CPU资源。 
     - 除非操作系统时间片到期，否则无限循环不会放弃占用的CPU资源，并且无限循环将继续向系统请求时间片，直到系统没有空闲时间来执行任何其他操作。
  2. 频繁的Young GC。
     - Young GC本身就是JVM用于垃圾收集的操作，它需要计算内存和调用寄存器。因此，频繁的Young GC必须占用CPU资源。
     - 比如：For循环从数据库中查询数据集合，然后再次封装新的数据集合。如果内存不足以存储，JVM将回收不再使用的数据。因此，如果所需的存储空间很大，CPU使用率会升高。
- **CPU和进程线程的关系**
  1. 分时操作系统使用循环方式为进程调度分配时间片。**如果进程正在等待或阻塞，将不会使用CPU资源**。线程称为轻量级进程，并共享进程资源。因此，线程调度在CPU中也是分时的。 
  2. 如果通过jstack检查系统线程状态时线程总数很大，但处于Runnable和Running状态的线程数不多，则CPU使用率不一定很高。
  3. **高CPU使用率的关键因素是计算密集型操作**。如果一个线程中有大量计算，则CPU使用率也可能很高。这也是数据脚本任务需要在大规模集群上运行的原因。
  4. CPU使用率的飙升更多是由于上下文切换或过多的可运行状态线程。 

#### 2.2CPU占用过高问题排查

- **使用top查看系统的资源占用情况**

  ![](https://javanote.oss-cn-shenzhen.aliyuncs.com/7_cpu故障排查top.png)

  1. 执行top命令，发现双核的CPU几乎全被一个PID为5739的进程给用掉了，99.2%的用户空间(也可以叫用户态)消耗，极有可能是出现了死循环。
  2. Java应用造成us高的主要原因是**线程一直处于可运行(`Runnable`)状态**，通常这些线程在执行无阻塞操作、循环、正则或纯粹的计算等任务，另一个可能**造成us高的原因是频繁GC**。

- **使用ps命令查看进程对应的是哪个程序**

  ![](https://javanote.oss-cn-shenzhen.aliyuncs.com/8_cpu故障ps.png)

  1. 也可以使用jps命令

- **使用top -p [PID] -H 观察该进程中所有线程的资源占用**

  ![](https://javanote.oss-cn-shenzhen.aliyuncs.com/9_cpu故障线程.png)

  1. 命令`  top -p 5739 -H `，-p表示需要监控的进程id，-H表示显示每个线程的情况。
  2. 发现若干线程实时CPU占用率(%CPU)较高，并且处理机使用时间(TIME+)非常长，6146线程实际占有处理机852分钟40.44秒。

- **使用jstack查看线程快照**

  ![](https://javanote.oss-cn-shenzhen.aliyuncs.com/10_cpu故障之jstack.png)

  1.  jstack后面的参数是PID的值，nid的含义是操作系统映射的线程id，可以通过nid的值过滤上面占用CPU较高的6146线程，**线程id需要转成十六进制，并且字母要小写**。 
  2.  通过观察输出，可以看到线程长期处于可运行状态，直接根据堆栈信息找到对应的代码。 
  3. 可以使用` jstack pid > xxx.log `输出堆栈到文件，到http://fastthread.io/index.jsp分析

### 3.内存占用过高

- 使用top -c命令查看实时的进程使用情况，输入M可以安装内存使用比率排序

  ![](https://javanote.oss-cn-shenzhen.aliyuncs.com/11_内存top.png)

- 使用jmap命令查看占用内存最大的前20个对象

  `jmap -histo 10831 | head -20`

  ![](https://javanote.oss-cn-shenzhen.aliyuncs.com/12_内存jmap命令.png)

- 使用jmap命令把整个内存情况转成文件形式保存下来(**谨慎使用**)

  `jmap -dump:live,format=b,file=xxx.hprof PID`

  1.  输出内存对象的明细，来定位具体方法位置。这个命令是将内存里的所有信息都输出出来，输出的文件大小和内存大小基本一致。 
  2.  这个命令会导致应用暂时挂起，所以谨慎使用。 

- 最后对dump出来的文件进行分析。文件大小不是很大的话，使用jdk自带的jhat命令即可

- dump文件太大的话，可以使用jprofiler工具来分析。

  

### 4.IO负载高

- **使用iostat从系统纬度查看磁盘IO负载**

  1. iostat并非常见Linux发行版本自带工具，其包含在sysstat软件包中，需要先通过yum或apt-get等方式进行安装后才能使用。

  ```shell
  # 执行命令：iostat -d -k 2
  # -d：显示设备（磁盘）使用状态。
  # -k：表示让某些使用block为单位的列强制使用kB为单位。
  # 2：数据显示每隔2秒刷新一次。
  Linux 3.10.0-123.9.3.el7.x8664 (centos)     06/27/2016     _x86_64    (1 CPU)
  Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
  xvda              0.58         0.12         3.75     278001    8820028
  xvdb              0.00         0.00         0.00        740          0
  xvdc              0.00         0.00         0.00       1388          0
  xvde              0.00         0.00         0.00       2035          0
  xvdf              0.00         0.00         0.00        740          0
  ```

  

- **使用iotop从进程纬度查看磁盘IO负载**

  1. 默认情况下按照IO使用量倒序排序，可以用左右箭头操作排序的字段。
  2. 按r切换排序方式。
  3. 按o只显示有磁盘IO活动的进程。

  ![](https://javanote.oss-cn-shenzhen.aliyuncs.com/13_IO负载高排查.png)

  

### 5.网络异常


### 6.JVM故障

#### 6.1内存泄露(MemoryLeak)

- **定义**

  1. 是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。
  2. **内存泄露最终会导致内存溢出**。

- **内存泄露可分为4类**

  1. **常发性内存泄漏**
     - 发生内存泄漏的代码会被多次执行到，每次被执行的时候都会导致一块内存泄漏。

  2. **偶发性内存泄漏**
     - 发生内存泄漏的代码只有在某些特定环境或操作过程下才会发生。
     - 常发性和偶发性是相对的。对于特定的环境，偶发性的也许就变成了常发性的。所以测试环境和测试方法对检测内存泄漏至关重要。

  3. **一次性内存泄漏**
     - 发生内存泄漏的代码只会被执行一次，或者由于算法上的缺陷，导致总会有一块仅且一块内存发生泄漏。
     - 比如，在类的构造函数中分配内存，在析构函数中却没有释放该内存，所以内存泄漏只会发生一次。

  4. **隐式内存泄漏**
     - 程序在运行过程中不停的分配内存，但是直到结束的时候才释放内存。
     - 严格的说这里并没有发生内存泄漏，因为最终程序释放了所有申请的内存。
     - 但是对于一个服务器程序，需要运行几天，几周甚至几个月，不及时释放内存也可能导致最终耗尽系统的所有内存。

- **内存泄露的危害**

  1. 从用户使用程序的角度来看，内存泄漏本身不会产生什么危害，作为一般的用户，根本感觉不到内存泄漏的存在。
  2. 真正有危害的是内存泄漏的堆积，这会最终消耗尽系统所有的内存。
  3. 一次性内存泄漏并没有什么危害，因为它不会堆积，而隐式内存泄漏危害性则非常大，因为较之于常发性和偶发性内存泄漏它更难被检测到。

- **内存泄露的原因**

  1. 内存泄露是指，无用对象(不再使用的对象)持续占有内存或无用对象的内存得不到及时释放，从而造成的内存空间的浪费。
  2. **长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露**，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是java中内存泄露的发生场景。

- **内存泄露的场景**

  1. **静态集合类引起内存泄露**

     ```java
     // 静态集合类的生命周期和应用程序一致,其所引用的所有的对象Object也不能被释放.
     Static Vector v = new Vector(10);
     for (int i = 1; i<100; i++) {
     	Object o = new Object();
     	v.add(o);
         // 如果仅仅释放引用本身(o=null),那么Vector仍然引用该对象，所以这个对象对GC来说是不可回收的.
     	o = null;	
     }
     ```

     

  2. **当集合里面的对象属性被修改后，再调用remove()方法时不起作用**

     ```java
     public static void main(String[] args) {
         // 初始化一个集合
     	Set<Person> set = new HashSet<Person>();
     	Person p1 = new Person("唐僧","pwd1",25);
     	Person p2 = new Person("孙悟空","pwd2",26);
     	Person p3 = new Person("猪八戒","pwd3",27);
     	set.add(p1);
     	set.add(p2);
     	set.add(p3);
         // 结果：总共有3个元素.
     	System.out.println("总共有:"+set.size()+" 个元素!"); 
         // 修改p3的年龄,此时p3元素对应的hashcode值发生改变
     	p3.setAge(2); 
         // 此时remove不掉，造成内存泄漏
     	set.remove(p3); 
         // 重新添加，居然添加成功
     	set.add(p3); 
         // 结果：总共有4个元素!
     	System.out.println("总共有:"+set.size()+" 个元素!"); 
         
     	for (Person person : set) {
     		System.out.println(person);
     	}
     }
     ```

     

  3. **监听器**

     - 通常一个应用当中会用到很多监听器，会调用一个控件的诸如addXXXListener()等方法来增加监听器。

     - 但往往在释放对象的时候却没有记住去删除这些监听器，从而增加了内存泄漏的机会。 

       

  4. **各种连接**

     - 比如数据库连接(`dataSourse.getConnection()`)，网络连接(`socket`)和io连接，除非其显式的调用了其close()方法将其连接关闭，否则是不会自动被GC 回收的。 

     - 对于`Resultset`和`Statement`对象可以不进行显式回收，但`Connection`一定要显式回收。因为`Connection`任何时候都无法自动回收，而`Connection`一旦回收，`Resultset`和`Statement`对象就会立即为NULL。

     - 如果使用连接池，情况就不一样了，除了要显式地关闭连接，还必须显式地关闭`Resultset Statement`对象(关闭其中一个，另外一个也会关闭)，否则就会造成大量的`Statement`对象无法释放，从而引起内存泄漏。

       

  5. **单例模式**

     -  如果单例对象持有外部对象的引用，那么这个外部对象将不能被jvm正常回收，导致内存泄露。 
     - 单例对象在被初始化后将在JVM的整个生命周期中存在(以静态变量的方式)，如果单例对象持有外部对象的引用，那么这个外部对象将不能被jvm正常回收，导致内存泄露。

     ```java
     class A{
     	public A(){
     		B.getInstance().setA(this);
     	}
     	....
     }
     
     // B类采用单例模式,持有A对象引用,A对象不能被回收
     class B{
     	private A a;
     	private static B instance=new B();
     
     	public B(){}
     
     	public static B getInstance(){
     		return instance;
     	}
     
     	public void setA(A a){
     		this.a=a;
     	}
     	//getter...
     }
     ```

     


#### 6.2内存溢出(OutOfMemoryError)

- **定义**

  是指程序在申请内存时，没有足够的内存空间供其使用，会抛出OutOfMemoryError错误。
  
- **常见原因**

  1. 内存分配过小，与实际业务需要空间不符。
  2. 对象频繁被创建，却没有被释放，导致内存泄漏。
  3. 有限系统资源(线程、网络连接)被不断的申请，导致系统资源被耗尽。

- **排查流程**

  1. 命令jps，查看java的进程。
  2. 命令jstat，查看JVM的类信息以及GC信息。
  3. 命令jmap，查看JVM的内存快照信息，会进行一次FullGC。

- **jps查看java的进程**

  用来显示系统内的Java进程

  ```shell
  # 输出jar路径和JVM参数
  jps -lv  
  ```

  

- **jstat查看JVM的类信息以及GC信息**

  | 参数      | 作用                                                         |
  | --------- | ------------------------------------------------------------ |
  | -class    | 用于查看类加载情况的统计，显示加载class的数量，及所占空间等信息。 |
  | -compiler | 查看HotSpot中即时编译器编译情况的统计                        |
  | -gc       | 查看JVM中堆的垃圾收集情况的统计，可以显示gc的信息，查看gc的次数，及时间。 |

  

- **jmap查看JVM的内存快照信息**


| 参数      | 作用                                                         |
| --------- | ------------------------------------------------------------ |
| -dump     | 生成Java堆转储快照。一般导出文件分析。                       |
| -heap     | 显示堆详细信息，比如收集器，参数配置，分代状态等。只在Linux/Solaris平台下有效。 |
| -histo    | 显示堆中对象统计信息，包括类、实例数量、合计容量。           |
| -permstat | 以ClassLoader为统计口径显示永久代内存状态。只在Linux/Solaris平台下有效。 |

  ```shell
  [root@k8s-master-1 ~]# jmap -heap 10831
  Attaching to process ID 10831, please wait...
  Debugger attached successfully.
  Server compiler detected.
  JVM version is 25.241-b07
  
  using thread-local object allocation.
  Parallel GC with 2 thread(s)
  
  Heap Configuration:
     MinHeapFreeRatio         = 0
     MaxHeapFreeRatio         = 100
     MaxHeapSize              = 1073741824 (1024.0MB)
     NewSize                  = 357564416 (341.0MB)
     MaxNewSize               = 357564416 (341.0MB)
     OldSize                  = 716177408 (683.0MB)
     NewRatio                 = 2
     SurvivorRatio            = 8
     MetaspaceSize            = 21807104 (20.796875MB)
     CompressedClassSpaceSize = 1073741824 (1024.0MB)
     MaxMetaspaceSize         = 17592186044415 MB
     G1HeapRegionSize         = 0 (0.0MB)
  
  Heap Usage:
  PS Young Generation
  Eden Space:
     capacity = 349175808 (333.0MB)
     used     = 179421816 (171.10997772216797MB)
     free     = 169753992 (161.89002227783203MB)
     51.384377694344735% used
  From Space:
     capacity = 4194304 (4.0MB)
     used     = 262144 (0.25MB)
     free     = 3932160 (3.75MB)
     6.25% used
  To Space:
     capacity = 4194304 (4.0MB)
     used     = 0 (0.0MB)
     free     = 4194304 (4.0MB)
     0.0% used
  PS Old Generation
     capacity = 716177408 (683.0MB)
     used     = 56829912 (54.197227478027344MB)
     free     = 659347496 (628.8027725219727MB)
     7.935172397954223% used
  
  31497 interned Strings occupying 3670360 bytes.
  
  ```


### 7.线程池故障

- **故障的表现**

  线程池如果被打满达到连接数的上线，就会导致后续的请求进不来，接口响应超时，并在线程池中堆积大量的任务。
  
- **故障排查**

  1. 通过jps -l找到项目的进程号, 如下是16555

     ```shell
     jps -lv
     ```

  2. 通过jstack dump线程信息,如下会将线程信息dump到一个名为thread.txt的文件中

     ```shell
     jstack 16555 > thread.txt
     ```

  3. 分析dump线程信息，找出线程池阻塞原因

     ```shell
     "http-nio-8080-exec-20" #54 daemon prio=5 os_prio=0 tid=0x00007fa468011800 nid=0x421c waiting on condition [0x00007fa4cd6ff000]
        java.lang.Thread.State: WAITING (parking)
         at sun.misc.Unsafe.park(Native Method)
         .....
     ```

  4. 分析一般排除JDK方法，结合线程信息查看

### 8.连接池泄露

- **定义**
  数据库连接池泄露就是数据库连接取了，用完了之后没有放回连接池，这样就没有可用的连接给出了。
  
- **故障的表现**

  系统开始有用户报障，发布系统线上无法构建发布，然后后续有用户不能登录系统，系统发生假死，当然系统不是真的宕机，而是所有和数据库有关的连接都被阻塞，随后查看日志发现有大量报错。

#### 8.1Druid连接池连接不释放、连接泄漏排查

- **日志报错**

  ![](https://javanote.oss-cn-shenzhen.aliyuncs.com/14_连接池泄露.png)

- **调整Druid连接池参数**

  ```xml
  <!-- 超过时间限制是否回收 -->  
  <property name="removeAbandoned" value="true" />  
  <!-- 超时时间；单位为秒。180秒=3分钟   -->
  <property name="removeAbandonedTimeout" value="180" />  
  <!-- 关闭abanded连接时输出错误日志   -->
  <property name="logAbandoned" value="true" />
  ```

- **打印日志，查看日志文件**

  1.  日志里查找`removeAbandoned`关键字，找到自己哪个方法获取连接后没有关闭资源，排查原因。 

  ![](https://javanote.oss-cn-shenzhen.aliyuncs.com/15_连接池泄露日志.png)

- **常见的泄露原因**

  1. 在事务中调用了阻塞的方法，导致事务没办法及时提交。
  2. 或者在阻塞的方法中，出现了错误。连接超时，Mysql主动关闭了连接，导致连接泄露。



###9.Mysql挂掉

#### 9.1查看MySQL执行日志

- 进入MySQL，开启日志选项(默认情况应该是关闭的)

  ```shell
  mysql> set global general_log=on;
  ```

- 查询本机MySQL执行日志保存的路径及开启情况

  ```shell
  # general_log表示开启情况，general_log_file表示日志文件地址
  mysql> show variables like '%general_log%';
  +------------------+------------------------------+
  | Variable_name    | Value                        |
  +------------------+------------------------------+
  | general_log      | OFF                          |
  | general_log_file | /var/lib/mysql/DB-Server.log |
  +------------------+------------------------------+
  ```

- 查看MySQL执行日志

  ```shell
  tail -500f /var/lib/mysql/DB-Server.log;
  ```

#### 9.2Mysql故障连接数太多

- **问题定义**

  MySQL数据库的默认最大连接数是100。但是除了我们正在使用的连接以外，还有很大一部分 Sleep 的连接 ，就会导致`too many connection`错误。

- **基本流程**

  1. 查看当前Mysql最大连接数量。
  2. 最大连接数的修改有两种方式。
  3. 杀死Sleep连接。
  4. 设置连接最大存活时间。

- **查看当前Mysql最大连接数量**

  ```shell
  # 查看当前配置的最大连接数量
  mysql> show variables like '%max_connections%';
  +-----------------+-------+
  | Variable_name   | Value |
  +-----------------+-------+
  | max_connections | 151   |
  +-----------------+-------+
  
  # 查看从这次mysql服务启动到现在，同一时刻并行连接数的最大值
  mysql> show status like 'Max_used_connections';
  +----------------------+-------+
  | Variable_name        | Value |
  +----------------------+-------+
  | Max_used_connections | 2     |
  +----------------------+-------+
  ```

- **最大连接数的修改有两种方式** 

  ```shell
  # 1.使用sql语句
  set global max_connections = 1000; 
  
  # 修改 /etc/my.cnf 添加max_connections = 1000永久有效。重启后生效
  ```

- **杀死Sleep连接**

  通过`show_processlist`命令来查看当前的所有连接状态。

  ![](https://javanote.oss-cn-shenzhen.aliyuncs.com/16_查询所有的sleep连接.png)

- **设置连接最大存活时间**

  ```shell
  # 查看sleep连接最大存活时间
  show global variables like '%wait_timeout'; 
  
  # 修改最大存活时间
  set global wait_timeout=250; 
  ```

  

### 10.Redis挂掉

