## MySQL的存储引擎

### 1.存储引擎基本介绍

1. MySQL中的数据用各种不同的技术存储在文件(或者内存)中。
2. 每一种技术都使用不同的**存储机制、索引技巧、锁定水平**并且最终提供广泛的不同的功能和能力。
3. MySQL默认配置了许多不同的存储引擎，可以预先设置或者在MySQL服务器中启用。

### 2.MyISAM

- **应用场景**
  
1. **适合多读取插入，少更新删除**
2. MyISAM**不支持事务**，**也不支持外键**，尤其是**访问速度快**，**对事务完整性没有要求**或者以SELECT、INSERT为主的应用基本都可以使用这个引擎来创建表。

- **文件结构**
  
  1. 每个MyISAM在磁盘上存储成3个文件，其中文件名和表名都相同，但是扩展名分别为：
     - .frm(存储表定义)
     - MYD(MYData，存储数据)
     - MYI(MYIndex，存储索引)
  2. 文件位置
     - 数据文件和索引文件可以放置在不同的目录，平均分配IO，获取更快的速度。
     - 要指定数据文件和索引文件的路径，需要在创建表的时候通过DATA DIRECTORY和INDEX DIRECTORY语句指定，文件路径需要使用绝对路径。
  
- **表的标志**
  
  1. 每个MyISAM表都有一个标志，服务器或myisamchk程序在检查MyISAM数据表时会对这个标志进行设置。
  2. MyISAM表还有一个标志用来表明该数据表在上次使用后是不是被正常的关闭了。
     - 如果服务器以为当机或崩溃，这个标志可以用来判断数据表是否需要检查和修复。
     - 如果想让这种检查自动进行，可以在启动服务器时使用--myisam-recover现象。这会让服务器在每次打开一个MyISAM数据表是自动检查数据表的标志并进行必要的修复处理。
  3. MyISAM类型的表可能会损坏，可以使用CHECK TABLE语句来检查MyISAM表的健康，并用REPAIR TABLE语句修复一个损坏到MyISAM表。
  
- **存储格式**
  
  1. MyISAM的表还支持3种不同的存储格式
     - 静态(固定长度)表
     - 动态表
     - 压缩表
  2. 静态表
     - 其中静态表是默认的存储格式。
     - 静态表中的字段都是非变长字段，这样每个记录都是固定长度的。这种存储方式的优点是存储非常迅速，容易缓存，出现故障容易恢复，缺点是占用的空间通常比动态表多。
     - 静态表在数据存储时会根据列定义的宽度定义补足空格，但是在访问的时候并不会得到这些空格，这些空格在返回给应用之前已经去掉。
      - 在某些情况下可能需要返回字段后的空格，而使用这种格式时后面到空格会被自动处理掉。
  3. 动态表
      - 动态表包含变长字段，记录不是固定长度的，这样存储的优点是占用空间较少。
      - 但是频繁到更新删除记录会产生碎片，需要定期执行OPTIMIZE TABLE语句或myisamchk -r命令来改善性能，并且出现故障的时候恢复相对比较困难。
  4. 压缩表
      - 压缩表由myisamchk工具创建，占据非常小的空间，因为每条记录都是被单独压缩的，所以只有非常小的访问开支。

### 3.InnoDB

- **特点**
  1. 比较慢，可以并发，具备索引，具备事务。
  2. InnoDB还引入了**行级锁定(间隙锁)**和外键约束。
  3. 一般来说，如果需要事务支持，并且有较高的并发读取频率，InnoDB是不错的选择。

- **应用场景**
  1. 更新密集的表。InnoDB存储引擎特别适合处理多重并发的更新请求。
  2. 事务。InnoDB存储引擎是支持事务的标准MySQL存储引擎。
  3. 自动灾难恢复。与其它存储引擎不同，InnoDB表能够自动从灾难中恢复。
  4. 外键约束。MySQL支持外键的存储引擎只有InnoDB。
  5. 支持自动增加列AUTO_INCREMENT属性。

### 4.MEMORY(内存表)

- **特点**
  1. 使用Memory存储引擎的出发点是速度。为得到最快的响应时间，采用的逻辑存储介质是系统内存。
  2. 在内存中存储表数据确实会提供很高的性能，但当mysql守护进程崩溃时，所有的Memory数据都会丢失。
  3. 要求存储在Memory数据表里的数据使用的是长度不变的格式，这意味着不能使用BLOB和TEXT这样的长度可变的数据类型，VARCHAR是一种长度可变的类型，但因为它在MySQL内部当做长度固定不变的CHAR类型，所以可以使用。

- **应用场景**
  1. 目标数据较小，而且被非常频繁地访问。在内存中存放数据，所以会造成内存的使用，可以通过参数max_heap_table_size控制Memory表的大小，设置此参数，就可以限制Memory表的最大大小。
  2. 如果数据是临时的，而且要求必须立即可用，那么就可以存放在内存表中。
  3. 存储在Memory表中的数据如果突然丢失，不会对应用服务产生实质的负面影响。

- **索引支持**
  1. Memory同时支持散列索引(HASH)和B树索引。
  2. B树索引的优于散列索引的是，可以使用部分查询和通配查询，也可以使用<、>和>=等操作符方便数据挖掘。
  3. 散列索引进行“相等比较”非常快，但是对“范围比较”的速度就慢多了，因此散列索引值适合使用在=和<>的操作符中，不适合在<或>操作符中，也同样不适合用在order by子句中。

### 5.MERGE

- **特点**
  1. `Merge`存储引擎是一组`MyISAM`表的组合，这些`MyISAM`表结构必须完全相同。
  2. `Merge`表就是几个相同`MyISAM`表的聚合器。`Merge`表中并没有数据，对`Merge`类型的表可以进行查询、更新、删除操作，这些操作实际上是对内部的`MyISAM`表进行操作。

- **应用场景**
  1. 对于服务器日志这种信息，一般常用的存储策略是将数据分成很多表，每个名称与特定的时间端相关。
     例如：可以用12个相同的表来存储服务器日志数据，每个表用对应各个月份的名字来命名。当有必要基于所有12个日志表的数据来生成报表，这意味着需要编写并更新多表查询，以反映这些表中的信息。与其编写这些可能出现错误的查询，不如将这些表合并起来使用一条查询，之后再删除Merge表，而不影响原来的数据，删除Merge表只是删除Merge表的定义，对内部的表没有任何影响。

### 6.ARCHIVE(归档)

- **特点**
  1. Archive是归档的意思，在归档之后很多的高级功能就不再支持了，仅仅支持最基本的插入和查询两种功能。
  2. 在MySQL 5.5版以前，Archive是不支持索引，但是在MySQL 5.5以后的版本中就开始支持索引了。
  3. Archive拥有很好的压缩机制，它使用zlib压缩库，在记录被请求时会实时压缩，所以它经常被用来当做仓库使用。

### 7.选取存储引擎的标准

![](https://javanote.oss-cn-shenzhen.aliyuncs.com/7_存储引擎对比.png)

- **基本判断标准**
  1. 是否需要支持事务。
  2. 是否需要使用热备。
  3. 崩溃恢复，能否接受崩溃。
  4. 是否需要外键支持。
- **四个主要存储引擎的区别**
  1. **MyIsam**不支持事务，不支持外键，所以访问速度快。锁机制是表锁，支持全文索引。插入数据快，空间和内存使用比较低。如果表主要是用于插入新记录和读出记录，那么选择MyISAM能实现处理高效率。如果应用的完整性、并发性要求比 较低，也可以使用。如果数据表主要用来插入和查询记录，则MyISAM引擎能提供较高的处理效率
  2. **InnoDB**支持事务、支持外键，所以对比MyISAM，InnoDB的处理效率差一些，并要占更多的磁盘空间保留数据和索引。锁机制是行锁，有间隙锁，不支持全文索引。支持事务处理，支持外键，支持崩溃修复能力和并发控制。如果需要对事务的完整性要求比较高（比如银行），要求实现并发控制（比如售票），那选择InnoDB有很大的优势。如果需要频繁的更新、删除操作的数据库，也可以选择InnoDB，因为支持事务的提交（commit）和回滚（rollback）。
  3. **Memory**数据是存放在内存中的，默认哈希索引，非常适合存储临时数据，服务器关闭后，数据会丢失掉。所有的数据都在内存中，数据的处理速度快，但是安全性不高。如果需要很快的读写速度，对数据的安全性要求较低，可以选择MEMOEY。它对表的大小有要求，不能建立太大的表。所以，这类数据库只使用在相对较小的数据库表。如果只是临时存放数据，数据量不大，并且不需要较高的数据安全性，可以选择将数据保存在内存中的Memory引擎，MySQL中使用该引擎作为临时表，存放查询的中间结果。
  4. **Archive**支持高并发的插入操作，但是本身不是事务安全的。Archive非常适合存储归档数据，如记录日志信息可以使用Archive。如果只有INSERT和SELECT操作，可以选择Archive。

