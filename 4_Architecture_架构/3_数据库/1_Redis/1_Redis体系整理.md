## Redis基础

### 1.Redis的优点

1. 传统的关系型数据库如Mysql已经不能适用所有的场景了，比如秒杀的库存扣减，APP首页的访问流量高峰等等。

2. 在很多数据库连接的情况下，容易把数据库打崩，所以引入了缓存中间件，目前市面上比较常用的缓存中间件有Redis和Memcached。

   TODO：数据库为什么会挂掉？大量的数据库连接会产生什么问题？

### 2.Redis的应用场景

1. redis 就是一个数据库，不过与传统数据库不同的是 redis 的数据是存在内存中的，所以读写速度非常快，因此 redis 被广泛应用于**缓存**方向。
2. redis也经常用来做**分布式锁**。
3. redis提供了多种数据类型来支持不同的业务场景。
4. 除此之外，redis支持事务 、持久化、LUA脚本、LRU驱动事件、多种集群方案。

### 2.数据结构以及使用场景

- **全部数据结构**
  1. 基本类型：字符串String、字典Hash、列表List、集合Set、有序集合SortedSet
  2. 新增类型：HyperLogLog、Geo、Pub/Sub

- **String**
  1. 常用命令：`set,get,decr,incr,mget` 等
  2. 数据结构：String数据结构是简单的key-value类型，value其实不仅可以是**String**，也可以是**数字**。 
  3. 应用场景
     - **缓存功能**：String字符串是最常用的数据类型，利用Redis作为缓存，配合其它数据库作为存储层，利用Redis支持高并发的特点，可以大大加快系统的读写速度、以及降低后端数据库的压力。
     - **计数器**：许多系统都会使用Redis作为系统的实时计数器，可以快速实现计数和查询的功能。而且最终的数据结果可以按照特定的时间落地到数据库或者其它存储介质当中进行永久保存。微博数，粉丝数等，
     - **共享用户Session**：用户重新刷新一次界面，可能需要访问一下数据进行重新登录，或者访问页面缓存Cookie，但是可以利用Redis将用户的Session集中管理，在这种模式只需要保证Redis的高可用，每次用户Session的更新和获取都可以快速完成。大大提高效率。
- **Hash-较少使用**
  
  1. 常用命令：`hget,hset,hgetall` 等
  2. 数据结构：hash是一个string类型的field和value的映射表，hash特别适合用于存储对象，可以直接仅仅修改这个对象中的某个字段的值。比如可以hash数据结构来存储用户信息，商品信息等等。(设置指定服务器和端口，请求转发的接口)
  3. 应用场景：暂无，比较少使用
- **List**
  1. 常用命令：`lpush,rpush,lpop,rpop,lrange`等
  2. 数据结构：RedisList的实现为一个双向链表，即可以**支持反向查找和遍历**，更方便操作，不过带来了部分额外的内存开销。可以通过lrange命令，从某个元素开始读取多少个元素，基于RedisList可以**实现简单的高性能分页**。
  3. 应用场景：比如微博的关注列表，粉丝列表，消息列表。
     - **消息队列**
       Redis的链表结构实现阻塞队列，可以使用左进右出的命令组成来完成队列的设计。比如：数据的生产者可以通过Lpush命令从左边插入数据，多个数据消费者，可以使用BRpop命令阻塞的“抢”列表尾部的数据。
     - **文章列表或者数据分页展示的应用**
       比如，我们常用的博客网站的文章列表，当用户量越来越多时，而且每一个用户都有自己的文章列表，而且当文章多时，都需要分页展示，可以考虑使用Redis的列表，列表不但有序同时还支持按照范围内获取元素，可以完美解决分页查询功能，大大提高查询效率。
- **Set**
  1. 常用命令：`sadd,spop,smembers,sunion`等
  2. 数据结构：Set对外提供的功能与list类似是一个列表的功能，可以**自动排重**。set提供了判断某个成员是否在一个set集合内的重要接口。可以基于set轻易实现交集、并集、差集的操作(**有对应的命令**)。
  3. 应用场景：实现如两个人的共同关注、共同粉丝、共同喜好等功能。
- **Sorted Set**
  1. 常用命令：`zadd,zrange,zrem,zcard`等
  
  2. 数据结构：SortedSet增加了一个权重参数score，使得集合中的元素能够按score进行有序排列。
  
  3. 应用场景：在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息。
  
     - **排行榜**
  
       有序集合经典使用场景。例如视频网站需要对用户上传的视频做排行榜，榜单维护可能是多方面，按照时间、按照播放量、按照获得的赞数等。
  
     - **做带权重的队列**
  
       比如普通消息的score为1，重要消息的score为2，然后工作线程可以选择按score的倒序来获取工作任务，让重要的任务优先执行。

### 3.Redis 和 Memcached 的区别

1. redis支持更丰富的数据类型(支持更复杂的应用场景)。Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。memcache支持简单的数据类型，String。

2. Redis支持**数据的持久化**，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而Memecache把数据全部存在内存之中。

3. **集群模式**：memcached没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 redis 目前是原生支持 cluster 模式的.

4. Memcached是多线程，非阻塞IO复用的网络模型；Redis使用单线程的多路 IO 复用模型。

   Redis使用单线程的原因，采用了非阻塞的异步事件处理机制，缓存数据都是内存操作 IO 时间不会太长，单线程可以避免线程上下文切换产生的代价。

5. **性能对比**，由于Redis只使用单核，而Memcached可以使用多核，所以平均每一个核上Redis在存储小数据时比Memcached性能更高。而在100k以上的数据中，Memcached性能要高于Redis，虽然Redis最近也在存储大数据的性能上进行优化，但是比起memcached，还是稍有逊色。

![redis 和 memcached 的区别](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-24/61603179.jpg)

### 4.Redis的线程模型

redis 内部使用**文件事件处理器** `file event handler`，这个文件事件处理器是单线程的，所以 redis 才叫做单线程的模型。采用 **IO 多路复用机制**同时监听多个 socket，根据 socket 上的事件来选择对应的事件处理器进行处理。

文件事件处理器的结构包含 4 个部分：

- 多个 socket
- IO 多路复用程序
- 文件事件分派器
- 事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）

多个 socket 可能会并发产生不同的操作，每个操作对应不同的文件事件。但是 IO 多路复用程序会监听多个 socket，会将 socket 产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。

TODO：什么是IO多路复用？

### 5.假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？

- **命令的运用**

  1. `KEYS`命令，可以扫出指定模式的key列表，是阻塞命令。

     因为Redis是单线程的。当redis正在线上运行时，`KEYS`指令会**导致线程阻塞一段时间**，线上服务会停顿，直到指令执行完毕，服务才能恢复。

  2. `SCAN`命令，用于迭代当前数据库中的数据库键，是增量式迭代命令，原理是使用游标。

     `SCAN`指令可以无阻塞的提取出指定模式的key列表，但是**会有一定的重复概率**，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。

     以 0 作为游标开始一次新的迭代， 一直调用SCAN命令， 直到命令返回游标 0 ， 我们称这个过程为一次完整遍历(`full iteration`)。

- 增量式命令的缺点

  举个例子，使用`SMEMBERS`命令可以返回集合键当前包含的所有元素，但是对于`SCAN`这类增量式迭代命令来说，因为在对键进行增量式迭代的过程中，键可能会被修改，所以增量式迭代命令只能对被返回的元素提供有限的保证。

### 6.Redis的Pipeline

- 应用背景

  Redis本身就是基于tcp的一个`Request/Response Protocol`模式，如果每一条命令都进行一次tcp请求，就会造成网络压力以及IO堵塞。

- Pipeline管道

  1. 可以将多次IO往返的时间缩减为一次，前提是pipeline执行的指令之间没有因果相关性。
  2. 使用redis-benchmark进行压测的时候可以发现影响redis的QPS峰值的一个重要因素是pipeline批次指令的数目。



## 缓存

### 1.缓存体系Redis和Memcache

![](https://javanote.oss-cn-shenzhen.aliyuncs.com/14_缓存体系架构.png)

### 2.缓存的类型

缓存的类型分为：本地缓存、分布式缓存和多级缓存。

- **本地缓存**
  1. 本地缓存就是在进程的内存中进行缓存，比如在`JVM`堆中，可以用`LRUMap`来实现，也可以使用`Ehcache`这样的工具来实现。
  2. 本地缓存是内存访问，没有远程交互开销，性能最好，但是受限于单机容量，一般缓存较小且无法扩展。
- **分布式缓存**
  1. 分布式缓存解决的问题是，部署在不同服务器的应用程序，可以共享一个缓存。
  2. 分布式缓存一般都具有良好的水平扩展能力，对较大数据量的场景也能应付自如。
  3. 缺点就是需要进行远程请求，性能不如本地缓存。
- **多级缓存**
  1. 实际业务中一般采用多级缓存，本地缓存只保存访问频率最高的部分热点数据，其他热点数据放在分布式缓存中。

### 3.Memcache实现缓存的特点

- **特点**
  1. MC处理请求时使用多线程异步IO的方式，可以合理利用CPU多核的优势，性能非常优秀。
  2. MC功能简单，使用内存存储数据。
  3. MC的内存结构以及钙化问题。
  4. MC对缓存的数据可以设置失效期，过期后的数据会被清除。
  5. 失效的策略采用延迟失效，就是当再次使用数据时检查是否失效。
  6. 当容量存满时，会对缓存中的数据进行剔除，剔除时除了会对过期key进行清理，还会按LRU策略对数据进行剔除。
- **缺点**
  1. key不能超过250个字节。
  2. value不能超过1M字节。
  3. key的最大失效时间是30天。
  4. 只支持K-V结构，不提供持久化和主从同步功能。

### 4.Redis实现缓存的优点

- **高性能**

  假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可。

- **高并发**

  直接操作缓存能够承受的请求是远远大于直接访问数据库的，可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。

  

###5.本地缓存(map/guava)和分布式缓存(redis/memcached )的区别

- 缓存分为本地缓存和分布式缓存。

  1. **本地缓存**

     使用自带的map或者guava实现的是本地缓存，最主要的特点是**轻量以及快速**，生命周期随着jvm的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，**缓存不具有一致性**。

  2. **分布式缓存**

     在多实例的情况下，各实例共用一份缓存数据，**缓存具有一致性**。缺点是需要保持redis或memcached服务的**高可用**，整个程序架构上较为复杂。

### 6.缓存过期Key的删除方式

- **Key过期时间**

  1. Redis中有个设置时间过期的功能，即对存储在 redis 数据库中的值可以设置一个过期时间。
  2. 应用场景：一般项目中的`token`或者一些登录信息，尤其是短信验证码都是有时间限制的。

- **删除过期的Key**

  1. 定期删除

     redis默认是每隔100ms就**随机抽取**一些设置了过期时间的key，检查其是否过期，如果过期就删除。

     随机抽取删除，是为了减轻CPU负载，如果是全量遍历负载就会很大。

  2. 惰性删除

     定期删除可能会导致很多过期 key 到了时间并没有被删除掉。

     比如当重新建立一个key值，系统检查key时发现过期的数据没有删除，此时就会删除过期的信息。惰性删除就是当用到的时候才会删除。

### 7.如果有大量的key需要设置同一时间过期，一般需要注意什么？

- 如果大量的key过期时间设置的过于集中，到过期的那个时间点，redis可能会出现**短暂的卡顿现象**。严重的话会出现**缓存雪崩**，一般需要在时间上加一个随机值，使得**过期时间分散**一些。
- 电商首页经常会使用定时任务刷新缓存，可能大量的数据失效时间都十分集中，如果失效时间一样，又刚好在失效的时间点大量用户涌入，就有可能造成缓存雪崩。

### 8.内存淘汰策略

- **解决的问题**

  1. 如果定期删除漏掉了很多过期 key，然后没有及时去查，也就没走惰性删除。此时如果大量过期key堆积在内存里，会导致redis内存块耗尽。
  2. 不管是本地缓存还是分布式缓存，为了保证较高性能，都是使用内存来保存数据，由于成本和内存限制，当存储的数据超过缓存容量时，需要对缓存的数据进行剔除。

- **默认的6种内存淘汰策略**

  1. **volatile-lru**：从已设置过期时间的数据集(`server.db[i].expires`)中挑选最近最少使用的数据淘汰
  2. **volatile-ttl**：从已设置过期时间的数据集(`server.db[i].expires`)中挑选将要过期的数据淘汰
  3. **volatile-random**：从已设置过期时间的数据集(`server.db[i].expires`)中任意选择数据淘汰
  4. **allkeys-lru**：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key(这个是最常用的)
  5. **allkeys-random**：从数据集(`server.db[i].dict`)中任意选择数据淘汰
  6. **no-eviction**：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。(比较少使用)

- **Redis4.0增加的2种策略**

  1. **volatile-lfu**：从已设置过期时间的数据集(`server.db[i].expires`)中挑选最不经常使用的数据淘汰
  2. **allkeys-lfu**：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的key
  
- **最常使用的三种策略**

  1. `FIFO`淘汰最早数据
  2. `LRU`剔除最近最少使用
  3. `LFU`剔除最近使用频率最低的数据

- **LRU算法**

  LinkedHashMap中实现了LRU算法 TODO

  

### 9.缓存雪崩、缓存穿透和缓存击穿

#### 6.1缓存雪崩

- **缓存雪崩定义**

  1. 缓存同一时间大面积的失效，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。

  2. 目前电商首页以及热点数据都会去做缓存 ，一般缓存都是定时任务去刷新，或者是查不到之后去更新的，定时任务刷新就有一个问题。

     如果所有首页的Key失效时间都是12小时，中午12点刷新的，我零点有个秒杀活动大量用户涌入，假设当时每秒 6000 个请求，本来缓存在可以扛住每秒 5000 个请求，但是缓存当时所有的Key都失效了。此时 1 秒 6000 个请求全部落数据库，数据库必然扛不住，它会报一下警，真实情况可能DBA都没反应过来就直接挂了。此时，如果没用什么特别的方案来处理这个故障，DBA 很着急，重启数据库，但是数据库立马又被新的流量给打死了。这就是我理解的缓存雪崩。

- **程序层面的方案**

  1. **随机key值**：可以保证数据不会在同一时间大面积过期失效。
  2. **设置热点数据永远不过期**：如果有更新操作，就更新缓存就好了。(比如运维更新了首页商品)

- **系统解决方法**

  1. 事前：保证redis集群的高可用性，发现机器宕机尽快补上。选择合适的内存淘汰策略。
  2. 事中：本地ehcache缓存+hystrix限流&降级，避免MySQL崩掉
  3. 事后：利用redis持久化机制保存的数据尽快恢复缓存

  ![](https://javanote.oss-cn-shenzhen.aliyuncs.com/7_缓存雪崩解决方法.png)

#### 6.2缓存击穿

- **缓存击穿定义**

  1. 缓存雪崩是因为大面积key的缓存失效，打崩了DB。缓存击穿是指一个Key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个Key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库。

- **解决方法**

  1. 设置热点数据永远不过期，可以保证单个key一直是访问到缓存上的。
  2. 使用随机退避方式，失效时随机 sleep 一个很短的时间，再次查询，如果失败再执行更新。
  3. 对数据库连接加上互斥锁，可以保证同时访问数据库只有一个线程，对这个key必缓存。

  ![](https://javanote.oss-cn-shenzhen.aliyuncs.com/9_互斥锁.png)

​     

#### 6.3缓存穿透

- **缓存穿透定义**

  1. 大量请求的`key`根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。例如：某个黑客故意制造我们缓存中不存在的`key`发起大量请求，导致大量请求落到数据库。
  2. 一般`MySQL`默认的最大连接数在150左右，这个可以通过`show variables like '%max_connections%';`命令来查看。最大连接数一个还只是一个指标，`cpu`，内存，磁盘，网络等无力条件都是其运行指标，这些指标都会限制其并发能力。所以，一般`3000`个并发请求就能打死大部分数据库了。

- **解决方法**

  1. **参数校验**

     一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库id不能小于0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。

  2. **IP校验**

     正常用户是不会在单秒内发起这么多次请求的，让运维对单个IP每秒访问次数超出阈值的IP都拉黑。

  3. **缓存无效key(不常用)**

     如果缓存和数据库都查不到某个 key 的数据，这就是一个无效key，可以将无效的key写入缓存，`SET key value EX 10086`。

     可以解决请求的 key 变化不频繁的情况，但是如果黑客每次构建不同的请求key，会导致redis中缓存大量无效的 key 。这种方案并不能从根本上解决此问题，如果一定要用这种方案，需要将key过期时间设置短一点。

     key的设计：`表名:列名:主键名:主键值`

  4. **布隆过滤器**

     布隆过滤器是一个特殊的数据结构，用来判断一个给定数据是否存在于海量数据中。
  
     把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端。存在的才会继续访问缓存和数据库。
  

### 10.布隆过滤器原理

- **应用场景**

  缓存穿透和海量数据去重

- **基本思想**

  当一个元素被加入集合时，通过K个散列函数将这个元素映射成一个位数组中的K个点，把它们置为1。检索时，我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了：如果这些点有任何一个0，则被检元素一定不在；如果都是1，则被检元素很可能在。

  ![](https://javanote.oss-cn-shenzhen.aliyuncs.com/10_布隆过滤器原理.png)

  

- **哈希冲突的降低**

  BloomFilter跟单哈希函数Bit-Map不同之处在于，BloomFilter使用了k个哈希函数，每个字符串跟k个bit对应。从而降低了冲突的概率。

- **具体实例**

  比如数据库的id现在有1、2、3
  就用id：1 为例子，在上图中经过三次hash之后，把三次原本值0的地方改为1。下次进来查询如果id也是1，那就把1拿去三次hash，发现跟上面的三个位置完全一样。反之如果不一样就说明不存在了。

- **缺点**

  1. **存在误判。**可能要查到的元素并没有在容器中，但是hash之后得到的k个位置上值都是1。如果bloom filter中存储的是黑名单，那么可以通过建立一个白名单来存储可能会误判的元素。
  2. **删除困难。**一个放入容器的元素映射到bit数组的k个位置上是1，删除的时候不能简单的直接置为0，可能会影响其他元素的判断。

### 11.BloomFilter实现

- **应用场景**

  1. cerberus在收集监控数据的时候, 有的系统的监控项量会很大, 需要检查一个监控项的名字是否已经被记录到db过了, 如果没有的话就需要写入db.
  2. 爬虫过滤已抓到的url就不再抓，可用bloom filter过滤
  3. 垃圾邮件过滤。如果用哈希表，每存储一亿个 email地址，就需要 1.6GB的内存(用哈希表实现的具体办法是将每一个 email地址对应成一个八字节的信息指纹，然后将这些信息指纹存入哈希表，由于哈希表的存储效率一般只有 50%，因此一个 email地址需要占用十六个字节。一亿个地址大约要 1.6GB，即十六亿字节的内存)。因此存贮几十亿个邮件地址可能需要上百 GB的内存。而Bloom Filter只需要哈希表 1/8到 1/4 的大小就能解决同样的问题。

- **guava实现**

  ```xml
  <!-- 引入依赖 -->
  <dependency>
      <groupId>com.google.guava</groupId>
      <artifactId>guava</artifactId>
      <version>23.0</version>
  </dependency>    
  ```

  ```java
  /**
   * 测试布隆过滤器(可用于redis缓存穿透)
   * 
   * @author 敖丙
   */
  public class TestBloomFilter {
  
      private static int total = 1000000;
      private static BloomFilter<Integer> bf = BloomFilter.create(Funnels.integerFunnel(), total);
  
      public static void main(String[] args) {
          // 初始化1000000条数据到过滤器中
          for (int i = 0; i < total; i++) {
              bf.put(i);
          }
  
          // 匹配已在过滤器中的值，是否有匹配不上的
          for (int i = 0; i < total; i++) {
              if (!bf.mightContain(i)) {
                  System.out.println("有坏人逃脱了~~~");
              }
          }
  
          // 匹配不在过滤器中的10000个值，有多少匹配出来
          int count = 0;
          for (int i = total; i < total + 10000; i++) {
              if (bf.mightContain(i)) {
                  count++;
              }
          }
          System.out.println("误伤的数量：" + count);
      }
  
  }
  ```

  

### 12.缓存和数据库双写时的数据一致性

- **问题背景**

  1. 缓存与数据库双存储双写，写入到缓存的是旧数据，写入到数据库的是新数据，这样会导致缓存和数据库中的数据不一致。
  2. 一般是主动更新失败，例如更新DB后，更新Redis因为网络原因请求超时，或者是异步更新失败导致。 

- **串行化请求--保证数据一致**

  1. 读请求和写请求串行化，串到一个内存队列里去。串行化可以**保证一定不会出现不一致**的情况，但是也会**导致系统的吞吐量大幅度降低**，用比正常情况下多几倍的机器去支撑线上的一个请求。
  2. 本质上，是将DB和KV作为一个整体，每次只能处理一个请求。

- **重试更新或异步更新--在一定程度保证**

  1. 服务对耗时不是特别敏感可以增加重试.
  2. 服务对耗时敏感可以通过异步补偿任务来处理失败的更新。
  3. 短期的数据不一致不会影响业务，那么只要下次更新时可以成功，能保证最终一致性就可以。

- **KV+DB读写模式--在一定程度保证**

  1. 读模式：先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。

  2. 写模式一：先更新数据库，然后再更新缓存(**一般不推荐**)

  3. 写模式二：先更新数据库，然后再删除缓存(**常用，两种模式差不多**)

     写模式三：先删除缓存，然后再更新数据库

- **更新缓存的缺点**

  1. **一个缓存关联不止一张表**

     比如可能更新了某个表的一个字段，然后其对应的缓存，是需要查询另外两个表的数据并进行运算，才能计算出缓存最新的值的。

  2. **更新缓存会造成冷数据**

     比如一个缓存涉及的表的字段，在 1 分钟内就修改了 20 次，或者是 100 次，那么缓存更新 20 次、100 次；但是这个缓存在 1 分钟内只被读取了 1 次，有大量的冷数据。造成读取次数远远小于更新次数，浪费内存。

     删除缓存后，等需要用到缓存再去计算，就不用每次都去计算缓存的最新值。

### 13.缓存更新方式

- **更新方式**
  1. **主动更新**。数据源是DB时，可以在更新完DB后就直接更新缓存。
  2. **失效更新**。当数据源是其他远程服务，可能无法及时主动感知数据变更。一般会选择对缓存数据设置失效期，也就是数据不一致的最大容忍时间。Key不存在或失效时先请求数据源获取最新数据，然后再次缓存，并更新失效期。
- **更新异常的解决**
  1. **异步更新**，就是当失效时先不清除数据，继续使用旧的数据，然后由异步线程去执行更新任务。避免了失效瞬间的空窗期。
  2. 还有一种**纯异步更新**方式，**定时对数据进行分批更新**。实际使用时可以根据业务场景选择更新方式。





## 持久化

### 1.Redis的持久化机制(在挂掉后可以进行数据恢复)

#### 1.1持久化的作用

- Redis是运行在内存中的，持久化就是将数据从内存写到硬盘中。
- 主要作用是：重启机器或机器故障之后恢复数据，进行数据备份，主从复制或从从复制
- Redis的一种持久化方式叫快照(`snapshotting,RDB`)，另一种方式是只追加文件(`append-only file,AOF`)。

#### 1.2RDB持久化(快照)

- **RDB定义**

  Redis可以通过创建快照，来获得存储在内存里面的数据在某个时间点上的副本。Redis创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本(Redis主从结构，主要用来提高Redis性能)，还可以将快照留在原地以便重启服务器的时候使用。

- **RDB原理**

  FORK和COW。fork是指redis通过创建子进程来进行RDB操作，cow指的是copy on write，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来。

- **优点**

  1. **会生成多个数据文件，每个数据文件分别都代表了某一时刻Redis里面的数据，适合做冷备**。完整的数据运维设置定时任务，定时同步到远端的服务器，比如阿里的云服务，这样一旦线上挂了，你想恢复多少分钟之前的数据，就去远端拷贝一份之前的数据就好了。
  2. **对Redis的性能影响非常小**，是因为在同步数据的时候他只是fork了一个子进程去做持久化的，而且他在数据恢复的时候速度比AOF来的快。

- **缺点**

  1. RDB都是快照文件，都是默认五分钟甚至更久的时间才会生成一次，**意味着会丢失这期间的数据**。
  2. RDB在生成数据快照的时候，**如果文件很大，客户端可能会暂停几毫秒甚至几秒**，你公司在做秒杀的时候他刚好在这个时候fork了一个子进程去生成一个大快照，就会出问题。

- **redis.conf配置文件**

  快照持久化是Redis默认采用的持久化方式，以下是RDB的配置，

  ```yml
  #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。
  save 900 1           
  
  #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。
  save 300 10          
  
  #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照。
  save 60 10000        
  ```

  

#### 1.3AOF持久化

- **AOF定义**

  1. AOF文件是一个只进行追加操作的日志文件(append only log)，与快照持久化相比，AOF持久化 的实时性更好，因此已成为主流的持久化方案。
  2. AOF机制对每条写入命令作为日志，以`append-only`的模式写入一个日志文件中，因为这个模式是只追加的方式，所以没有任何磁盘寻址的开销，所以很快，有点像`Mysql`中的`binlog`。

- **redis.conf配置文件**

  1. 开启AOF持久化后每执行一条会更改Redis中的数据的命令，Redis就会将该命令写入硬盘中的AOF文件。
  2. 为了兼顾数据和写入性能，用户可以考虑 `appendfsync everysec`选项 ，让Redis每秒同步一次`AOF`文件，Redis性能几乎没受到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。

  ```yml
  # 默认情况下Redis没有开启AOF(append only file)方式的持久化，可以通过appendonly参数开启
  appendonly yes
  
  # AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的，默认的文件名是appendonly.aof。
  dir /tmp
  
  # 三种不同的AOF持久化方式
  # 1.每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度
  appendfsync always   
  # 2.每秒钟同步一次，显示地将多个写命令同步到硬盘
  appendfsync everysec 
  # 3.让操作系统决定何时进行同步
  appendfsync no        
  ```

- **优点**
  1. RDB五分钟一次生成快照，但是**AOF是一秒一次去通过一个后台的线程fsync操作**，那最多丢这一秒的数据。
  2. AOF在对日志文件进行操作的时候是以append-only的方式去写的，只是追加的方式写数据，自然就少了很多磁盘寻址的开销了，**写入性能惊人，文件也不容易破损。**
  3. AOF的日志是通过一个叫非常可读的方式记录的，**适合做灾难性数据误删除的紧急恢复**。比如公司的实习生通过flushall清空了所有的数据，只要这个时候后台重写还没发生，你马上拷贝一份AOF日志文件，把最后一条flushall命令删了就完事了。
- **缺点**
  1. 一样的数据，AOF文件比RDB还要大。
  2. AOF开启后，Redis支持写的QPS会比RDB支持写的要低，因为要每秒都要去异步刷新一次日志

#### 1.4AOF重写

- AOF是一个不断追加操作内容的日志文件，存在大量的冗余内容。AOF重写可以产生一个新的AOF文件，这个新的AOF文件和原有的AOF文件所保存的数据库状态一样，但是去除了冗余的内容。
- AOF重写是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无须对现有AOF文件进行任何读入、分析或者写入操作。
- **执行过程**
  1. 在执行`BGREWRITEAOF`命令时，Redis服务器会维护一个`AOF`重写缓冲区，该缓冲区会在子进程创建新`AOF`文件期间，记录服务器执行的所有写命令。
  2. 当子进程完成创建新`AOF`文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新`AOF`文件的末尾，使得新旧两个`AOF`文件所保存的数据库状态一致。
  3. 最后，服务器用新的`AOF`文件替换旧的`AOF`文件，以此来完成`AOF`文件重写操作。



#### 1.5Redis 4.0 对于持久化机制的优化

- Redis4.0开始支持RDB和AOF的混合持久化(默认关闭，可以通过配置项`aof-use-rdb-preamble`开启)。
- 如果把混合持久化打开，AOF重写的时候就直接把RDB的内容写到AOF文件开头。优点是可以快速加载同时避免丢失过多的数据，缺点是AOF里面的RDB部分是压缩格式不再是AOF格式，可读性较差。



### 2.执行持久化的流程，用于主从复制

1. RDB做镜像全量持久化，AOF做增量持久化。因为RDB会耗费较长时间且不够实时，在停机的时候会导致大量丢失数据，需要AOF来配合使用。

2. 在Redis实例重启时，会**使用RDB持久化文件重新构建内存**，再**使用AOF重放近期的操作指令**来实现完整恢复重启之前的状态。RDB为一整个表全量的数据，AOF为每次操作的日志，服务器重启的时候先把表的数据倒进去，但是可能不完整，再回放一下日志，数据就完整了。

3. Redis本身机制

   AOF持久化开启且存在AOF文件时，优先加载AOF文件。AOF关闭或者AOF文件不存在时，加载RDB文件。

   加载AOF/RDB文件成功后，Redis启动成功，AOF/RDB文件存在错误时，Redis启动失败并打印错误信息。

4. 机器断电对持久化的影响

   取决于AOF日志sync属性的配置，如果不要求性能，在每条写指令时都sync一下磁盘，就不会丢失数据。但是在高性能的要求下每次都sync是不现实的，一般都使用定时sync，比如1s一次，这个时候最多就会丢失1s的数据。



## Redis事务

### 1.Redis事务的实现

1. 相关命令：`MULTI、EXEC、WATCH`等
2. 事务提供了一种将多个命令请求打包，然后一次性、按顺序地执行多个命令的机制，并且在事务执行期间，服务器不会中断事务而改去执行其他客户端的命令请求，会将事务中的所有命令都执行完毕，然后才去处理其他客户端的命令请求。
3. 在`Redis`中，事务总是具有原子性(`Atomicity`)、一致性(`Consistency`)和隔离性(`Isolation`)，并且当`Redis`运行在某种特定的持久化模式下时，事务也具有持久性(`Durability`)。
4. Redis同一个事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚。



## 分布式锁

###1. Redis 并发竞争 Key 

- **问题背景**

  多个系统同时对一个 key 进行操作，但是最后的执行顺序和期望顺序不同，导致了结果不同。

  系统A、B、C三个系统，分别去操作Redis的同一个Key，本来顺序是1，2，3是正常的，但是因为系统A网络突然抖动了一下，B，C在他前面操作了Redis，这样数据不就错了么。**就好比下单，支付，退款三个顺序变了**，你先退款，再下单，再支付，那流程就会失败，那数据不就乱了？你订单还没生成你却支付，退款了？明显走不通了，这在线上是很恐怖的事情。


- **解决方案**

  1. 某个时刻，多个系统实例都去更新某个 key。可以基于 Zookeeper 实现分布式锁。每个系统通过 Zookeeper 获取分布式锁，**确保同一时间，只能有一个系统实例在操作某个 Key，别人都不允许读和写**。

     <img src="https://javanote.oss-cn-shenzhen.aliyuncs.com/8_zookeeper实现分布式锁.png" style="zoom:50%;" />

  2. **防止写入脏数据**

     数据写入MySQL中的时候必须保存一个时间戳，从MySQL查询数据带出时间戳。每次要写入缓存之前，先判断一下当前这个Value的时间戳是否比缓存里的Value的时间戳要新。如果是那么可以写，否则就不能用旧的数据覆盖新的数据。


- **zoopkeeper分布式锁实现原理**

  1. `zookeeper`和`redis`都可以实现分布式锁。

  2. 基于zookeeper临时有序节点可以实现的分布式锁，实现原理。

     每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。

     判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。

     同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。完成业务流程后，删除对应的子节点释放锁。

     

### 2.Redis实现分布式锁

- **具体实现**

  SET命令参数

  1. `EX second`：设置键的过期时间为`second`秒。`SET keyvalue EX second`效果等同于`SETEX key second value`。
  2. `PX millisecond`：设置键的过期时间为`millisecond`毫秒。`SET keyvalue PX millisecond` 效果等同于 `PSETEX keymillisecond value`。
  3. `NX`：只在键不存在时，才对键进行设置操作。`SET key value NX`效果等同于`SETNX key value`。
  4. `XX`：只在键已经存在时，才对键进行设置操作。

  ```shell
  # SET命令,持有锁并设置过期时间,到了时间会自动释放锁
  # 如果服务器返回OK,那么这个客户端获得锁.如果服务器返回NULL,那么客户端获取锁失败,可以在稍后再重试。
  SET resource-name anystring NX EX max-lock-time
  
  # DEL命令,释放锁
  DEL resource-name
  
  # 不使用固定的字符串作为键的值，而是设置一个不可猜测(non-guessable)的长随机字符串，作为口令串(token)。
  ```

- **其他命令实现**

  1. 使用命令SETNX来争抢锁，抢到之后，再用命令EXPIRE给锁加一个过期时间防止锁忘记了释放。
  2. 缺点是，使用两个命令不具备原子性。可以使用SET命令来争抢锁并设置过期时间。





## 异步队列

### 1.Redis实现异步队列

- **LIST列表实现**

  1. 一般使用LIST结构作为队列，LPUSH命令生产消息，RPOP命令消费消息。当lpop没有消息的时候，要适当sleep一会再重试。
  2. 如果不使用slepp方法，使用命令BRPOP，在没有消息的时候，会阻塞住直到消息到来。
  3. 这种方式是，**生成一次消费一次**。

  ```shell
  # LPUSH命令：将一个或多个值value,插入到列表key的左边.
  # RPOP命令：移除并返回列表key的右边的元素.
  # LPUSH和RPOP命令可以实现先进先出的异步队列,RPUSH和LPOP命令结合也可以实现.
  LPRUSH SYCN 1 2 3 4  # 入队
  RPOP SYCN  # 移除1,出队
  
  
  # BLPOP命令：LPOP命令的阻塞版本，当给定列表内没有任何元素可供弹出的时候，连接将被BLPOP命令阻塞，直到等待超时
  #           或发现可弹出元素为止.
  # BRPOP命令：RPOP命令的阻塞版本.
  ```

- **发布/订阅实现**

  1. Redis发布订阅(`pub/sub`)是一种消息通信模式，发送者(`pub`)发送消息，订阅者(`sub`)接收消息。
  2. Redis客户端可以订阅任意数量的频道。发送者消息可以直接发送到频道，订阅者需要订阅频道才能收到消息。
  3. 发布订阅，可以实现**生产者 1:N 消费者**。

  ```shell
  # 订阅者订阅频道,如果频道不存在会自动创建
  SUBSCRIBE redischat #订阅redischat频道
  
  # 发送者发布消息
  PUBLIS redischat "hello world"
  ```

  

- **SortedSet实现延时队列**

  1. 延时队列就是带有时间的队列，比如订单持续一小时后取消。
  2. 使用`SORTEDSET`，拿时间戳作为score，消息内容作为key调用zadd来生产消息，消费者用zrangebyscore指令获取N秒之前的数据，轮询进行处理。

  ```shell
  # ZADD命令：将一个或多个member元素及其score值加入到有序集key当中.
  ZADD lazyqueue 1 google
  ZADD lazyqueue 2 baidu
  
  # ZRANGEBYSCORE命令：返回有序集key中，所有score值介于min和max之间(包括等于min或max)的成员。
  #                    有序集成员按score值递增(从小到大)次序排列。
  ZRANGEBYSCORE lazyqueue (1 5 #返回score值 1<score<=5 之间的元素
  
  # ZREM命令：移除有序集key中的一个或多个成员，不存在的成员将被忽略。
  ```



## 高可用集群

### 1.Redis集群高可用性的保证，集群的原理

- `RedisSentinal`(哨兵)着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。
- `RedisCluster`(集群)着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。

### 2.集群的部署

1. 集群的部署方式也就是Redis  cluster，并且是主从同步读写分离，类似Mysql的主从同步，Redis cluster支撑N个Redis masternode，每个masternode都可以挂载多个slavenode。
2. Redis横向扩容。如果要支撑更大数据量的缓存，那就横向扩容更多的master节点，每个master节点就能存放更多的数据了。

### 3.Redis的主从同步和从从同步

![](https://javanote.oss-cn-shenzhen.aliyuncs.com/11_主从同步.png)

1. 启动一台slave的时候，会发送一个**psync**命令给master 。
2. 如果是这个slave第一次连接到master，master会触发一个全量复制。主节点做一次**bgsave**，并同时将后续修改操作记录到内存buffer。
3. RDB文件生成后，master会将这个RDB发送给slave的，slave拿到之后做的第一件事情就是写进本地的磁盘，然后加载进内存
4. 加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。后续的**增量数据通过AOF日志同步**即可，有点类似数据库的binlog。
5. 传输过程中有什么网络问题啥的，会自动重连的，并且连接之后会把缺少的数据补上的。

###4.主从复制的步骤

- 主从复制的开启，完全是**在从节点发起**的，**不需要在主节点做任何事情**。

- 开启主从复制的3种方式

  1.  配置文件： 在从服务器的配置文件中加入 `slaveof <masterip> <masterport>` 

  2.  启动命令： `redis-server` 启动命令后加入 `--slaveof <masterip> <masterport>` 

  3.  客户端命令： Redis服务器启动后，直接通过客户端执行命令：`slaveof <masterip> <masterport>`，则该Redis实例成为从节点。 

     ```shell
     # 本实例的端口为6389,主节点端口为6388
     slaveof 127.0.0.1:6388
     
     # 断开复制
     slaveof no one
     ```

### 5.哨兵集群Sentinel

- 哨兵的主要功能

  1. 集群监控：负责监控Redismaster和slave进程是否正常工作。
  2. 消息通知：如果某个Redis实例有故障，那么哨兵负责发送消息作为报警通知给管理员。
  3. 故障转移：如果masternode挂掉了，会自动转移到slavenode上。
  4. 配置中心：如果故障转移发生了，通知client客户端新的master地址。

- 双哨兵集群的缺点

  ![](https://javanote.oss-cn-shenzhen.aliyuncs.com/13_双哨兵.png)

  1. master宕机了，S1和S2两个哨兵只要有一个认为你宕机了就切换了，并且会选举出一个哨兵去执行故障，但是这个时候也需要大多数哨兵都是运行的。
  2. 但是M1宕机了，S1没挂那其实是OK的。如果整个机器都挂了，哨兵就只剩下S2，没有哨兵去允许故障转移了。虽然另外一个机器上还有R1，但是故障转移就是不执行。

- 经典三哨兵集群

  ![](https://javanote.oss-cn-shenzhen.aliyuncs.com/12_三哨兵.png)

  1. 哨兵必须用三个实例去保证健壮性，哨兵+主从并**不能保证数据不丢失**，但是可以保证集群的**高可用**。

  2. M1所在的机器挂了，哨兵还有两个，两个人一看他不是挂了嘛，那我们就选举一个出来执行故障转移不就好了。

     

  

## Spirngboot整合Redis

### 1.Jedis和Lettuce

### 2.redis中的pipeline





## 其他问题

- 0、在集群模式下，Redis 的 Key 是如何寻址的？分布式寻址都有哪些算法？了解一致性 Hash 算法吗？
- 1、使用Redis有哪些好处？
- 2、Redis相比Memcached有哪些优势？
- 3、Redis常见性能问题和解决方案
- 4、MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据？
- 5、Memcache与Redis的区别都有哪些？
- 6、Redis 常见的性能问题都有哪些？如何解决？
- 7、在什么样的场景下可以充分的利用Redis的特性，大大提高Redis的效率？
- 8、Redis的缓存雪崩、穿透、击穿了解么？有什么异同点？分别怎么解决？
- 9、Redis的基本类型有哪些？他们的使用场景了解么？比较高级的用法你使用过么？
- 10、Redis主从怎么同步数据的？集群的高可用怎么保证？持久化机制了解么？
- 11、为什么 redis 单线程却能支撑高并发？
- 12、如何保证缓存和数据库数据的一致性？
- 13、项目中是怎么用缓存的，用了缓存之后会带来什么问题？




## 相关书籍

- Redis中文官网
- 《Redis入门指南(第2版)》
- 《Redis实战》
- 《Redis设计与实现》
- 《大型网站技术架构——李智慧》
- 《Redis 设计与实现——黄健宏》
- 《Redis 深度历险——钱文品》
- 《亿级流量网站架构核心技术——张开涛》
- 《中华石杉——石杉》