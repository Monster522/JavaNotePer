## 秒杀系统

### 1.场景

- 10万人同时请求，秒杀100件商品。

### 2.问题

#### 2.1高并发

- 定义
  1. 大量的请求访问后台应用。
  2. 对于Tomcat，线程不够大会造成堵塞。
  3. 对于缓存，造成缓存雪崩、击穿、穿透。单机Redis的QPS差不多是3-4w
  4. 对于DB，连接池不够大会造成堵塞，连接过多会打挂DB。

#### 2.2超卖

- 定义
  1. 本来只能卖100个，结果卖了200个。
  2. 线程安全问题，造成超卖。

#### 2.3恶意请求

- 定义
  1. 会有黄牛恶意脚本请求，造成请求过多。

#### 2.4链接暴露

- 定义
  1. 接口的url暴露在前端页面中，或者开发内鬼自己请求访问。

#### 2.5数据库挂掉

- 定义
  1. 每秒上万甚至十几万的QPS(每秒请求数)直接打到数据库，基本上都要把库打挂掉。而且服务不单单是做秒杀的还涉及其他的业务，没做降级、限流、熔断啥的，别的一起挂，小公司的话可能全站崩溃404。



### 3.设计方案

#### 3.1服务单一职责

- **解决的问题**
  1. 高并发。专门的逻辑处理以及场景处理，可以抗住高并发。
  2. 数据库缓存挂掉产生的连锁反应。如果只有秒杀挂掉，可以将秒杀的影响降低到最小范围，不会影响到其他库。
- **具体实现**
  1. 秒杀单体应用，把秒杀的代码业务逻辑放一起。
  2. 单独建库，将秒杀需要的数据冗余到秒杀库，等活动进行完之后再将数据同步到其他库。

#### 3.2秒杀链接加盐

- **解决的问题**
  1. 链接暴露。
- **具体实现**
  1. 在进行秒杀之前，先请求一个服务端地址，/getmiaoshaPath这个地址，用来获取秒杀地址，传参为商品id，在服务端生成随机数(MD5)作为pathId存入缓存，(缓存过期时间60s)，然后将这个随机数返回给前端。
  2. 获得该pathid，后前端在用这个pathid拼接在Url上作为参数，去请求秒杀服务。
  3. 后端接收到这个pathid参数，并且与缓存中的pathid比较。

#### 3.3Redis集群

- **解决的问题**
  1. 高并发导致的缓存挂掉。
- **具体实现**
  1. redis集群，主从同步，读写分离，哨兵，持久化，形成一个高可用的Redis。

#### 3.4Nginx

- **解决的问题**
  1. 高并发导致的Tomcat挂掉或堵塞。
  2. 恶意请求。
- **具体实现**
  1. Nginx是**高性能的web服务器**，并发可以顶几万。Tomcat只能顶几百的并发。临时租用流量机器，通过Nginx做负载均衡和反向代理。
  2. Nginx可以拦截掉恶意请求，比如同一个IP的大量请求。

#### 3.5资源静态化

- **解决的问题**
  1. 高并发导致前端服务器挂掉
- **具体实现**
  1. 提前将静态资源放入CDN服务器，分流请求。

#### 3.6按钮控制

- **解决的问题**
  1. 高并发导致服务器挂掉。在时间快到的最后几秒秒疯狂请求服务器，然后还没到秒杀基本上服务器就挂了。
- **具体实现**
  1. 前端将按钮设置成灰色。

#### 3.7限流

- **解决的问题**
  1. 高并发导致的前端服务器，应用服务器，Tomcat的压力。
- **具体实现**
  1. 前端限流。一般秒杀不会让你一直点的，一般都是点击一下或者两下然后几秒之后才可以继续点击，这也是保护服务器的一种手段。
  2. 后端限流。库存为空及时返回false，清理无效请求。真正的限流还会有限流组件的加入，例如阿里的Sentinel、Hystrix等

#### 3.8库存预热

- **解决的问题**
  1. 数据库连接太多导致挂掉。秒杀的本质就是对库存的抢夺，每个秒杀的用户来你都去数据库查询库存校验库存，然后扣减库存，撇开性能因数，对业务开发人员都不友好，而且数据库顶不住啊。
  2. 超卖。Redis会有太多的请求访问，导致的线程安全问题。
- **具体实现**
  1. 开始秒杀前你通过定时任务或者运维同学**提前把商品的库存加载到Redis中**去，让整个流程都在Redis里面去做，然后等秒杀介绍了，再异步的去修改库存就好了。
  2. **Lua脚本是类似Redis事务，有一定的原子性，不会被其他命令插队，可以完成一些Redis事务性的操作。**

#### 3.9限流&降级&熔断&隔离

- **解决的问题**
  1. 高并发导致的各种崩溃问题。
- **具体实现**
  1. 限流，顶不住就挡一部分出去但是不能说不行。
  2. 降级，降级了还是被打挂了。
  3. 熔断，至少不要影响别的系统。
  4. 隔离，本身是独立的，但是会调用其他的系统，不要连累到其他应用。

#### 3.10削峰填谷

- **解决的问题**
  1. 高并发，减少并发的请求数量。
  2. 数据连接请求太多，会导致数据库挂掉。
- **具体实现**
  1. 对于下单成功的请求，可以先把修改库存订单状态的调用，先放到MQ中，然后再一个一个调用修改。



### 4.请求的流程

![](https://javanote.oss-cn-shenzhen.aliyuncs.com/15_秒杀系统流程.png)