## 熔断中心Hystrix

### 1.服务雪崩效应

#### 1.1基本定义

![](https://javanote.oss-cn-shenzhen.aliyuncs.com/9_雪崩效应.png)

- 服务雪崩效应是一种因服务提供者的不可用导致服务调用者的不可用，并将不可用逐渐放大的过程。
- 上图中，A为服务提供者，B为A的服务调用者，C和D是B的服务调用者。当A的不可用，引起B的不可用，并将不可用逐渐放大C和D时，服务雪崩就形成了。

#### 1.2形成的原因

- 服务雪崩产生的过程分为以下三个阶段

  1. 服务提供者不可用

  2. 重试加大流量

  3. 服务调用者不可用

     

- **服务提供者不可用**

  1. 硬件故障，可能为硬件损坏造成的服务器主机宕机，网络硬件故障造成的服务提供者的不可访问 

  2. 程序Bug

  3. **缓存击穿**，一般发生在缓存应用重启，所有缓存被清空时，以及短时间内大量缓存失效时。大量的缓存不命中，使请求直击后端，造成服务提供者超负荷运行，引起服务不可用。 

  4. **用户大量请求**，在秒杀和大促开始前，如果准备不充分，用户发起大量请求也会造成服务提供者的不可用。

     

- **重试加大流量**

  1. 用户重试，在服务提供者不可用后，用户由于忍受不了界面上长时间的等待，而不断刷新页面甚至提交表单。

  2. 代码逻辑重试，服务调用端的会存在大量服务异常后的重试逻辑。

     

- **服务调用者不可用**

  1. 同步等待造成的资源耗尽，当服务调用者使用同步调用时，会产生大量的等待线程占用系统资源。一旦线程资源被耗尽，服务调用者提供的服务也将处于不可用状态，于是服务雪崩效应产生了。

#### 1.3应对策略

- **流量控制**
  1. 网关限流，因为`Nginx`的高性能，目前一线互联网公司大量采用`Nginx+Lua`的网关进行流量控制。
  2. 用户交互限流，用户交互限流的具体措施有，采用加载动画提高用户的忍耐等待时间，或者提交按钮添加强制等待时间机制。
  3. 关闭重试
- **改进缓存模式**
  1. 缓存预加载
  2. 同步改为异步刷新
- **服务自动扩容**
  1. AWS 的 auto scaling 
- **服务调用者降级服务**
  1. 资源隔离，主要是对调用服务的线程池进行隔离。
  2. 对依赖服务进行分类，根据具体业务，将依赖服务分为强依赖和若依赖。强依赖服务不可用会导致当前业务中止，而弱依赖服务的不可用不会导致当前业务的中止。
  3. 不可用服务的调用快速失败，一般通过`超时机制` , `熔断器`和`熔断后的降级方法`来实现。

### 2.使用 Hystrix 预防服务雪崩

####2.1服务降级(Fallback)

- 对于查询操作，可以实现一个`fallback`方法，当请求后端服务出现异常的时候，可以使用`fallback`方法返回的值。`fallback`方法的返回值一般是设置的默认值或者来自缓存。

#### 2.2资源隔离-服务调用者

- **线程池来实现资源隔离**

  1. 通常在使用的时候，根据调用的远程服务划分出多个线程池。例如调用产品服务的`Command`放入A线程池，调用账户服务的`Command`放入B线程池。
  2. 这样将运行环境隔离开，就算调用服务的代码存在`bug`或者由于其他原因导致自己所在线程池被耗尽时，不会对系统的其他服务造成影响。
- **优点**

  1. 应用自身得到完全的保护，不会受不可控的依赖服务影响。即便给依赖服务分配的线程池被填满，也不会影响应用自身的额其余部分。
  2. 可以有效的降低接入新服务的风险。如果新服务接入后运行不稳定或存在问题，完全不会影响到应用其他的请求。
  3. 当依赖的服务从失效恢复正常后，其线程池会被清理并且能够马上恢复健康的服务，相比之下容器级别的清理恢复速度要慢得多。
  4. 当依赖的服务出现配置错误的时候，线程池会快速的反应出此问题(通过失败次数、延迟、超时、拒绝等指标的增加情况)。同时可以在不影响应用功能的情况下,通过实时的动态属性刷新来处理。
  5. 当依赖的服务因实现机制调整等原因造成其性能出现很大变化的时候，此时线程池的监控指标信息会反映出这样的变化。同时也可以通过实时动态刷新自身应用对依赖服务的阈值，进行调整以适应依赖方的改变。
  6. 每个专有线程池都提供了内置的并发实现，可以利用它为同步的依赖服务构建异步的访问。
- **使用线程池对于系统的负载和开销**
1. 在99%的情况下，使用线程池隔离的延迟有9ms，对于大多数需求来说这样的消耗是微乎其微的，更何况为系统在稳定性和灵活性上所带来的巨大提升。
  2. Hystrix也可以通过信号量机制，来解决延迟开销的问题。
  
- **信号量**
  1. `Hystrix`中除了使用线程池之外，还可以使用信号量来控制单个依赖服务的并发度，信号量的开销要远比线程池的开销小得多，但是它不能设置超时和实现异步访问。只有在依赖服务是足够可靠的情况下才使用信号量。
  2. 信号量的默认值为10，也可以通过动态刷新配置的方式来控制并发线程的数量。对于信号量大小的估算方法与线程池并发度的估算类似。仅访问内存数据的请求一般耗时在`1ms`以内，性能可以达到`5000rps`，这样级别的请求可以将信号量设置为1或者2。



#### 2.3断路器模式

- **基本定义**

  1. 在分布式架构中，断路器模式的作用也是类似的，当某个服务单元发生故障(类似用电器发生短路)之后，通过断路器的故障监控(类似熔断保险丝)，直接切断原来的主逻辑调用。

- **工作流程**

  ![](https://javanote.oss-cn-shenzhen.aliyuncs.com/12_熔断器工作流程.png)

  1. 当`HystrixCommand`请求后端服务失败数量超过一定阈值，断路器会切换到开路状态(Open)。这时所有请求会直接失败而不会发送到后端服务。
  2. 断路器保持在开路状态一段时间后(默认5秒)，自动切换到半开路状态(HALF-OPEN)。
  3. 这时会判断下一次请求的返回情况，如果请求成功，断路器切回闭路状态(CLOSED)，否则重新切换到开路状态(OPEN)。

- **切换到开路的阈值**

  这个阈值涉及到三个重要参数：快照时间窗、请求总数下限、错误百分比下限。这个参数的作用分别是：
    1. 快照时间窗：断路器确定是否打开需要统计一些请求和错误数据，而统计的时间范围就是快照时间窗，默认为最近的10秒。
    2. 请求总数下限：在快照时间窗内，必须满足请求总数下限才有资格进行熔断。默认为20，意味着在10秒内，如果该HystrixCommand的调用此时不足20次，即时所有的请求都超时或其他原因失败，断路器都不会打开。
    3. 错误百分比下限：当请求总数在快照时间窗内超过了下限，比如发生了30次调用，如果在这30次调用中，有16次发生了超时异常，也就是超过50%的错误百分比，在默认设定50%下限情况下，这时候就会将断路器打开。

### 3.Feign整合Hystrix

- **配置文件**

  1. 因为Feign中已经依赖了Hystrix所以在maven配置上不用做任何改动。

  ```yml
  spring:
    application:
      name: eureka-consumer-feign-hystrix
  eureka:
    client:
      service-url:
        defaultZone: http://localhost:7000/eureka/
  server:
    port: 9003
  feign:
    hystrix:
      # 开启hystrix
      enabled: true
  ```

- **创建回调类**

  ```java
  @Component
  public class HelloRemoteHystrix implements HelloRemote {
  
      // 回调方法和调用方法,名称保持一致
      @Override
      public String hello(@RequestParam(value = "name") String name) {
          return "Hello World!";
      }
  
  }
  ```

  

- **添加 fallback 属性**

  ```java
  // 在HelloRemote类添加指定fallback类，在服务熔断的时候返回fallback类中的内容。
  @FeignClient(name = "eureka-producer", fallback = HelloRemoteHystrix.class)
  public interface HelloRemote {
  
      @GetMapping("/hello/")
      String hello(@RequestParam(value = "name") String name);
  
  }
  ```

  