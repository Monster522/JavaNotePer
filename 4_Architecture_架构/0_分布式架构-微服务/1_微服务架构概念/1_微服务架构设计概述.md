## 微服务设计概述

### 1.微服务和分布式架构

#### 1.1分布式系统和集中式系统

- **集中式系统**

  指由一台或多台主计算机组成中心节点，数据集中存储于这个中心节点中，并且整个系统的所有业务单元都集中部署在这个中心节点上，系统的所有功能均由其集中处理。

  优点是：部署结构非常简单，不用考虑各节点之间的分布式协作问题。

  缺点是：采用单机部署，很可能带来系统大而复杂、难于维护、发生单点故障(一个点故障波及到全系统)、扩展性差等问题。

- **分布式系统**

  指一个硬件或软件组件分布在不同的网络计算机上，彼此之间仅仅通过消息传递进行通信和协调的系统。一群独立计算机集合共同对外提供服务，但是对于系统的用户来说，就像是一台计算机在提供服务一样。

  优点是：可以组成分布式集群对外提供服务，计算机越多，CPU、内存、存储资源等也就越多，能够处理的并发访问量也就越大。 

  缺点是 

  1. **通信异常**

     分布式系统需要在各个节点之间进行网络通信，网络通信都会伴随着网络不可用或是系统不可用的风险。延时也会远大于单机操作，会影响消息的收发的过程，因此消息丢失和消息延迟变得非常普遍。 

  2. **网络分区 - 脑裂**

     指当网络由于发生异常情况，导致分布式系统中部分节点之间的网络延时不断增大，最终导致组成分布式系统的所有节点中，只有部分节点之间能够进行正常通信，而另一些节点则不能。

     当网络分区出现时，分布式系统会出现局部小集群，在极端情况下，这些局部小集群会独立完成原本需要整个分布式才能完成的功能，这就对分布式一致性提出类非常大的挑战。 

  3. **三态**

     分布式系统的每一次请求与响应，存在特有的“三态”概念，即成功、失败与超时。当出现超时现象时，网络通信的发起方是无法确定当前请求是否被成功处理的。

  4. **节点故障**                            

     节点故障则是分布式环境下另一个比较常见的问题，指的是组成分布式系统的服务器节点出现的宕机或“僵死”现象。


#### 1.2微服务和分布式架构的关系

- 微服务是一种分布式系统架构
  1. 将业务切分为更加细粒度的服务，并使每个服务的责任单一且可独立部署。
  2. 服务内部高内聚，隐含内部细节，服务之间低耦合，彼此相互隔离。
  3. 面向服务的业务领域来建模，对外提供统一的API接口。



### 2.微服务架构出现的背景

#### 2.1传统应用架构的问题

![](https://javanote.oss-cn-shenzhen.aliyuncs.com/1_传统应用架构水平扩展.png)

当传统应用出现并发量大问题时，通常采用反向代理达到负载均衡，可以达到不断水平扩展。

- 系统资源浪费

  如上图，ModuleA和ModuleB占用系统资源20%，ModuleC占用系统资源80%。当进行水平扩展时，将三个模块都进行了负载均衡。然而ModuleA和ModuleB并没有必要，这就造成了系统资源的浪费。

- 部署效率太低

  ModuleA、ModuleB和ModuleC三个模块都部署在一个应用当中，造成如果只修改了一个模块就要部署整个应用。部署整个应用所消耗的时间与对系统带来的性能开销都是非常多的。

- 技术选型单一

  对于JavaWeb而言，整个应用只能使用Java语言单一，没办法使用其他语言进行扩展。

### 3.微服务架构概念

#### 3.1达到微服务架构的基本要求

- **根据业务模块划分服务种类**

  根据业务划分是垂直划分，根据代码划分是水平划分。

- **每个服务可独立部署且相互隔离**

  服务之间是没有任何干扰的，可将每个服务放入独立的进程中运行，因为进程之间是完全隔离的。

- **通过轻量级API调用服务**

  可通过基于HTTP或自定义协议的方式来调用，两者都可达到RPC的作用，降低调用所产生的性能开销。

- **服务需保证良好的高可用性**

  不能长时间无法响应，在某个服务岀现故障时，可以自动调用其中一个正常工作的服务。

#### 3.2交付流程

- **设计开发阶段**

  架构师将产品功能拆分为若干服务，为每个服务设计API接口。前端和后端并行开发，通过接口进行联调。

- **测试阶段**

  前后端工程师分别将自己的代码部署到测试环境上，测试工程师将针对测试用例进行手工或自动化测试，随后产品经理将从产品功能上进行验收。

- **部署阶段**

  运维工程师将代码部署到预发环境中，测试工程师再次进行一些冒烟测试，当不再发现任何问题时，经技术经理确认，运维工程师将代码部署到生产环境中，这一系列的部署过程都需要做到自动化，才能提高工作效率。

#### 3.3开发规范-Git管理代码

- 最稳定的代码放在master分支，只能在该分支上进行代码合并操作。
- 日常开发中的代码需要从master分支上拉一条develop分支出来，开发的时候自己新建本地分支，再合并到开发分支中。
- 需要开发某个特性时，需要从develop分支上拉岀一条feature分支，例如feature-1 与feature-2,在这些分支上并行地开发具体特性。
- 发布某个版本，从develop分支上拉出一条release分支，例如release-1.0.0,并将需要发布的特性从相关feature分支一同合并到release分支上，随后针对release分支部署测试环境。待上线完成后将release分支上的代码同时合并到develop分支与master分支上，并在master分支上打一个tag,例女口v1.0.0
- 在生产环境中发现bug时，从对应的tag上（例如v1.0.0）拉出一条hotfix分支（例如hotfix-1.0.1）,并在该分支上进行bug修复。
- 对于版本号我们也有要求，格式为：x.y.z,其中，x用于有重大重构时才会升级，y用于有新的特性发布时才会升级，z用于修改了某个bug后才会升级。

### 4.微服务架构特点和挑战

####4.1特点

- **微小度颗粒**

  微服务的粒度是根据业务功能来划分的。对于某些复杂的业务来说，可能粒度较大，对于相对简单的业务而言，可能粒度较小。

- **责任单一性**

  确保每个微服务只做一件事，确保每个API必须做到责任单一性。

- **运行隔离性**

  每个服务运行在自己的进程中。进程之间是隔离的，是安全的，而进程内部或线程之间的资源是共享的。一个服务出了问题，不会影响到其他微服务。

- **管理自动化**

  对服务提供自动化部署与监控预警的能力，这样才能更加高效地管理这些服务。

#### 4.2挑战

- **运维要求较高**

  除了需要使用自动化技术来部署微服务，还需要对整个微服务系统进行有效的监控，并保障系统的高可用性。

- **分布式复杂性**

  微服务架构的本质还是一个分布式架构，每个服务可以部署在任意的机器上。对于分布式系统而言，存在网络延迟、系统容错、分布式事务等问题。

- **部署依赖较强**

  对于业务复杂的情况，可能存在多个服务来共同完成一件事情，服务之间虽然没有相互调用，但可能会有调用的顺序性要求。业务上的依赖性导致了部署的依赖性，从而在某一时间点, 同一微服务可能具备多个版本。

- **通信成本较高**

  从客户端调用微服务，需要跨进程间进行调用，而进程间的调用一定比进程内的调用更加消耗资源，从而带来通信成本上的开销。

### 5.搭建微服务架构

#### 5.1微服务架构工作流程

![](https://javanote.oss-cn-shenzhen.aliyuncs.com/2_微服务架构图.png)

- 工作流程
  1. 底层部署了一系列的Service,每个Service可能有单独的DB,或者多个Service公用一个DB,且同一个Service可部署多个。
  2. 当Service启动时，会自动将其信息(服务IP和端口)，注册到ServiceRegistry(服务注册中心)中。
  3. 当客户端上发出请求时，该请求会发送到ServiceGateway(服务网关)中，ServiceGateway读取请求数据。
  4. 然后从ServiceRegistry中获取对应Service的信息(IP与端口)，最后ServiceGateway主动去调用下面对应的Service。
  5. 其中`ServiceRegistry`与`ServiceGateway`担当了重要的角色。
- 网关`ServiceGateway`和注册中心`ServiceRegistry`
  1. `ServiceGateway`将成为一个中心，可能会造成单点故障，需要将网关做的越简单越稳定。
  2. `ServiceRegistry`要求具备高可用性，在每个Service启动时提供`服务注册`，还需要在`ServiceGateway`处理每个请求时提供`服务发现`。



#### 5.2微服务技术选型

![](https://javanote.oss-cn-shenzhen.aliyuncs.com/3_技术选型.png)

- 架构构建技术
  1. 使用`Jenkins`部署服务
  2. 使用`SpringBoot`开发服务
  3. 使用`Docker`封装服务
  4. 使用`ZooKeeper`注册服务
  5. 使用`Node.js`调用服务