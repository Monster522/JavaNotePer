## Mysql的锁机制

### 1.锁机制的介绍及分类

- **基本介绍**
  1. 数据库管理系统(DBMS)中的并发控制的任务是，确保在多个事务同时存取数据库中同一数据时，不破坏事务的隔离性和统一性以及数据库的统一性。
  2. 封锁、时间戳、乐观并发控制(乐观锁)和悲观并发控制(悲观锁)是并发控制主要采用的技术手段。
- **锁的分类**
  1. 按操作划分，可分为**DML锁**(数据锁用来保证数据完整性)、**DDL锁**(数据字典锁用来保护数据库对象的结构)。
  2. 按锁的粒度划分，可分为**行级锁、页级锁(mysql)、表级锁**。
  3. 按锁级别划分，可分为**共享锁、排他锁**。
  4. 按加锁方式划分，可分为**自动锁、显示锁**。
  5. 按使用方式划分，可分为**乐观锁、悲观锁**。

### 2.锁的粒度(行级/页级/表级)

#### 2.1行级锁

- **定义**
  1. 行级锁是Mysql中**锁定粒度最细**的一种锁，表示**只针对当前操作的行进行加锁**。
  2. 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。
  3. 行级锁分为共享锁和排他锁。

- **特点**
  1. 开销大，加锁慢。
  2. **会出现死锁**。
  3. 锁定粒度最小，发生锁冲突的概率最低，并发度也最高。

#### 2.2页级锁

- **定义**
  1. 页级锁是MySQL中**锁定粒度介于行级锁和表级锁中间的一种锁**。
  2. 表级锁速度快，但冲突多，行级冲突少，但速度慢。
  3. **页级一次锁定相邻的一组记录**，BDB支持页级锁。

- **特点**
  1. 开销和加锁时间界于表锁和行锁之间。
  2. **会出现死锁**。
  3. 锁定粒度界于表锁和行锁之间，并发度一般。


#### 2.3表级锁(无死锁)

- **定义**
  1. 表级锁是**MySQL中锁定粒度最大的一种锁**，表示**对当前操作的整张表加锁**。
  2. 实现简单，资源消耗较少，被大部分MySQL引擎支持。
  3. 最常使用的`MYISAM`与`InnoDB`都支持表级锁定。
  4. 表级锁定分为表共享读锁(共享锁)与表独占写锁(排他锁)。

- **特点**
  1. 开销小，加锁快。
  2. **不会出现死锁**。
  3. 锁定粒度大，发出锁冲突的概率最高，并发度最低。

### 3.MySQL常用存储引擎的锁机制

- **存储引擎支持的锁**
  1. MyISAM和MEMORY采用表级锁(`table-level locking`)。
  2. BDB采用页面锁(`page-level locking`)或表级锁，默认为页面锁。
  3. InnoDB支持行级锁(`row-level locking`)和表级锁，默认为行级锁。

- **Innodb中的行锁与表锁**
  1. InnoDB行锁是通过给索引上的索引项加锁来实现的。Oracle是通过在数据块中对相应数据行加锁来实现的。
  2. **InnoDB只有通过索引条件检索数据，InnoDB才使用行级锁，否则InnoDB将使用表锁。**
  3. 行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁。
  4. 行级锁的缺点是，由于需要**请求大量的锁资源**，所以速度慢，内存消耗大。

- **行级锁和死锁**
  1. **MyISAM中是不会产生死锁的**，因为MyISAM总是一次性获得所需的全部锁，要么全部满足，要么全部等待。而在**InnoDB中**，锁是逐步获得的，就造成了**死锁的可能**。
  2. 在MySQL中，行级锁并不是直接锁记录，而是锁索引。
  3. **索引分为主键索引和非主键索引两种**，如果一条sql语句操作了主键索引，MySQL就会锁定这条主键索引。如果一条语句操作了非主键索引，MySQL会先锁定该非主键索引，再锁定相关的主键索引。 
  4. 在UPDATE、DELETE操作时，MySQL不仅锁定WHERE条件扫描过的所有索引记录，而且会锁定相邻的键值，即所谓的间隙锁(`next-key locking`)。
  5. **死锁产生的场景**。当两个事务同时执行，一个锁住了主键索引，在等待其他相关索引。另一个锁定了非主键索引，在等待主键索引。
  6. 发生死锁后，InnoDB一般都可以检测到，并使一个事务释放锁回退，另一个获取锁完成事务。
     `show engine innodb status` 打印死锁记录
- **避免死锁**
  1. 如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。
  2. 在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率。
  3. 对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率。

### 4.共享锁和排他锁

####4.1共享锁(行级锁)
- **定义**
  
  1. 共享锁又称读锁，是读取操作创建的锁。其他用户可以并发读取数据，但**任何事务都不能对数据进行修改(获取数据上的排他锁)**，**直到已释放所有共享锁**。
2. 如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排他锁。获准共享锁的事务只能读数据，不能修改数据。
  
- **具体用例**
  
  ```sql
  -- 在查询语句后面增加LOCK IN SHARE MODE，Mysql会对查询结果中的每行都加共享锁
  SELECT ... LOCK IN SHARE MODE;
  ```
  1. 当没有其他线程对查询结果集中的任何一行使用排他锁时，可以成功申请共享锁，否则会被阻塞。
  2. 其他线程也可以读取使用了共享锁的表，而且这些线程读取的是同一个版本的数据。


####4.2排他锁(行级锁)
- **定义**
  
  1. 排他锁又称写锁，如果事务T对数据A加上排他锁后，则其他事务**不能再对A加任任何类型的封锁**。
2. 获取排他锁的事务既能读数据，又能修改数据。
  3. 只有当没有其他锁时，共享锁或排他锁，才能获取到排他锁。
  
- **具体用例**
  
  1. 当没有其他线程对查询结果集中的任何一行使用排他锁时，可以成功申请排他锁，否则会被阻塞。
  ```sql
  -- 在查询语句后面增加FOR UPDATE，Mysql会对查询结果中的每行都加排他锁。
  SELECT ... FOR UPDATE;
  ```
  

####4.3意向锁(表级锁)
- **定义**
  
  1. 意向共享锁(IS)，表示事务准备给数据行加入共享锁，也就是说一个数据行加共享锁前必须先取得该表的IS锁。
  2. 意向排他锁(IX)，表示事务准备给数据行加入排他锁，说明事务在一个数据行加排他锁前必须先取得该表的IX锁。
3. 意向锁是InnoDB自动加的，不需要用户干预。
  
- **具体用例**
  
  1. 对于Insert、Update、Delete语句，InnoDB会自动给涉及的数据加排他锁(X)。
  2. 对于一般的Select语句，InnoDB不会加任何锁。
  ```sql
  -- 事务可以显示加共享锁或排他锁
  -- 共享锁
  SELECT ... LOCK IN SHARE MODE;
  -- 排他锁
  SELECT ... FOR UPDATE;
  ```

### 5.悲观锁和乐观锁

####5.1悲观锁
- **定义**
  
  1. 在关系数据库管理系统里，悲观并发控制(悲观锁)是一种并发控制的方法。
  2. 可以阻止一个事务以影响其他用户的方式来修改数据。如果一个事务执行的操作的某行数据应用了锁，那只有当这个事务把锁释放，其他事务才能够执行与该锁冲突的操作。
3. 悲观并发控制主要用于数据争用激烈的环境，以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中。
  
- **悲观锁使用流程**
  
  1. 在对任意记录进行修改前，先尝试为该记录加上排他锁(`exclusive locking`)。
  2. 如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。 具体响应方式由开发者根据实际需要决定。
  3. 如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。
4. 其间如果有其他对该记录做修改或加排他锁的操作，都会等待解锁或直接抛出异常。
  
- **具体实例**
  
  ```sql
  -- 1.开始事务的三种方式
  begin; 
  begin work;
  start transaction;
  -- 2.查询出商品信息
  select status from t_goods where id=1 for update;
  -- 3.根据商品信息生成订单
  insert into t_orders(id,goods_id) values(null,1);
  -- 4.修改商品status为2
  update t_goods set status=2;
  -- 5.提交事务的两种方式
  commit;
  commit work;
  ```
  1. 在InnoDB中使用悲观锁，必须关闭mysql数据库的自动提交属性。
  2. 因为MySQL默认使用autocommit模式，当执行一个更新操作后，MySQL会立刻将结果进行提交。
     `set autocommit=0; -- 关闭自动提交模式`
3. InnoDB默认行级锁。行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住。
  
- **缺点**
  
  1. 悲观并发控制实际上是`先取锁再访问`的保守策略，为数据处理的安全提供了保证。
  2. **在效率方面**，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会。
  3. 在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载。
  4. **会降低了并行性**，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数。

####5.2乐观锁
- **定义**
  
  1. 乐观锁(Optimistic Locking)相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突。
  2. 所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测。如果冲突，则让返回用户错误的信息，让用户决定如何去做。
3. 相对于悲观锁，在对数据库进行处理的时候，**乐观锁并不会使用数据库提供的锁机制**。一般的**实现乐观锁的方式就是记录数据版本**。
  
- **实现流程**
  
  1. 数据版本,为数据增加的一个版本标识。当读取数据时，将版本标识的值一同读出。
  2. 数据每更新一次，同时对版本标识进行更新。
  3. 当提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的版本标识进行比对。
  4. 如果数据库表当前版本号与第一次取出来的版本标识值相等，则予以更新，否则认为是过期数据。
  5. **实现数据版本有两种方式，第一种是使用版本号，第二种是使用时间戳**。
   使用版本号时，可以在数据初始化时指定一个版本号，每次对数据的更新操作都对版本号执行+1操作。并判断当前版本号是不是该数据的最新的版本号。
  
- **具体实例**
  
  ```sql
  -- 1.查询出商品信息
  select status,version from t_goods where id=1;
  -- 2.根据商品信息生成订单
  -- 3.修改商品status为2
  update t_goods set status=2,version=version+1 where id=#{id} and version=#{version};
  ```
- **优点和不足**
  
  1. 乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的。
  2. 优点是，先实现语句直到提交的时候才去锁定，所以**不会产生任何锁和死锁**。
  3. 可能会遇到不可预期的结果，例如两个事务都读取了数据库的某一行，经过修改以后写回数据库，会产生争抢锁的场景。

### 6.事务的隔离性

#### 6.1事务隔离性实现原理

- **数据库事务会导致脏读、不可重复读和幻影读等问题**
  1. 脏读：一个事务可以读取另一个尚未提交事务的修改数据。
  2. 不可重复读：在同一个事务中，同一个查询在T1时间读取某一行，在T2时间重新读取这一行时候，这一行的数据已经发生修改，可能被更新了(update)，也可能被删除了(delete)(**具体某一行数据**)
  3. 幻影数据：在同一事务中，同一查询多次进行时候，由于其他插入操作(insert)的事务提交，导致每次返回不同的结果集。(**范围数据**)

- **InnoDB提供了四种不同级别的机制保证数据隔离性** 
  1. 事务的隔离用是通过锁机制实现的，不同于`MyISAM`使用表级别的锁，`InnoDB`采用更细粒度的行级别锁，提高了数据表的性能。
  2. InnoDB的锁通过锁定索引来实现，如果查询条件中有主键则锁定主键，如果有索引则先锁定对应索引然后再锁定对应的主键(可能造成死锁)，如果连索引都没有则会锁定整个数据表。


#### 6.2事务的隔离级别

- **ANSI SQL标准定义的四个隔离级别为**
  
  1. **READ UNCOMMITTED(未提交读)脏读**
  - 事务中的修改，即使没有提交，在其他事务也都是可见的。事务可以读取未提交的数据，这也被称为脏读。
  - 原理：READ UNCOMMIT不会采用任何锁。
  2. **READ COMMITTED(提交读)解决脏读**
  - 一个事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的。
  - 这个级别有时候也叫做不可重复读，因为两次执行相同的查询，可能会得到不一样的结果。
  - 因为在这2次读之间可能有其他事务更改这个数据，每次读到的数据都是已经提交的。
  - 原理：数据的读是不加锁的，但是数据的写入、修改、删除加锁，避免了脏读。
  3. **REPEATABLE READ(可重复读)**
  - 解决了脏读和不可重复读，也保证了在同一个事务中多次读取同样记录的结果是一致的。
  - 但是可重读读隔离级别，还是无法解决另外一个幻读的问题，指的是当某个事务在读取某个范围内的记录时，另外一个事务也在该范围内插入了新的记录，当之前的事务再次读取该范围内的记录时，会产生幻行。
  - 原理：对具体某一行数据的读、写都会加锁，当前事务如果占据了锁，其他事务必须等待本次事务提交完成释放锁后才能对相同的数据行进行操作。
  4. **SERIALIZABLE(可串行化)**
  
  - 通过强制事务串行执行，同步执行，避免了前面说的幻读的问题
  
- **InnoDB的锁**

  1. InnoDB采用MVCC来支持高并发，并实现了四个标准的隔离级别。
  2. 其默认级别是REPEATABLE READ(可重复读)，并且**通过间隙锁(next-key locking)策略防止幻读的出现**。
  3. 间隙锁使得InnoDB不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定，以防止幻影的插入。
  4. 隔离级别越低，事务请求的锁越少或保持锁的时间就越短。
  5. 所以很多数据库系统默认的事务隔离级别是READ COMMITTED。质疑SERIALIZABLE隔离级别的性能，但是InnoDB存储引擎认为两者的开销是一样的，所以默认隔离级别使用REPEATABLE READ。

- **隔离级别的设置**

  1. 用命令设置当前会话或全局会话的事务隔离级别。
  ```sql
  SET [GLOBAL | SESSION] TRANSACTION ISOLATION LEVEL 
  {
      READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE
  }
  ```

  2. 如果想启动时就设置事务的默认隔离级别，修改MYSQL的配置文件，在[mysqld]中添加如下行：
  `[mysqld]`
  `transaction-isolation = READ-COMMITTED`



### 7. MVCC机制

#### 7.1基本介绍

- **定义**
  1. MVCC就是多版本并发控制，是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问。
  2. 并发访问(读或者写)数据库时，对正在事务内处理的数据做多版本的管理，用来避免由于写操作的堵塞，而引发读操作失败的并发问题。
  3. 典型的有乐观并发控制和悲观并发控制。

- **MVCC作用**
  1. 大多数的MYSQL事务型存储引擎，如InnoDB，Falcon以及PBXT不仅仅使用一种简单的行锁机制。
  2. 一般情况，都和MVCC–多版本并发控制来一起使用。
  3. 锁机制可以控制并发操作，但其系统开销较大。而MVCC可以在大多数情况下代替行级锁，使用MVCC能降低其系统开销。

- **锁实现并发**
  1. **数据库通常使用锁来实现隔离性**。最原生的锁，锁住一个资源后会禁止其他任何线程访问同一个资源。
  2. 应用一般都是读多写少，数据的读取次数远大于修改的次数，而读取数据间互相排斥显得不是很必要。
  3. 数据库使用**读写锁机制**，读锁和读锁之间不互斥(共享锁)，而写锁和写锁、读锁都互斥(排他锁)，提升了系统并发能力。

- **MVCC实现并发**
  1. **锁实现了并发读，MVCC在此之上，解决并发读写的问题**。
  2. 具体实现是，读取数据时通过一种类似快照的方式将数据保存下来。读锁和写锁不冲突，不同的事务session会看到特定版本的数据。
  3. 快照是一种概念模型，不同的数据库可能用不同的方式来实现这种功能。

- **InnoDB中的MVCC**
  1. `MVCC`只在`READCOMMITTED`(提交读/写锁)和`REPEATABLEREAD`(可重复读/读写锁)两个隔离级别下工作。
  2. 其他两个隔离级别够和`MVCC`不兼容,因为`READUNCOMMITTED`(不提交读/不加锁)总是读取最新的数据行,而不是符合当前事务版本的数据行。而`SERIALIZABLE`(串行化/不并发)则会对所有读取的行都加锁。

#### 7.2MVCC的具体实现

- **InnoDB的MVCC实现**
  
  1. InnoDB的MVCC，是通过在每行记录后面保存两个隐藏的列来实现的。
  2. 两个列，一个保存的是**行的创建时间**，一个保存的是**行的删除时间**。
  3. 行的删除时间，并不是实际的时间值，而是系统版本号(可以理解为事务的ID)。开始一个新的事务，系统版本号就会自动递增，事务开始时刻的系统版本号会作为事务的ID。
  
- **在可重复读隔离级别下-MVCC具体的操作**

  1. **INSERT语句为新插入的每一行保存当前系统版本号作为版本号.**
     
     ```sql
     start transaction;
     insert into yang values(NULL,'yang');
     insert into yang values(NULL,'long');
     insert into yang values(NULL,'fei');
     commit;
  ```
     
  2. **SELECT语句**
     
     - InnoDB会根据两个条件检查每行记录。
     - 第一个是，只会查找**版本早于当前事务版本的数据行**(也就是,行的系统版本号小于或等于事务的系统版本号)。可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的，就是修改之前的。
     - 第二个是，**行的删除版本要么未定义，要么大于当前事务版本号**(就是说删除版本是在当前版本之后的)，这可以确保事务读取到的行，在事务开始之前未被删除。
  - 只有两条同时满足的记录，才能返回作为查询结果。
     
  3. **DELETE语句**
     
  - InnoDB会为删除的每一行保存当前系统的版本号(事务的ID)作为删除标识。
     
  4. **UPDATE语句**
     
     - InnoDB执行UPDATE语句实际上是新插入了一行记录，并保存其创建时间为当前事务的ID。
     - 同时保存当前事务ID，到要UPDATE的行的删除时间。(就是创建版本和删除版本都为当前的事务ID)。

