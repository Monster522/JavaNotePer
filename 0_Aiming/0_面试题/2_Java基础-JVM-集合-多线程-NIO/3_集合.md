## Collection接口

###1.Collection 有什么子接口、有哪些具体的实现

- **子接口**

  List、Set、Queue三个子接口，Map接口不属于Collection

- **具体的实现**

  |       | HashTable(哈希表) | ResizableArray(变长数组) | BalancedTree | Linked List(链表) | 哈希表+链表   |
  | ----- | ----------------- | ------------------------ | ------------ | ----------------- | ------------- |
  | List  |                   | ArrayList                |              | LinkedList        |               |
  | Set   | HashSet           |                          | TreeSet      |                   | LinkedHashSet |
  | Map   | HashMap           |                          | TreeMap      |                   | LinkedHashMap |
  | Deque |                   | ArrayDeque               |              | LinkedList        |               |

###2.集合在迭代的过程中，插入或删除数据会怎样？

- **没有使用迭代器Iterator** 
  1. 当插入的时候，不能遍历到所有的元素。
  2. 当删除数据时，会发生数组越界的异常，ArrayIndexOutOfBoundsException是运行时异常。
- **使用迭代器Iterator**
  1. 迭代器是在容器的数据视图之上进行迭代，因此**不能在迭代过程中修改容器中的数据**，否则会抛出异常。除非使用迭代器的专用方法对数据进行修改。
  2. 实际上，Iterator迭代的“集合”是真正集合的视图，视图和真实数据之间是一一映射的关系。
  3. 如果此时使用非迭代器方法对真实数据进行修改就会导致真实数据和映像之间不一致，因此会抛出异常。
  4. 迭代器的修改方法可以保证映射的一致性，即迭代器先对视图进行修改，然后将视图的修改更新到真实数据。
  5. 反向就是无效的，因为映像自己是知道关联的是哪个真实数据，但是真实数据本身不知道有哪些映像和我关联的。即真实数据永远是被动的，而映像是主动的。

###3.在集合中，JDK1.8比1.7改进了什么方面？

- **HashMap**

  1. 数据结构。在哈希冲突时，使用链表+红黑树，取代了链表。

     <img src=" https://user-gold-cdn.xitu.io/2018/3/12/16217d714525211d?imageslim"  />

  2. 获取数据。

     ![](https://user-gold-cdn.xitu.io/2018/3/12/16217d7167830234?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

  3. 扩容机制。使用尾插法替代头插法，防止并发环形链表的问题。

     ![](https://user-gold-cdn.xitu.io/2018/3/12/16217d71685c05a4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

- **ConcurrentHashMap**

  1. 使用CAS+synchronized，替代了分段锁。

## ArrayList

###1.简单介绍下 ArrayList 怎么实现，加操作、取值操作？

- **底层数据结构**
  1. 底层是通过动态数组实现的，是一个Object数组。
  2. 数组的实际长度为capacity，存放元素的个数为size，size不能超过capacity。
  3. 如果capacity不足以存放元素，则会自动扩容。
- **初始化**
  1. `ArrayList`定义了一个私有的未被序列化的`Object`数组`elementData`，用来存储`ArrayList`的对象列表(只定义未初始化)
  2. 带正整数的构造方法中，以指定初始容量(Capacity)，或把指定的`Collection`转换为引用型数组后，实例化`elementData`数组。
  3. 空构造方法，默认构造一个空的数组。进行add()添加元素时，预置初始容量为10进行实例化。
  4. 带`Collection`实例的构造方法，先把集合转换成数组`Arrays.copyOf()浅拷贝`，然后通过`copyOf`方法覆盖原数组，进行数组的实例化。
- **加操作(首次添加初始化)**
  1. 当添加元素时，size值加1，进行数组长度的调整。
  2. 根据size值，计算此次插入元素所需的最小容量。当底层数组为空数组时，返回`10和所需容量`的最大值，作为最小容量。
  3. 当最小容量大于当前数组容量，进行数组长度的调整。(当前容量为0,最小默认容量为10)**[扩容的时机]**
  4. 计算扩充后容量 `oldCapacity+(oldCapacity/2)` (扩充后容量为0,最小容量为10)**[扩容的过程]**
  5. 如果扩充后的容量 小于 最小容量, 则扩充后的容量修改为最小容量,否则为扩充后容量.(扩充后容量0修改为10)
  6. 计算扩充后容量最大值溢出问题.(10 小于 MAX_ARRAY_SIZE)
  7. Arrays.copyOf()方法将旧有数组,复制到扩充容量后的数组. (将当前数组复制到容量为10的数组,元素不变)
  8. 将要添加的元素，赋值到`elementData[size++] = e;`
- **取值操作**
  1. 检查索引是否越界。
  2. 直接返回数组索引处的元素。
- **删除操作**
  1. 通过`System.arraycopy`方法，将待删除元素后面的数组，往左移动一位。
  2. 将数组`size-1`位元素，设置为null。
  3. 返回被删除的元素。

### 2.深拷贝和浅拷贝

- **定义**

  1. 对于基本数据类型,只存在栈内存,所以它的拷贝不存在深浅拷贝这个概念。
  2. 对于对象而言,一个对象的创建会在内存中分配两块空间,一个在栈内存存对象的引用指针,一个在堆内存存放对象。如果拷贝的是栈中的指针，则是浅拷贝。如果拷贝的是堆内存的内容，则是深拷贝。

- **数组拷贝方法**

  1. `Arrays.copyOf()`用来进行数组的拷贝，底层实现是`System.arraycopy`。
  2. `Arrays.copyOf()`是在其内部创建了一个相同类型的新数组，然后调用`System.arraycopy()`复制元素，最后返回出去的是这个新数组。
  3. 不过`Arrays.copyOf()`方法是一个浅拷贝。
  
  

## HashMap

###1.HashMap底层存储的原理 

- **哈希表的基本实现**

  1. 声明`Map`对象后,内部哈希表还没有初始化。当调用第一个`put()`方法时,才会初始化哈希表。

  2. 在每个数组元素上都一个链表结构。当数据被`Hash`后，得到数组下标，把数据放在对应下标元素的链表上。

  3. `Hash`算法计算结果越分散均匀，Hash碰撞的概率就越小，map的存取效率就会越高。

  4. 哈希桶数组较大，较差的hash算法也会比较分散，但是所占的空间就比较大。哈希桶数组较小，要求的hash算法也比较高，否则哈希碰撞会变多，花费的时间会变长。

     

- **确定哈希表位置的算法**

  哈希算法分为三步：取key的hashCode值、高位运算、取模运算

  ```java
  /**
  * hash()和indexFor()方法
  * jdk1.8改进了hash()方法,删除了1.7的indexFor()方法
  **/
  static final int hash(Object key) {   
      int h;
      // h = key.hashCode() 为第一步 取hashCode值   默认实现是一个本地方法
      // h ^ (h >>> 16)     为第二步 高位参与运算
      return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
  }
  
  static int indexFor(int h, int length) {  
      // h & (length-1)     为第三步 取模运算
      return h & (length-1);  
  }
  ```

  - **高位参与运算(扰动函数)以及取模运算**

    ![](https://javanote.oss-cn-shenzhen.aliyuncs.com/9_哈希算法.jpg)

    1. `Object`类的`hashCode()`方法一般返回32bit的哈希值。

    2. h ^ (h >>> 16) ：哈希值右位移16位，正好是32bit的一半。然后将本身的高半区和低半区做异或，是为了 **混合原始哈希码的高位和低位，以此来加大低位的随机性，减少碰撞率**。

       **与运算是提取共同特征，或运算是综合各自特征，异或运算是只提取不同特征，舍弃共同特征。**

    3. ( n-1 ) & hash： HashMap的数组长度要取2的整次幂 ，这样低位都是“11111”，相当于一个“低位掩码”，只提取hash值的低位特征。而且**数组索引不会超过数组的长度**。
    
       

- **初始化哈希表put()方法**

  1. 传入一个`key`，通过哈希算法计算出散列表(哈希桶)的索引。

  2. 如果散列表当前索引处`(table[i])`为`null`，则新建一个节点当做链表的头结点。

  3. 如果`table[i]`不为`null`，判断头结点与插入值的key是否相等，如果相等则更新value值。

  4. 如果头结点`key`不相等，判断头结点是否为红黑树，如果是则将结点传入树内。如果不是，进入链表循环筛选。

  5. 判断头结点`p.next`是否为空，如果为空则插入当前键值对。判断链表长度，如果大于等于8则转为红黑树处理。

  6. 如`果p.next`不为空，则判断这个节点是否等于key，如果是则更新value值，如果不是则继续下一个节点。

  7. 如果e值为空则说明新建了一个节点，将size的长度增加1并检查散列表长度是否需要扩容。如果e值不为空，则说明用新value值覆盖了旧value值,返回旧value值,不用增加size的长度。

     

- **数组动态扩容**

  1. 扩容(resize)就是重新计算容量，向HashMap对象里不停的添加元素。

  2. 当HashMap的散列表超过阈值时，就需要扩大数组长度。Java的数组是无法自动扩容的，只有使用一个新的数组代替已有的容量小的数组。

     - 当 size > threshold 的时候进行扩容。
     - 扩容之后的 table.length = 旧 table.length * 2。
     - 扩容之后的 threshold = 旧 threshold * 2。
     
  3. 数组扩容后，原本散列表的元素需要重新计算索引再插入到散列表中。

     

- **JDK1.8重建数组元素的过程**

  <img src="https://javanote.oss-cn-shenzhen.aliyuncs.com/10_map扩容.png" style="zoom:50%;" />

  1. 如果索引处只有一个元素，则保持原样。

  2. 如果索引处是红黑树，则交给红黑树解决。

  3. 如果索引处是链表。判断元素是否大于旧数组长度，如果小于则不动，如果大于等于则移动到 原索引+旧数组长度的位置。会将原链表拆分成两个链表，链表元素不会倒置。

     

- **JDK1.7重建数组元素的过程**

  <img src="https://javanote.oss-cn-shenzhen.aliyuncs.com/11_jdk7重建数组元素.png" style="zoom: 50%;" />

  1. 新建扩容后的数组对象。
  2. 将旧数组对象中的元素全部取出，重新计算索引后插入新的数组对象中。
  3. 重建后的数组元素，如果还处于同一个链表中，则会倒置。

     

###2. 哈希表怎么处理冲突?

- **哈希冲突定义**
  1. 如果两个输入串的hash函数的值是一样的，则称这两个串是一个哈希碰撞。
- **解决哈希冲突的两种方法**
  - **开放寻址**
    1. 根据key的哈希值计算出存储的表索引。如果已经被占据，则通过一定的寻找方式来找到空白的索引点。如果最后找不到，则扩充表。
    2. 一个索引地址只能存放一个值。适合数量确定，冲突比较少的情况。

  - **分离链接**
    1. 将哈希表的每个索引作为一个链表的头结点。当插入的`key2`计算出的索引已经被`key1`占据时,则将`key2`插入到`key1`后面,共同存放在一个索引下。
    2. 一个索引地址可以存放多个值，每个索引都可以当做一个链表。如果链表过长,也需要扩充表索引。
    3. 查找值的时候,则需先查索引,再遍历该索引下的链表。

  - **采用分离链接的原因**
    1. 数据量小的时候，开放寻址可以加载到缓存，效率比较高。
    2. 数据量大的时候，开放寻址就是一个大型数组，效率低。而当分离链接的链表不长时，时间复杂度就是O(1)。
    3. 在调用remove频繁的情况下，开放寻址会干扰总体的性能。
- **HashMap怎么解决**
  1. 在Java8之前,假设对象的Hash值服从平均分布,那么获取一个对象需要的次数时间复杂度应该是`O(N/M)`。
  2. Java8在没有降低哈希冲突的度的情况下，使用红黑树代替链表，将这个值降低到了`O(log(N/M))`。数据越多,`O(N/M)`和`O(log(N/M))`的差别就会越明显。
  3. 在实际应用中,哈希值有时也会集中在几个特定值上。因此使用平衡树比如红黑树有着比使用链表更强的性能。
  4. 当冲突的元素数增加到8时，链表变为树。当减少至6时，树切换为链表。中间有2个缓冲值的原因是避免频繁的切换浪费计算机资源。

###3.HashMap存在的线程安全问题

- **数据丢失**

  1. 当A线程和B线程，同时对一个key进行赋值。
  2. 肯定会发生A线程或B线程的数据丢失。

- **死循环(JDK1.7的问题)**

  1. 假设链表为3-7-5，然后进行重新散列，3-7将会被散列到同一个哈希桶。
  2. A线程获取到了3，并拿到7，此时被挂起。
  3. B线程完成了扩容，将原Map的链表重新散列到新的表中，并且链表变成了7-3。
  4. A线程继续进行散列，链表此时变成了3-7。
  5. 由于7的next被B线程设置成了3，所以形成了一个环形链表3-7-3。
  6. 当get表中不存在的元素时，造成死循环。
  4. 在JDK1.8中，链表由头插法改成了尾插法，解决了死循环的问题。

  

###4. 说一下红黑树，你平时用的技术哪里用到了它?

- **红黑树的定义**

  1. 每个节点或者是黑色，或者是红色。
  2. 根节点是黑色。
  3. 每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]
  4. 如果一个节点是红色的，则它的子节点必须是黑色的。
  5. 从一个节点到其子孙节点的所有路径上包含相同数目的黑节点，确保没有一条路径会比其他路径长出俩倍。 

  ![](https://images0.cnblogs.com/i/497634/201403/251730074203156.jpg)

- **Java中的应用**

  1. HashMap
  2. TreeMap
  3. ConcurrentMap

###5.红黑树优缺点，为啥不用平衡树，jdk还有哪里用到了红黑树

- **红黑树优点**
  1. 红黑树能够以`O(log2 n)`的时间复杂度进行搜索、插入、删除操作。 
  2. 任何不平衡都会在三次旋转之内解决。
- **AVL树优点**
  1. 查找、插入和删除在平均和最坏情况下都是`O(log n)`。
  2. 增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。 
- **红黑树和AVL区别**
  1. 红黑树相比于AVL树，牺牲了部分平衡性，以换取删除/插入操作时少量的旋转次数，整体来说，性能优于AVL树。 
  2. 写操作复杂度就较AVL要低一点，但是查询的速度要稍慢于AVL。 

## ConcurrentHashMap

###1.ConcurrentHashMap读写加锁吗？

- 同步处理主要是通过`Synchronized`和`unsafe`两种方式来完成的。
  1. 在取得`sizeCtl`、某个位置的`Node`的时候，使用的都是`unsafe`的方法，来达到并发安全的目的。
  2. 当需要在某个位置设置节点的时候，则会通过`Synchronized`的同步机制来锁定该位置的节点。
  3. 在数组扩容的时候，则通过处理的步长和`fwd`节点来达到并发安全的目的，通过设置`hash`值为`MOVED`。
  4. 当把某个位置的节点复制到扩张后的`table`的时候，也通过`Synchronized`的同步机制来保证线程安全。
  
- **读写操作**

  1. 在`get`操作中，根本没有使用同步机制，也没有使用`unsafe`方法，所以读操作是支持并发操作的。

  2. 在`put`操作中，如果哈希表没有元素则通过CAS进行添加，如果发生哈希冲突则通过`Synchronized`进行添加。

     

###2.讲一下 concurrentHashMap 原理。头插法还是尾插法？扩容怎么做？

- **底层原理**

  1. 数据结构为：数组+红黑树+链表。
  2. 确定哈希值：取key的hashCode值、高位运算、取模运算
  3. 解决哈希冲突：设置链表或者红黑树

- **头插法和尾插法**

  1. 头插法会导致循环链表。
  2. 尾插法不会导致循环链表。

- **扩容的时机**

  1. 当发生哈希冲突的元素达到8个，且哈希表长度小于64。
  2. 当哈希表的使用超过了阈值，就是`长度x负载因子`。

- **扩容的过程**

  1. 扩容数组为2的幂次方，获取扩容后数组。

  2. 把数组中的节点复制到新的数组的相同位置,或者移动到扩张部分的相同位置。

  3. 每个CPU最少处理16个长度的数组元素，如果一个数组的长度只有16，那只有一个线程会对其进行扩容的复制移动操作。

  4. 扩容的时候会一直遍历，直到复制完所有节点。每处理一个节点的时候会在链表的头部设置一个fwd节点，其他线程就会跳过他。

  5. 复制后在新数组中的链表不是绝对的反序的。

     

### 3.为什么ConcurrentHashMap不允许null值？

- 第一种原因：如果放入了null，无法通过null来判断原来是否有这个key，方法putIfAbsent()
- 第二种原因：为了取代HashTable，保持行为一致。



##LinkedHashMap

### 1.LRU算法

- **定义**

  1. 在LinkedHashMap中，有插入顺序和访问顺序。

  2. 访问顺序的底层应用的是LRU算法。

     

## PriorityQueue优先级队列

###1.堆是怎么存储的，插入是在哪里？
