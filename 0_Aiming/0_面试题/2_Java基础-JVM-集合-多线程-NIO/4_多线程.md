##多线程基础概念

###1.并发的基本概念

- **并行和并发的区别**
  1. 并行是指，多处理器情况下，多个线程在同一时刻发生，在不同的处理器上同时执行。 侧重于物理。
  2. 并发是指，单处理器情况下，两个或多个线程在同一时间轮流执行。侧重于逻辑。
  3. 串行是指，单处理器情况下，线程一个接一个执行，不能同时执行。 多个串行就可以称为并行，也是侧重于物理上的概念。

###2.进程和线程的区别？了解协程么？

- **进程**
  1. 进程是具有一定独立功能的程序，关于某个数据集合上的一次运行活动。
  2. 进程是系统进行资源分配和调度的一个独立单位。
  3. 每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。
  4. 由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。 
  5. 一个进程可以包含多个线程。同一个进程中的所有线程共享该进程中的资源，如内存空间、文件句柄等。
- **线程**
  1. 线程是进程的一个实体,是CPU调度和分派的基本单位,是比进程更小的能独立运行的基本单位。
  2. 线程基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。
  3. 线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。 
  4. 一个线程可以拥有多个协程。
- **协程**
  1. 协程是一种**用户态的轻量级线程**，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。
  2. 协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。

###3.进程间如何通信：进程 A 想读取进程 B 的主存怎么办？

- **进程A读取进程B的方式**
  1. **[消息队列]** B进程向消息队列写入一个包含变量内容的消息，A进程从队列中读出。
  2. **[套接字]** 通过本地环路通信。
  3. **[命名管道] **如果A、B 非亲属，那么A通过命名管道把这个变量的地址发给B进程。

- **通信方式的分类**
  1. 管道
  2. 系统IPC(包括消息队列、信号量、共享内存)
  3. 套接字SOCKET

- **管道的分类**
  1. 管道分为三种：普通管道PIPE、流管道(s_pipe)、命名管道(name_pipe)。
  2. 管道是一种半双工的通信方式，数据只能单项流动，并且只能在具有亲缘关系的进程间流动，进程的亲缘关系通常是父子进程。
  3. 命名管道也是半双工的通信方式，它允许无亲缘关系的进程间进行通信。

- **信号量**
  1. 信号量是一个计数器，用来控制多个进程对资源的访问，通常作为一种锁机制。
  2. 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。

- **消息队列**
  1. 消息队列是消息的链表，存放在内核中并由消息队列标识符标识。

- **共享内存**
  1. 共享内存就是映射一段能被其它进程访问的内存，这段共享内存由一个进程创建，但是多个进程可以访问。

- **套接字**
  1. 套接字也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同主机间的进程通信。

### 4.线程间通信的方式

- **进程通信和线程通信的区别**

  1. 进程通信，进程数据空间的独立性决定了它的通信相对比较复杂，需要通过操作系统。
  2. 线程通信，由于多线程共享地址空间和数据空间，所以多个线程间的通信是一个线程的数据可以直接提供给其他线程使用，而不必通过操作系统(也就是内核的调度)。 

- **线程通信方式**

  1. 锁机制，包括互斥锁、条件变量、读写锁。
     - 互斥锁提供了以排他方式防止数据结构被并发修改的方法。
     - 读写锁允许多个线程同时读共享数据，而对写操作是互斥的。
     - 条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。
     
  2. 信号量机制(Semaphore)，包括无名线程信号量和命名线程信号量

  3. 信号机制(Signal)，类似进程间的信号处理

  4. 线程间的通信目的**主要是用于线程同步**，所以线程没有像进程通信中的用于数据交换的通信机制。

  5. 如果需要数据交换，直接定义共享变量即可，但是要注意线程安全问题。

### 5.原子性、可见性和有序性
### 6.重排序出现的场景

### 7.上下文切换的定义



​     

##同步机制-内部锁和显式锁

###1.锁有几种，区别是什么

- **锁的定义**

  锁可以理解为，对线程间共享数据的保护，设计思想是将多个线程对共享数据的并发访问转换为串行访问。

- **锁的分类**

  1. 按照实现可以分为内部锁和显式锁。

     - 内部锁是由虚拟机实现的，通过`synchronized`关键字使用。
     - 显式锁为`Lock`接口，默认实现为可重入锁`ReentrantLock`类，底层原理是AQS。

  2. 按照设计思想可以分为乐观锁和悲观锁。

     - 乐观锁假设获取数据的时候，数据没有被修改，直到更新的时候再判断数据是否被修改过，如果没有就更新。主要是两个步骤，冲突检测和数据更新。

       CAS技术是乐观锁思想的实现，Java中的CAS是基于硬件操作指令。

     - 悲观锁假设获取数据的时候，数据会被修改，所以预先拿到锁再进行数据的修改更新。在持有锁的期间，只有一个线程可以进行数据的修改。

       内部锁和显式锁都是悲观锁思想的实现。

  3. volatile关键字是，在特定条件下可以保护共享数据的机制

     1. 对变量的写操作不依赖于当前值。
     2. 该变量没有包含在具有其他变量的不变式中。

- **内部锁和显式锁的区别**

  见同步机制

###2.synchronized底层实现原理

###3.JVM对锁的优化，自旋锁和自适应自旋，为什么需要自旋？

###4.偏向锁，轻量级锁，重量级锁？

- 234三个问题，见文件synchronized原理

  

###5.Lock接口有哪些锁？

![](https://javanote.oss-cn-shenzhen.aliyuncs.com/12_Lock接口继承.png)

###4.ReentrantLock的应用场景

- 可重入锁代表着，可以去重入，可以被重入。

  1. 可以去重入，就是递归调用。

  2. 可以被重入，就是子类可以调用父类的方法。
  3. 其实并不存在父类锁或子类锁，例如synchronized内部锁是对实例加锁，就是子类对象是持有父类的引用的，所以其实父类和子类只有一个锁。

###5.RenntrantLock和AQS的实现原理
###6.AQS 有那些实现？

- 见Reentrantlock和AQS的原理

###11.volatile 关键字有什么用？怎么理解可见性，一般什么场景去用可见性

- **volatile保障了可见性**

  1. 读取一个volatile关键字修饰的变量，会使相应的处理器执行刷新处理器缓存的动作。
  2. 写一个volatile关键字修饰的变量，会使相应的处理器执行冲刷处理器缓存的动作，从而保障了可见性。

- **可见性的定义**

  可见性是一个线程对共享变量的更新的结果，对于读取相应共享变量的线程而言是否可见。

- **volatile保障了有序性**

  1. 在读操作之后，插入一个获取屏障，防止读操作和之后的读写操作进行重排序。
  2. 在写操作之前，插入一个释放屏障，防止写操作和之前的读写操作进行重排序。

###14.讲讲AtomicInteger的底层实现

- 主要是通过volatile变量，和CAS硬件指令进行线程安全的更新


##线程间协作

###1.线程的生命周期有哪些状态？怎么转换？

![](https://javanote.oss-cn-shenzhen.aliyuncs.com/1_线程生命周期状态.png)

###2.线程状态讲一下, wait和block什么区别

- waitint状态是执行了某些特定方法进入的，比如Object. wait() 、Thread.join()和LockSupport.park(Object)。可以通过Object.notify()/notify All()和LockSupport.unpark(Object))等方法进行唤醒，转换为就绪的状态。
- blocking状态是执行了阻塞IO或者要获取锁导致的，只有当获取到相应的资源后才能够转换为诶就绪状态。

###3.wait 和 sleep 有什么区别？什么情况下会用到 sleep？

- wait会让出锁，并且如果没有被唤醒，就不会醒过来。
- sleep不会让出锁，是进入到一个有过期时间的等待状态，时间一到就会转换为就绪状态。

###4.怎么停止线程？

1. 使用退出标志，使线程正常退出，也就是当run方法完成后线程终止。
2. 使用stop方法强行终止，但是不推荐这个方法，因为stop和suspend及resume一样都是过期作废的方法。
3. 使用interrupt方法中断线程。

###5.怎么控制多个线程按序执行？

1. 利用 thread join实现线程顺序执行： 挂起调用join方法的线程的执行，直到被调用的线程执行结束。 

2. 利用 CountDownLatch 控制线程的执行顺序

3. 利用 newSingleThreadExecutor 控制线程的执行顺序：只有一个线程处理任务队列上的任务，先提交的任务必将被先处理。

   

###6.Countdownlatch具体应用

- 开始执行前等待n个线程完成各自任务: 例如table_A、table_B、table_A、table_D统计4个表数量，然后进行统计总数量。 



##线程安全的代码设计技术

###1.ThreadLocal的结构是怎么样的？存储在JVM的哪一部分内存中？
###2.讲一下 threadLocal 原理，threadLocal 是存在 jvm 内存哪一块的



##线程的活性故障-死锁活锁锁死饥饿
###1.死锁条件

- 资源互斥
- 资源不可抢夺
- 占用并等待资源
- 循环等待资源，没有超时机制



##线程的统一管理-线程池线程工厂执行器

###1.ThreadPoolExecutor 有什么参数？各有什么作用？拒绝策略?

```java
/**
* 线程池构造方法
* corePoolSize：用于指定核心线程池大小
* maximumPoolSize：用于指定最大线程池大小
* keepAliveTime：和unit一起,用于指定线程池中空闲(Idle)线程的最大存活时间
* unit：和keepAliveTime一起,用于指定线程池中空闲(Idle)线程的最大存活时间
* workQueue：阻塞队列,被称为工作队列
* threadFactory：指定用于创建工作者线程的线程工厂
* handler：表示当工作队列满且达到最大线程数,客户提交的任务被拒绝时,线程池执行的处理策略
**/
public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,ThreadFactory threadFactory,
                              RejectedExecutionHandler handler) 
```

- 当工作队列满时，且线程池达到最大线程数时，会执行拒绝策略。
| 实现类                                 | 所实现的处理策略                                         |
| -------------------------------------- | -------------------------------------------------------- |
| ThreadPoolExecutor.AbortPolicy         | 直接抛出异常(默认的策略)                                 |
| ThreadPoolExecutor.DiscardPolicy       | 丢弃当前被拒绝的任务(而不抛出任何异常)                   |
| ThreadPoo!Executor.DiscardOldestPolicy | 将工作队列中最老的任务丢弃，然后重新尝试接纳被拒绝的任务 |
| ThreadPoolExecutor.CallerRunsPolicy    | 在客户端线程中执行被拒绝的任务                           |



###2.会用到线程池么？怎么使用的？用什么实现的？

- 当多个任务为互不关联的任务时，可以使用线程池就行处理，再统计结果。

  比如查询3张表，如果每张表查询为4s，多线程执行可以节省8s的时间。再回收所有的运算结果，进行处理返回。

- 线程池的实现有三种

  1. JDK自带线程池

  2. Spring的线程池

  3. Tomcat的线程池

     

###2.常用的线程池有哪些？用的哪个线程池？什么情况下怎么选择？

1. cacheThreadPool：核心线程
2. fix
3. syn
4. sche



###4.一个任务从被提交到被执行，线程池做了哪些工作？

- **ThreadPoolExecutor线程池**
1. 提交一个任务，如果线程小于核心线程，则新建线程执行。
  
2. 如果线程大于核心线程，则扔到阻塞队列中等待执行。
  
3. 如果阻塞队列已满，则新建线程执行。
  
4. 如果线程数已经达到了最大，则执行拒绝策略。


- **线程池主要是三个部分**

  1. 新建工作线程
  
     - **核心线程数`corePoolSize`**
       1. **如果运行的线程少于`corePoolSize`，则创建新线程来处理请求**，即使其他辅助线程是空闲的。 
     - **阻塞队列大小`maxPoolSzie`** 
       1. 如果运行的线程多于`corePoolSize`而少于`maximumPoolSize`，则仅当阻塞队列满时才创建新线程。
       2. 如果设置的`corePoolSize`和`maximumPoolSize`相同，相当于创建了固定大小的线程池。 
       3. 如果将`maximumPoolSize`设置为基本的无界值(如`Integer.MAX_VALUE`)，则允许池适应任意数量的并发任务。
  
  2. 工作线程执行任务
  
     - worker执行时加锁的原因，以及实现不可重入锁的原因。
     - **引起worker退出的原因**
       1. 阻塞队列已经为空，即没有任务可以运行了。 
       2. 调用了`shutDown`或`shutDownNow`函数。
     - 在`getTask()`函数中，从阻塞队列中获取下一个任务。如果当前线程超过了核心线程，就会有超时控制。一旦超时，工作线程就会尝试中断
  
  3. 关闭线程池
  
     1. 按过去执行已提交任务的顺序发起一个有序的关闭，但是不接受新任务。
     2. 首先会检查是否具有shutdown的权限，然后设置线程池的控制状态为`SHUTDOWN`，之后中断空闲的`worker`。
     3. 最后尝试终止线程池。
  
     - **shutdown()和shutdownNow()区别**
       1. `shutdownNow`会尝试停止所有的活动执行任务、暂停等待任务的处理，并返回等待执行的任务列表，
       2. 但是其会终止所有的`worker`，而并非空闲的`worker`。 
  
     